{"config":{"lang":["en","zh"],"separator":"[\\s\\u200b\\-]","pipeline":["stemmer"]},"docs":[{"location":"","title":"MultiMolecule","text":"<ul> <li>zyc date: 2024-05-04 00:00:00</li> </ul>"},{"location":"#multimolecule","title":"MultiMolecule","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to MultiMolecule (\u200b\u6d66\u539f\u200b), a foundational library designed to accelerate Scientific Research with Machine Learning. MultiMolecule aims to provide a comprehensive yet flexible set of tools for researchers who wish to leverage AI in their work.</p> <p>We understand that AI4Science is a broad field, with researchers from different disciplines employing various practices. Therefore, MultiMolecule is designed with low coupling in mind, meaning that while it offers a full suite of functionalities, each module can be used independently. This allows you to integrate only the components you need into your existing workflows without adding unnecessary complexity. The key functionalities that MultiMolecule provides include:</p> <ul> <li><code>data</code>: Efficient data handling and preprocessing capabilities to streamline the ingestion and transformation of scientific datasets.</li> <li><code>modules</code>: Modular components designed to provide flexibility and reusability across various machine learning tasks.</li> <li><code>models</code>: State-of-the-art model architectures optimized for scientific research applications, ensuring high performance and accuracy.</li> <li><code>tokenisers</code>: Advanced tokenization methods to effectively handle complex scientific text and data representations.</li> <li><code>utils</code>: A collection of utility functions and tools to simplify common tasks and enhance the overall user experience.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install the most recent stable version on PyPI:</p> Bash<pre><code>pip install multimolecule\n</code></pre> <p>Install the latest version from the source:</p> Bash<pre><code>pip install git+https://github.com/DLS5-Omics/MultiMolecule\n</code></pre>"},{"location":"#license","title":"License","text":"<p>We believe openness is the Foundation of Research.</p> <p>MultiMolecule is licensed under the GNU Affero General Public License.</p> <p>Please join us in building an open research community.</p> <p><code>SPDX-License-Identifier: AGPL-3.0-or-later</code></p>"},{"location":"models/","title":"models","text":"<ul> <li>Zhiyuan Chen date: 2024-05-04</li> </ul>"},{"location":"models/#models","title":"Models","text":"<p><code>models</code> provide a collection of pre-trained models.</p>"},{"location":"models/#model-class","title":"Model Class","text":"<p>In the <code>transformers</code> library, the names of model classes can sometimes be misleading. While these classes support both regression and classification tasks, their names often include <code>xxxForSequenceClassification</code>, which may imply they are only for classification.</p> <p>To avoid this ambiguity, MultiMolecule provides a set of model classes with clear, intuitive names that reflect their intended use:</p> <ul> <li><code>multimolecule.AutoModelForContactPrediction</code>: Contact Prediction</li> <li><code>multimolecule.AutoModelForNucleotidePrediction</code>: Nucleotide Prediction</li> <li><code>multimolecule.AutoModelForSequencePrediction</code>: Sequence Prediction</li> <li><code>multimolecule.AutoModelForTokenPrediction</code>: Token Prediction</li> </ul> <p>Each of these models supports both regression and classification tasks, offering flexibility and precision for a wide range of applications.</p>"},{"location":"models/#nucleotide-prediction","title":"Nucleotide Prediction","text":"<p>Similar to Token Classification, but removes the <code>&lt;bos&gt;</code> token and the <code>&lt;eos&gt;</code> token if they are defined in the model config.</p> <p><code>&lt;bos&gt;</code> and <code>&lt;eos&gt;</code> tokens</p> <p>In tokenizers provided by MultiMolecule, <code>&lt;bos&gt;</code> token is pointed to <code>&lt;cls&gt;</code> token, and <code>&lt;sep&gt;</code> token is pointed to <code>&lt;eos&gt;</code> token.</p>"},{"location":"models/#usage","title":"Usage","text":""},{"location":"models/#build-with-multimoleculeautomodels","title":"Build with <code>multimolecule.AutoModel</code>s","text":"Python<pre><code>from transformers import AutoTokenizer\n\nfrom multimolecule import AutoModelForSequencePrediction\n\nmodel = AutoModelForSequencePrediction.from_pretrained(\"multimolecule/rnafm\")\ntokenizer = AutoTokenizer.from_pretrained(\"multimolecule/rnafm\")\n\nsequence = \"UAGCGUAUCAGACUGAUGUUG\"\noutput = model(**tokenizer(sequence, return_tensors=\"pt\"))\n</code></pre>"},{"location":"models/#direct-access","title":"Direct Access","text":"<p>All models can be directly loaded with the <code>from_pretrained</code> method.</p> Python<pre><code>from multimolecule.models import RnaFmForNucleotidePrediction, RnaTokenizer\n\nmodel = RnaFmForNucleotidePrediction.from_pretrained(\"multimolecule/rnafm\")\ntokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rnafm\")\n\nsequence = \"UAGCGUAUCAGACUGAUGUUG\"\noutput = model(**tokenizer(sequence, return_tensors=\"pt\"))\n</code></pre>"},{"location":"models/#build-with-transformersautomodels","title":"Build with <code>transformers.AutoModel</code>s","text":"<p>While we use a different naming convention for model classes, the models are still registered to corresponding <code>transformers.AutoModel</code>s.</p> Python<pre><code>from transformers import AutoModelForSequenceClassification, AutoTokenizer\n\nimport multimolecule  # noqa: F401\n\nmodel = AutoModelForSequenceClassification.from_pretrained(\"multimolecule/mrnafm\")\ntokenizer = AutoTokenizer.from_pretrained(\"multimolecule/mrnafm\")\n\nsequence = \"UAGCGUAUCAGACUGAUGUUG\"\noutput = model(**tokenizer(sequence, return_tensors=\"pt\"))\n</code></pre> <p><code>import multimolecule</code> before use</p> <p>Note that you must <code>import multimolecule</code> before building the model using <code>transformers.AutoModel</code>. The registration of models is done in the <code>multimolecule</code> package, and the models are not available in the <code>transformers</code> package.</p> <p>The following error will be raised if you do not <code>import multimolecule</code> before using <code>transformers.AutoModel</code>:</p> Python<pre><code>ValueError: The checkpoint you are trying to load has model type `rnafm` but Transformers does not recognize this architecture. This could be because of an issue with the checkpoint, or because your version of Transformers is out of date.\n</code></pre>"},{"location":"models/#initialize-a-vanilla-model","title":"Initialize a vanilla model","text":"<p>You can also initialize a vanilla model using the model class.</p> Python<pre><code>from multimolecule.models import RnaFmConfig, RnaFmForNucleotidePrediction, RnaTokenizer\n\nconfig = RnaFmConfig()\nmodel = RnaFmForNucleotidePrediction(config)\ntokenizer = RnaTokenizer()\n\nsequence = \"UAGCGUAUCAGACUGAUGUUG\"\noutput = model(**tokenizer(sequence, return_tensors=\"pt\"))\n</code></pre>"},{"location":"models/#available-models","title":"Available Models","text":""},{"location":"models/#deoxyribonucleic-acid-dna","title":"DeoxyriboNucleic Acid (DNA)","text":"<ul> <li>CaLM</li> </ul>"},{"location":"models/#ribonucleic-acid-rna","title":"RiboNucleic acid (RNA)","text":"<ul> <li>ERNIE-RNA</li> <li>RiNALMo</li> <li>RNABERT</li> <li>RNA-FM</li> <li>RNA-MSM</li> <li>SpliceBERT</li> <li>3UTRBERT</li> <li>UTR-LM</li> </ul>"},{"location":"tokenisers/","title":"tokenisers","text":"<ul> <li>Zhiyuan Chen date: 2024-05-04</li> </ul>"},{"location":"tokenisers/#tokenisers","title":"Tokenisers","text":"<p><code>tokenisers</code> provide a collection of pre-defined tokenizers.</p> <p>A tokenizer is a class that converts a sequence of nucleotides or amino acids into a sequence of indices. It is used to pre-process the input sequence before feeding it into a model.</p> <p>Please refer to Tokenizer for more details.</p>"},{"location":"tokenisers/#available-tokenizers","title":"Available Tokenizers","text":"<ul> <li>RnaTokenizer</li> <li>DnaTokenizer</li> <li>ProteinTokenizer</li> </ul>"},{"location":"models/calm/","title":"CaLM","text":"<p>Pre-trained model on protein-coding DNA (cDNA) using a masked language modeling (MLM) objective.</p>"},{"location":"models/calm/#statement","title":"Statement","text":"<p>Codon language embeddings provide strong signals for use in protein engineering is published in Nature Machine Intelligence, which is a Closed Access / Author-Fee Journal.</p> <p>Machine learning has been at the forefront of the movement for free and open access to research.</p> <p>We see no role for closed access or author-fee publication in the future of machine learning research and believe the adoption of these journals as an outlet of record for the machine learning community would be a retrograde step.</p> <p>The MoltiMolecule team is committed to the principles of open access and open science.</p> <p>We do NOT endorse the publication of manuscripts on Closed Access / Author-Fee Journals and encourage the community to support Open Access Journals.</p> <p>Please consider signing the Statement on Nature Machine Intelligence.</p>"},{"location":"models/calm/#disclaimer","title":"Disclaimer","text":"<p>This is an UNOFFICIAL implementation of the Codon language embeddings provide strong signals for use in protein engineering by Carlos Outeiral and Charlotte M. Deane.</p> <p>The OFFICIAL repository of CaLM is at oxpig/CaLM.</p> <p>The team releasing CaLM did not write this model card for this model so this model card has been written by the MultiMolecule team.</p>"},{"location":"models/calm/#model-details","title":"Model Details","text":"<p>CaLM is a bert-style model pre-trained on a large corpus of protein-coding DNA sequences in a self-supervised fashion. This means that the model was trained on the raw nucleotides of DNA sequences only, with an automatic process to generate inputs and labels from those texts. Please refer to the Training Details section for more information on the training process.</p>"},{"location":"models/calm/#model-specification","title":"Model Specification","text":"Num Layers Hidden Size Num Heads Intermediate Size Num Parameters (M) FLOPs (G) MACs (G) Max Num Tokens 12 768 12 3072 85.75 22.36 11.17 1024"},{"location":"models/calm/#links","title":"Links","text":"<ul> <li>Code: multimolecule.calm</li> <li>Weights: multimolecule/calm</li> <li>Data: European Nucleotide Archive</li> <li>Paper: Codon language embeddings provide strong signals for use in protein engineering</li> <li>Developed by: Carlos Outeiral, Charlotte M. Deane</li> <li>Model type: BERT - ESM</li> <li>Original Repository: https://github.com/oxpig/CaLM</li> </ul>"},{"location":"models/calm/#usage","title":"Usage","text":"<p>The model file depends on the <code>multimolecule</code> library. You can install it using pip:</p> Bash<pre><code>pip install multimolecule\n</code></pre>"},{"location":"models/calm/#direct-use","title":"Direct Use","text":"<p>You can use this model directly with a pipeline for masked language modeling:</p> Python<pre><code>&gt;&gt;&gt; import multimolecule  # you must import multimolecule to register models\n&gt;&gt;&gt; from transformers import pipeline\n&gt;&gt;&gt; unmasker = pipeline('fill-mask', model='multimolecule/calm')\n&gt;&gt;&gt; unmasker(\"gcc&lt;mask&gt;cgctgacagccgcgg\")\n\n[{'score': 0.049356844276189804,\n  'token': 42,\n  'token_str': 'CGC',\n  'sequence': 'GCC CGC CGC UGA CAG CCG CGG'},\n {'score': 0.038425520062446594,\n  'token': 67,\n  'token_str': 'GGC',\n  'sequence': 'GCC GGC CGC UGA CAG CCG CGG'},\n {'score': 0.031837038695812225,\n  'token': 62,\n  'token_str': 'GCC',\n  'sequence': 'GCC GCC CGC UGA CAG CCG CGG'},\n {'score': 0.02501658722758293,\n  'token': 32,\n  'token_str': 'CAC',\n  'sequence': 'GCC CAC CGC UGA CAG CCG CGG'},\n {'score': 0.024257611483335495,\n  'token': 37,\n  'token_str': 'CCC',\n  'sequence': 'GCC CCC CGC UGA CAG CCG CGG'}]\n</code></pre>"},{"location":"models/calm/#downstream-use","title":"Downstream Use","text":""},{"location":"models/calm/#extract-features","title":"Extract Features","text":"<p>Here is how to use this model to get the features of a given sequence in PyTorch:</p> Python<pre><code>from multimolecule import RnaTokenizer, CaLmModel\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/calm')\nmodel = CaLmModel.from_pretrained('multimolecule/calm')\n\ntext = \"GCCAGTCGCTGACAGCCGCGG\"\ninput = tokenizer(text, return_tensors='pt')\n\noutput = model(**input)\n</code></pre>"},{"location":"models/calm/#sequence-classification-regression","title":"Sequence Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for sequence classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a sequence-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, CaLmForSequencePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/calm')\nmodel = CaLmForSequencePrediction.from_pretrained('multimolecule/calm')\n\ntext = \"GCCAGTCGCTGACAGCCGCGG\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.tensor([1])\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/calm/#nucleotide-classification-regression","title":"Nucleotide Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for nucleotide classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a nucleotide-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, CaLmForNucleotidePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/calm')\nmodel = CaLmForNucleotidePrediction.from_pretrained('multimolecule/calm')\n\ntext = \"GCCAGTCGCTGACAGCCGCGG\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.randint(2, (len(text), ))\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/calm/#training-details","title":"Training Details","text":"<p>CaLM used Masked Language Modeling (MLM) as the pre-training objective: taking a sequence, the model randomly masks 25% of the tokens in the input then runs the entire masked sentence through the model and has to predict the masked tokens. This is comparable to the Cloze task in language modeling.</p>"},{"location":"models/calm/#training-data","title":"Training Data","text":"<p>The CaLM model was pre-trained coding sequences of all organisms available on the European Nucleotide Archive (ENA). European Nucleotide Archive provides a comprehensive record of the world\u2019s nucleotide sequencing information, covering raw sequencing data, sequence assembly information and functional annotation.</p> <p>CaLM collected coding sequences of all organisms from ENA on April 2022, including 114,214,475 sequences. Only high level assembly information (dataclass CON) were used. Sequences matching the following criteria were filtered out:</p> <ul> <li>with unknown nucleotides (<code>N</code>, <code>Y</code>, <code>R</code>)</li> <li>start codon is not <code>ATG</code></li> <li>contains interstitial stop codons</li> <li>number of nucleotides is not a multiple of three</li> </ul> <p>To reduce redundancy, CaLM grouped the entries by organism, and apply CD-HIT (CD-HIT-EST) with a cut-off at 40% sequence identity to the translated protein sequences.</p> <p>The final dataset contains 9,858,385 cDNA sequences.</p> <p>Note that the alphabet in the original implementation is RNA instead of DNA, therefore, we use <code>RnaTokenizer</code> to tokenize the sequences. <code>RnaTokenizer</code> of <code>multimolecule</code> will convert \u201cU\u201ds to \u201cT\u201ds for you, you may disable this behaviour by passing <code>replace_T_with_U=False</code>.</p>"},{"location":"models/calm/#training-procedure","title":"Training Procedure","text":""},{"location":"models/calm/#preprocessing","title":"Preprocessing","text":"<p>CaLM used masked language modeling (MLM) as the pre-training objective. The masking procedure is similar to the one used in BERT:</p> <ul> <li>25% of the tokens are masked.</li> <li>In 80% of the cases, the masked tokens are replaced by <code>&lt;mask&gt;</code>.</li> <li>In 10% of the cases, the masked tokens are replaced by a random token (different) from the one they replace.</li> <li>In the 10% remaining cases, the masked tokens are left as is.</li> </ul>"},{"location":"models/calm/#pretraining","title":"PreTraining","text":"<p>The model was trained on 4 NVIDIA Quadro RTX4000 GPUs with 8GiB memories.</p> <ul> <li>Learning rate: 1e-4</li> <li>Optimizer: AdamW</li> <li>Learning rate scheduler: cosine</li> <li>Learning rate warm-up: 1,000 steps</li> <li>Epochs: 14</li> <li>Batch Size: 1,000</li> </ul>"},{"location":"models/calm/#citation","title":"Citation","text":"<p>BibTeX:</p> BibTeX<pre><code>@article {outeiral2022coodn,\n    author = {Outeiral, Carlos and Deane, Charlotte M.},\n    title = {Codon language embeddings provide strong signals for protein engineering},\n    elocation-id = {2022.12.15.519894},\n    year = {2022},\n    doi = {10.1101/2022.12.15.519894},\n    publisher = {Cold Spring Harbor Laboratory},\n    abstract = {Protein representations from deep language models have yielded state-of-the-art performance across many tasks in computational protein engineering. In recent years, progress has primarily focused on parameter count, with recent models{\\textquoteright} capacities surpassing the size of the very datasets they were trained on. Here, we propose an alternative direction. We show that large language models trained on codons, instead of amino acid sequences, provide high-quality representations that outperform comparable state-of-the-art models across a variety of tasks. In some tasks, like species recognition, prediction of protein and transcript abundance, or melting point estimation, we show that a language model trained on codons outperforms every other published protein language model, including some that contain over 50 times more parameters. These results suggest that, in addition to commonly studied scale and model complexity, the information content of biological data provides an orthogonal direction to improve the power of machine learning in biology.Competing Interest StatementThe authors have declared no competing interest.},\n    URL = {https://www.biorxiv.org/content/early/2022/12/19/2022.12.15.519894},\n    eprint = {https://www.biorxiv.org/content/early/2022/12/19/2022.12.15.519894.full.pdf},\n    journal = {bioRxiv}\n}\n</code></pre>"},{"location":"models/calm/#contact","title":"Contact","text":"<p>Please use GitHub issues of MultiMolecule for any questions or comments on the model card.</p> <p>Please contact the authors of the CaLM paper for questions or comments on the paper/model.</p>"},{"location":"models/calm/#license","title":"License","text":"<p>This model is licensed under the AGPL-3.0 License.</p> Text Only<pre><code>SPDX-License-Identifier: AGPL-3.0-or-later\n</code></pre>"},{"location":"models/calm/#multimolecule.models.calm","title":"<code>multimolecule.models.calm</code>","text":""},{"location":"models/calm/#multimolecule.models.calm.RnaTokenizer","title":"<code>RnaTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>Constructs an RNA tokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>alphabet</code> <code>List[str] | None</code> <p>List of tokens to use. Defaults to IUPAC nucleotide code.</p> <code>None</code> <code>nmers</code> <code>int</code> <p>Size of nmers to tokenize. Defaults to 1.</p> <code>1</code> <code>codon</code> <code>bool</code> <p>Whether to tokenize into codons. Defaults to False.</p> <code>False</code> <code>replace_T_with_U</code> <code>bool</code> <p>Whether to replace T with U. Defaults to True.</p> <code>True</code> <code>do_upper_case</code> <code>bool</code> <p>Whether to convert input to uppercase. Defaults to True.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaTokenizer\n&gt;&gt;&gt; tokenizer = RnaTokenizer()\n&gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n[1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n&gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 3, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 17, 64, 49, 96, 84, 22, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 49, 22, 2]\n&gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\nTraceback (most recent call last):\nValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n</code></pre> Source code in <code>multimolecule/tokenisers/rna/tokenization_rna.py</code> Python<pre><code>class RnaTokenizer(Tokenizer):\n    \"\"\"\n    Constructs an RNA tokenizer.\n\n    Args:\n        alphabet (List[str] | None, optional): List of tokens to use.\n            Defaults to [IUPAC nucleotide code](https://www.bioinformatics.org/sms2/iupac.html).\n        nmers (int, optional): Size of nmers to tokenize.\n            Defaults to 1.\n        codon (bool, optional): Whether to tokenize into codons.\n            Defaults to False.\n        replace_T_with_U (bool, optional): Whether to replace T with U.\n            Defaults to True.\n        do_upper_case (bool, optional): Whether to convert input to uppercase.\n            Defaults to True.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaTokenizer\n        &gt;&gt;&gt; tokenizer = RnaTokenizer()\n        &gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n        [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n        &gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 3, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 17, 64, 49, 96, 84, 22, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 49, 22, 2]\n        &gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\n        Traceback (most recent call last):\n        ValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n    \"\"\"\n\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n\n    def __init__(\n        self,\n        alphabet: List[str] | None = None,\n        nmers: int = 1,\n        codon: bool = False,\n        replace_T_with_U: bool = True,\n        bos_token: str = \"&lt;cls&gt;\",\n        cls_token: str = \"&lt;cls&gt;\",\n        pad_token: str = \"&lt;pad&gt;\",\n        eos_token: str = \"&lt;eos&gt;\",\n        sep_token: str = \"&lt;eos&gt;\",\n        unk_token: str = \"&lt;unk&gt;\",\n        mask_token: str = \"&lt;mask&gt;\",\n        additional_special_tokens: List | Tuple | None = None,\n        do_upper_case: bool = True,\n        **kwargs,\n    ):\n        if codon and nmers &gt; 1:\n            raise ValueError(\"Codon and nmers cannot be used together.\")\n        if codon:\n            nmers = 3  # set to 3 to get correct vocab\n        super().__init__(\n            alphabet=get_vocab_list(alphabet, nmers),\n            bos_token=bos_token,\n            cls_token=cls_token,\n            pad_token=pad_token,\n            eos_token=eos_token,\n            sep_token=sep_token,\n            unk_token=unk_token,\n            mask_token=mask_token,\n            additional_special_tokens=additional_special_tokens,\n            do_upper_case=do_upper_case,\n            **kwargs,\n        )\n        self.replace_T_with_U = replace_T_with_U\n        self.nmers = nmers\n        self.condon = codon\n\n    def _tokenize(self, text: str, **kwargs):\n        if self.do_upper_case:\n            text = text.upper()\n        if self.replace_T_with_U:\n            text = text.replace(\"T\", \"U\")\n        if self.condon:\n            if len(text) % 3 != 0:\n                raise ValueError(\n                    f\"length of input sequence  must be a multiple of 3 for codon tokenization, but got {len(text)}\"\n                )\n            return [text[i : i + 3] for i in range(0, len(text), 3)]\n        if self.nmers &gt; 1:\n            return [text[i : i + self.nmers] for i in range(len(text) - self.nmers + 1)]  # noqa: E203\n        return list(text)\n</code></pre>"},{"location":"models/calm/#multimolecule.models.calm.CaLmConfig","title":"<code>CaLmConfig</code>","text":"<p>               Bases: <code>PreTrainedConfig</code></p> <p>This is the configuration class to store the configuration of a [<code>CaLmModel</code>]. It is used to instantiate a CaLM model according to the specified arguments, defining the model architecture. Instantiating a configuration with the defaults will yield a similar configuration to that of the CaLM oxpig/CaLM architecture.</p> <p>Configuration objects inherit from [<code>PreTrainedConfig</code>] and can be used to control the model outputs. Read the documentation from [<code>PreTrainedConfig</code>] for more information.</p> <p>Parameters:</p> Name Type Description Default <code>vocab_size</code> <code>`int`, *optional*, defaults to 131</code> <p>Vocabulary size of the CaLM model. Defines the number of different tokens that can be represented by the <code>inputs_ids</code> passed when calling [<code>CaLmModel</code>].</p> <code>131</code> <code>hidden_size</code> <code>`int`, *optional*, defaults to 768</code> <p>Dimensionality of the encoder layers and the pooler layer.</p> <code>768</code> <code>num_hidden_layers</code> <code>`int`, *optional*, defaults to 12</code> <p>Number of hidden layers in the Transformer encoder.</p> <code>12</code> <code>num_attention_heads</code> <code>`int`, *optional*, defaults to 12</code> <p>Number of attention heads for each attention layer in the Transformer encoder.</p> <code>12</code> <code>intermediate_size</code> <code>`int`, *optional*, defaults to 3072</code> <p>Dimensionality of the \u201cintermediate\u201d (often named feed-forward) layer in the Transformer encoder.</p> <code>3072</code> <code>hidden_dropout</code> <code>`float`, *optional*, defaults to 0.1</code> <p>The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.</p> <code>0.1</code> <code>attention_dropout</code> <code>`float`, *optional*, defaults to 0.1</code> <p>The dropout ratio for the attention probabilities.</p> <code>0.1</code> <code>max_position_embeddings</code> <code>`int`, *optional*, defaults to 1026</code> <p>The maximum sequence length that this model might ever be used with. Typically set this to something large just in case (e.g., 512 or 1024 or 2048).</p> <code>1026</code> <code>initializer_range</code> <code>`float`, *optional*, defaults to 0.02</code> <p>The standard deviation of the truncated_normal_initializer for initializing all weight matrices.</p> <code>0.02</code> <code>layer_norm_eps</code> <code>`float`, *optional*, defaults to 1e-12</code> <p>The epsilon used by the layer normalization layers.</p> <code>1e-12</code> <code>position_embedding_type</code> <code>`str`, *optional*, defaults to `\"absolute\"`</code> <p>Type of position embedding. Choose one of <code>\"absolute\"</code>, <code>\"relative_key\"</code>, <code>\"relative_key_query\", \"rotary\"</code>. For positional embeddings use <code>\"absolute\"</code>. For more information on <code>\"relative_key\"</code>, please refer to Self-Attention with Relative Position Representations (Shaw et al.). For more information on <code>\"relative_key_query\"</code>, please refer to Method 4 in Improve Transformer Models with Better Relative Position Embeddings (Huang et al.).</p> <code>'rotary'</code> <code>is_decoder</code> <code>`bool`, *optional*, defaults to `False`</code> <p>Whether the model is used as a decoder or not. If <code>False</code>, the model is used as an encoder.</p> required <code>use_cache</code> <code>`bool`, *optional*, defaults to `True`</code> <p>Whether or not the model should return the last key/values attentions (not used by all models). Only relevant if <code>config.is_decoder=True</code>.</p> <code>True</code> <code>emb_layer_norm_before</code> <code>`bool`, *optional*</code> <p>Whether to apply layer normalization after embeddings but before the main stem of the network.</p> <code>False</code> <code>token_dropout</code> <code>`bool`, defaults to `False`</code> <p>When this is enabled, masked tokens are treated as if they had been dropped out by input dropout.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import CaLmModel, CaLmConfig\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a CaLM multimolecule/calm style configuration\n&gt;&gt;&gt; configuration = CaLmConfig()\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/calm style configuration\n&gt;&gt;&gt; model = CaLmModel(configuration)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Accessing the model configuration\n&gt;&gt;&gt; configuration = model.config\n</code></pre> Source code in <code>multimolecule/models/calm/configuration_calm.py</code> Python<pre><code>class CaLmConfig(PreTrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`CaLmModel`]. It is used to instantiate a CaLM\n    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n    defaults will yield a similar configuration to that of the CaLM\n    [oxpig/CaLM](https://github.com/oxpig/CaLM) architecture.\n\n    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n    documentation from [`PreTrainedConfig`] for more information.\n\n\n    Args:\n        vocab_size (`int`, *optional*, defaults to 131):\n            Vocabulary size of the CaLM model. Defines the number of different tokens that can be represented by the\n            `inputs_ids` passed when calling [`CaLmModel`].\n        hidden_size (`int`, *optional*, defaults to 768):\n            Dimensionality of the encoder layers and the pooler layer.\n        num_hidden_layers (`int`, *optional*, defaults to 12):\n            Number of hidden layers in the Transformer encoder.\n        num_attention_heads (`int`, *optional*, defaults to 12):\n            Number of attention heads for each attention layer in the Transformer encoder.\n        intermediate_size (`int`, *optional*, defaults to 3072):\n            Dimensionality of the \"intermediate\" (often named feed-forward) layer in the Transformer encoder.\n        hidden_dropout (`float`, *optional*, defaults to 0.1):\n            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n        attention_dropout (`float`, *optional*, defaults to 0.1):\n            The dropout ratio for the attention probabilities.\n        max_position_embeddings (`int`, *optional*, defaults to 1026):\n            The maximum sequence length that this model might ever be used with. Typically set this to something large\n            just in case (e.g., 512 or 1024 or 2048).\n        initializer_range (`float`, *optional*, defaults to 0.02):\n            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n        layer_norm_eps (`float`, *optional*, defaults to 1e-12):\n            The epsilon used by the layer normalization layers.\n        position_embedding_type (`str`, *optional*, defaults to `\"absolute\"`):\n            Type of position embedding. Choose one of `\"absolute\"`, `\"relative_key\"`, `\"relative_key_query\", \"rotary\"`.\n            For positional embeddings use `\"absolute\"`. For more information on `\"relative_key\"`, please refer to\n            [Self-Attention with Relative Position Representations (Shaw et al.)](https://arxiv.org/abs/1803.02155).\n            For more information on `\"relative_key_query\"`, please refer to *Method 4* in [Improve Transformer Models\n            with Better Relative Position Embeddings (Huang et al.)](https://arxiv.org/abs/2009.13658).\n        is_decoder (`bool`, *optional*, defaults to `False`):\n            Whether the model is used as a decoder or not. If `False`, the model is used as an encoder.\n        use_cache (`bool`, *optional*, defaults to `True`):\n            Whether or not the model should return the last key/values attentions (not used by all models). Only\n            relevant if `config.is_decoder=True`.\n        emb_layer_norm_before (`bool`, *optional*):\n            Whether to apply layer normalization after embeddings but before the main stem of the network.\n        token_dropout (`bool`, defaults to `False`):\n            When this is enabled, masked tokens are treated as if they had been dropped out by input dropout.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import CaLmModel, CaLmConfig\n\n        &gt;&gt;&gt; # Initializing a CaLM multimolecule/calm style configuration\n        &gt;&gt;&gt; configuration = CaLmConfig()\n\n        &gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/calm style configuration\n        &gt;&gt;&gt; model = CaLmModel(configuration)\n\n        &gt;&gt;&gt; # Accessing the model configuration\n        &gt;&gt;&gt; configuration = model.config\n    \"\"\"\n\n    model_type = \"calm\"\n\n    def __init__(\n        self,\n        vocab_size=131,\n        codon=True,\n        hidden_size=768,\n        num_hidden_layers=12,\n        num_attention_heads=12,\n        intermediate_size=3072,\n        hidden_act=\"gelu\",\n        hidden_dropout=0.1,\n        attention_dropout=0.1,\n        max_position_embeddings=1026,\n        initializer_range=0.02,\n        layer_norm_eps=1e-12,\n        position_embedding_type=\"rotary\",\n        use_cache=True,\n        emb_layer_norm_before=False,\n        token_dropout=True,\n        head=None,\n        lm_head=None,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n\n        self.vocab_size = vocab_size\n        self.codon = codon\n        self.hidden_size = hidden_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_attention_heads = num_attention_heads\n        self.intermediate_size = intermediate_size\n        self.hidden_act = hidden_act\n        self.hidden_dropout = hidden_dropout\n        self.attention_dropout = attention_dropout\n        self.max_position_embeddings = max_position_embeddings\n        self.initializer_range = initializer_range\n        self.layer_norm_eps = layer_norm_eps\n        self.position_embedding_type = position_embedding_type\n        self.use_cache = use_cache\n        self.emb_layer_norm_before = emb_layer_norm_before\n        self.token_dropout = token_dropout\n        self.head = HeadConfig(**head if head is not None else {})\n        self.lm_head = MaskedLMHeadConfig(**lm_head if lm_head is not None else {})\n</code></pre>"},{"location":"models/calm/#multimolecule.models.calm.CaLmForMaskedLM","title":"<code>CaLmForMaskedLM</code>","text":"<p>               Bases: <code>CaLmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import CaLmConfig, CaLmForMaskedLM, RnaTokenizer\n&gt;&gt;&gt; config = CaLmConfig()\n&gt;&gt;&gt; model = CaLmForMaskedLM(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 131])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/calm/modeling_calm.py</code> Python<pre><code>class CaLmForMaskedLM(CaLmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import CaLmConfig, CaLmForMaskedLM, RnaTokenizer\n        &gt;&gt;&gt; config = CaLmConfig()\n        &gt;&gt;&gt; model = CaLmForMaskedLM(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 131])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    _tied_weights_keys = [\"lm_head.decoder.weight\"]\n\n    def __init__(self, config: CaLmConfig):\n        super().__init__(config)\n        if config.is_decoder:\n            logger.warning(\n                \"If you want to use `CaLmForMaskedLM` make sure `config.is_decoder=False` for \"\n                \"bi-directional self-attention.\"\n            )\n        self.calm = CaLmModel(config, add_pooling_layer=False)\n        self.lm_head = MaskedLMHead(config, self.calm.embeddings.word_embeddings.weight)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | MaskedLMOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.calm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_attention_mask,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.lm_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return MaskedLMOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/calm/#multimolecule.models.calm.CaLmForNucleotidePrediction","title":"<code>CaLmForNucleotidePrediction</code>","text":"<p>               Bases: <code>CaLmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import CaLmConfig, CaLmForNucleotidePrediction, RnaTokenizer\n&gt;&gt;&gt; config = CaLmConfig()\n&gt;&gt;&gt; model = CaLmForNucleotidePrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 5, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/calm/modeling_calm.py</code> Python<pre><code>class CaLmForNucleotidePrediction(CaLmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import CaLmConfig, CaLmForNucleotidePrediction, RnaTokenizer\n        &gt;&gt;&gt; config = CaLmConfig()\n        &gt;&gt;&gt; model = CaLmForNucleotidePrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 5, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: CaLmConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.calm = CaLmModel(config, add_pooling_layer=True)\n        self.nucleotide_head = NucleotidePredictionHead(config)\n        self.head_config = self.nucleotide_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | NucleotidePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.calm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.nucleotide_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return NucleotidePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/calm/#multimolecule.models.calm.CaLmForSequencePrediction","title":"<code>CaLmForSequencePrediction</code>","text":"<p>               Bases: <code>CaLmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import CaLmConfig, CaLmForSequencePrediction, RnaTokenizer\n&gt;&gt;&gt; config = CaLmConfig()\n&gt;&gt;&gt; model = CaLmForSequencePrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.tensor([[1]]))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/calm/modeling_calm.py</code> Python<pre><code>class CaLmForSequencePrediction(CaLmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import CaLmConfig, CaLmForSequencePrediction, RnaTokenizer\n        &gt;&gt;&gt; config = CaLmConfig()\n        &gt;&gt;&gt; model = CaLmForSequencePrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.tensor([[1]]))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: CaLmConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.calm = CaLmModel(config, add_pooling_layer=True)\n        self.sequence_head = SequencePredictionHead(config)\n        self.head_config = self.sequence_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | SequencePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.calm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.sequence_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return SequencePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/calm/#multimolecule.models.calm.CaLmForTokenPrediction","title":"<code>CaLmForTokenPrediction</code>","text":"<p>               Bases: <code>CaLmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import CaLmConfig, CaLmForTokenPrediction, RnaTokenizer\n&gt;&gt;&gt; config = CaLmConfig()\n&gt;&gt;&gt; model = CaLmForTokenPrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/calm/modeling_calm.py</code> Python<pre><code>class CaLmForTokenPrediction(CaLmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import CaLmConfig, CaLmForTokenPrediction, RnaTokenizer\n        &gt;&gt;&gt; config = CaLmConfig()\n        &gt;&gt;&gt; model = CaLmForTokenPrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: CaLmConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.calm = CaLmModel(config, add_pooling_layer=True)\n        self.token_head = TokenPredictionHead(config)\n        self.head_config = self.token_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | TokenPredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.calm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.token_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return TokenPredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/calm/#multimolecule.models.calm.CaLmModel","title":"<code>CaLmModel</code>","text":"<p>               Bases: <code>CaLmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import CaLmConfig, CaLmModel, RnaTokenizer\n&gt;&gt;&gt; config = CaLmConfig()\n&gt;&gt;&gt; model = CaLmModel(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input)\n&gt;&gt;&gt; output[\"last_hidden_state\"].shape\ntorch.Size([1, 7, 768])\n&gt;&gt;&gt; output[\"pooler_output\"].shape\ntorch.Size([1, 768])\n</code></pre> Source code in <code>multimolecule/models/calm/modeling_calm.py</code> Python<pre><code>class CaLmModel(CaLmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import CaLmConfig, CaLmModel, RnaTokenizer\n        &gt;&gt;&gt; config = CaLmConfig()\n        &gt;&gt;&gt; model = CaLmModel(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input)\n        &gt;&gt;&gt; output[\"last_hidden_state\"].shape\n        torch.Size([1, 7, 768])\n        &gt;&gt;&gt; output[\"pooler_output\"].shape\n        torch.Size([1, 768])\n    \"\"\"\n\n    def __init__(self, config: CaLmConfig, add_pooling_layer: bool = True):\n        super().__init__(config)\n        self.pad_token_id = config.pad_token_id\n        self.embeddings = CaLmEmbeddings(config)\n        self.encoder = CaLmEncoder(config)\n        self.pooler = CaLmPooler(config) if add_pooling_layer else None\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.embeddings.word_embeddings\n\n    def set_input_embeddings(self, value):\n        self.embeddings.word_embeddings = value\n\n    def _prune_heads(self, heads_to_prune):\n        \"\"\"\n        Prunes heads of the model. heads_to_prune: dict of {layer_num: list of heads to prune in this layer} See base\n        class PreTrainedModel\n        \"\"\"\n        for layer, heads in heads_to_prune.items():\n            self.encoder.layer[layer].attention.prune_heads(heads)\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        past_key_values: Tuple[Tuple[torch.FloatTensor, torch.FloatTensor], ...] | None = None,\n        use_cache: bool | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | BaseModelOutputWithPoolingAndCrossAttentions:\n        r\"\"\"\n        encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n            Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n            the model is configured as a decoder.\n        encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n            the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n            - 1 for tokens that are **not masked**,\n            - 0 for tokens that are **masked**.\n        past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors\n            of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n            Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n        use_cache (`bool`, *optional*):\n            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n            `past_key_values`).\n        \"\"\"\n        if kwargs:\n            warn(\n                f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n                f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n                \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n            )\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        if self.config.is_decoder:\n            use_cache = use_cache if use_cache is not None else self.config.use_cache\n        else:\n            use_cache = False\n\n        if isinstance(input_ids, NestedTensor):\n            input_ids, attention_mask = input_ids.tensor, input_ids.mask\n        if input_ids is not None and inputs_embeds is not None:\n            raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n        if input_ids is not None:\n            self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n            input_shape = input_ids.size()\n        elif inputs_embeds is not None:\n            input_shape = inputs_embeds.size()[:-1]\n        else:\n            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n        batch_size, seq_length = input_shape\n        device = input_ids.device if input_ids is not None else inputs_embeds.device  # type: ignore[union-attr]\n\n        # past_key_values_length\n        past_key_values_length = past_key_values[0][0].shape[2] if past_key_values is not None else 0\n\n        if attention_mask is None:\n            attention_mask = (\n                input_ids.ne(self.pad_token_id)\n                if self.pad_token_id is not None\n                else torch.ones(((batch_size, seq_length + past_key_values_length)), device=device)\n            )\n\n        # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n        # ourselves in which case we just need to make it broadcastable to all heads.\n        extended_attention_mask: Tensor = self.get_extended_attention_mask(attention_mask, input_shape)\n\n        # If a 2D or 3D attention mask is provided for the cross-attention\n        # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n        if self.config.is_decoder and encoder_hidden_states is not None:\n            encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n            encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n            if encoder_attention_mask is None:\n                encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n            encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n        else:\n            encoder_extended_attention_mask = None\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n        head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n        embedding_output = self.embeddings(\n            input_ids=input_ids,\n            position_ids=position_ids,\n            attention_mask=attention_mask,\n            inputs_embeds=inputs_embeds,\n            past_key_values_length=past_key_values_length,\n        )\n        encoder_outputs = self.encoder(\n            embedding_output,\n            attention_mask=extended_attention_mask,\n            head_mask=head_mask,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_extended_attention_mask,\n            past_key_values=past_key_values,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n        sequence_output = encoder_outputs[0]\n        pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n        if not return_dict:\n            return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n        return BaseModelOutputWithPoolingAndCrossAttentions(\n            last_hidden_state=sequence_output,\n            pooler_output=pooled_output,\n            past_key_values=encoder_outputs.past_key_values,\n            hidden_states=encoder_outputs.hidden_states,\n            attentions=encoder_outputs.attentions,\n            cross_attentions=encoder_outputs.cross_attentions,\n        )\n</code></pre>"},{"location":"models/calm/#multimolecule.models.calm.CaLmModel.forward","title":"<code>forward(input_ids, attention_mask=None, position_ids=None, head_mask=None, inputs_embeds=None, encoder_hidden_states=None, encoder_attention_mask=None, past_key_values=None, use_cache=None, output_attentions=None, output_hidden_states=None, return_dict=None, **kwargs)</code>","text":"<p>encoder_hidden_states  (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, optional):     Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if     the model is configured as a decoder. encoder_attention_mask (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, optional):     Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in     the cross-attention if the model is configured as a decoder. Mask values selected in <code>[0, 1]</code>:</p> Text Only<pre><code>- 1 for tokens that are **not masked**,\n- 0 for tokens that are **masked**.\n</code></pre> <p>past_key_values (<code>tuple(tuple(torch.FloatTensor))</code> of length <code>config.n_layers</code> with each tuple having 4 tensors     of shape <code>(batch_size, num_heads, sequence_length - 1, embed_size_per_head)</code>):     Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.</p> Text Only<pre><code>If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\ndon't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n`decoder_input_ids` of shape `(batch_size, sequence_length)`.\n</code></pre> <p>use_cache (<code>bool</code>, optional):     If set to <code>True</code>, <code>past_key_values</code> key value states are returned and can be used to speed up decoding (see     <code>past_key_values</code>).</p> Source code in <code>multimolecule/models/calm/modeling_calm.py</code> Python<pre><code>def forward(\n    self,\n    input_ids: Tensor | NestedTensor,\n    attention_mask: Tensor | None = None,\n    position_ids: Tensor | None = None,\n    head_mask: Tensor | None = None,\n    inputs_embeds: Tensor | NestedTensor | None = None,\n    encoder_hidden_states: Tensor | None = None,\n    encoder_attention_mask: Tensor | None = None,\n    past_key_values: Tuple[Tuple[torch.FloatTensor, torch.FloatTensor], ...] | None = None,\n    use_cache: bool | None = None,\n    output_attentions: bool | None = None,\n    output_hidden_states: bool | None = None,\n    return_dict: bool | None = None,\n    **kwargs,\n) -&gt; Tuple[Tensor, ...] | BaseModelOutputWithPoolingAndCrossAttentions:\n    r\"\"\"\n    encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n        Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n        the model is configured as a decoder.\n    encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n        Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n        the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n        - 1 for tokens that are **not masked**,\n        - 0 for tokens that are **masked**.\n    past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors\n        of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n        Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n        If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n        don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n        `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n    use_cache (`bool`, *optional*):\n        If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n        `past_key_values`).\n    \"\"\"\n    if kwargs:\n        warn(\n            f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n            f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n            \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n        )\n    output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n    output_hidden_states = (\n        output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n    )\n    return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n    if self.config.is_decoder:\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n    else:\n        use_cache = False\n\n    if isinstance(input_ids, NestedTensor):\n        input_ids, attention_mask = input_ids.tensor, input_ids.mask\n    if input_ids is not None and inputs_embeds is not None:\n        raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n    if input_ids is not None:\n        self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n        input_shape = input_ids.size()\n    elif inputs_embeds is not None:\n        input_shape = inputs_embeds.size()[:-1]\n    else:\n        raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n    batch_size, seq_length = input_shape\n    device = input_ids.device if input_ids is not None else inputs_embeds.device  # type: ignore[union-attr]\n\n    # past_key_values_length\n    past_key_values_length = past_key_values[0][0].shape[2] if past_key_values is not None else 0\n\n    if attention_mask is None:\n        attention_mask = (\n            input_ids.ne(self.pad_token_id)\n            if self.pad_token_id is not None\n            else torch.ones(((batch_size, seq_length + past_key_values_length)), device=device)\n        )\n\n    # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n    # ourselves in which case we just need to make it broadcastable to all heads.\n    extended_attention_mask: Tensor = self.get_extended_attention_mask(attention_mask, input_shape)\n\n    # If a 2D or 3D attention mask is provided for the cross-attention\n    # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n    if self.config.is_decoder and encoder_hidden_states is not None:\n        encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n        encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n        if encoder_attention_mask is None:\n            encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n        encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n    else:\n        encoder_extended_attention_mask = None\n\n    # Prepare head mask if needed\n    # 1.0 in head_mask indicate we keep the head\n    # attention_probs has shape bsz x n_heads x N x N\n    # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n    # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n    head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n    embedding_output = self.embeddings(\n        input_ids=input_ids,\n        position_ids=position_ids,\n        attention_mask=attention_mask,\n        inputs_embeds=inputs_embeds,\n        past_key_values_length=past_key_values_length,\n    )\n    encoder_outputs = self.encoder(\n        embedding_output,\n        attention_mask=extended_attention_mask,\n        head_mask=head_mask,\n        encoder_hidden_states=encoder_hidden_states,\n        encoder_attention_mask=encoder_extended_attention_mask,\n        past_key_values=past_key_values,\n        use_cache=use_cache,\n        output_attentions=output_attentions,\n        output_hidden_states=output_hidden_states,\n        return_dict=return_dict,\n    )\n    sequence_output = encoder_outputs[0]\n    pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n    if not return_dict:\n        return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n    return BaseModelOutputWithPoolingAndCrossAttentions(\n        last_hidden_state=sequence_output,\n        pooler_output=pooled_output,\n        past_key_values=encoder_outputs.past_key_values,\n        hidden_states=encoder_outputs.hidden_states,\n        attentions=encoder_outputs.attentions,\n        cross_attentions=encoder_outputs.cross_attentions,\n    )\n</code></pre>"},{"location":"models/calm/#multimolecule.models.calm.CaLmPreTrainedModel","title":"<code>CaLmPreTrainedModel</code>","text":"<p>               Bases: <code>PreTrainedModel</code></p> <p>An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained models.</p> Source code in <code>multimolecule/models/calm/modeling_calm.py</code> Python<pre><code>class CaLmPreTrainedModel(PreTrainedModel):\n    \"\"\"\n    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n    models.\n    \"\"\"\n\n    config_class = CaLmConfig\n    base_model_prefix = \"calm\"\n    supports_gradient_checkpointing = True\n    _no_split_modules = [\"CaLmLayer\", \"CaLmEmbeddings\"]\n\n    # Copied from transformers.models.bert.modeling_bert.BertPreTrainedModel._init_weights\n    def _init_weights(self, module: nn.Module):\n        \"\"\"Initialize the weights\"\"\"\n        if isinstance(module, nn.Linear):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, nn.Embedding):\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.padding_idx is not None:\n                module.weight.data[module.padding_idx].zero_()\n        elif isinstance(module, nn.LayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n</code></pre>"},{"location":"models/ernierna/","title":"ERNIE-RNA","text":"<p>Pre-trained model on non-coding RNA (ncRNA) using a masked language modeling (MLM) objective.</p>"},{"location":"models/ernierna/#disclaimer","title":"Disclaimer","text":"<p>This is an UNOFFICIAL implementation of the ERNIE-RNA: An RNA Language Model with Structure-enhanced Representations by Weijie Yin, Zhaoyu Zhang, Liang He, et al.</p> <p>The OFFICIAL repository of ERNIE-RNA is at Bruce-ywj/ERNIE-RNA.</p> <p>The team releasing ERNIE-RNA did not write this model card for this model so this model card has been written by the MultiMolecule team.</p>"},{"location":"models/ernierna/#model-details","title":"Model Details","text":"<p>ERNIE-RNA is a bert-style model pre-trained on a large corpus of non-coding RNA sequences in a self-supervised fashion. This means that the model was trained on the raw nucleotides of RNA sequences only, with an automatic process to generate inputs and labels from those texts. Please refer to the Training Details section for more information on the training process.</p>"},{"location":"models/ernierna/#variations","title":"Variations","text":"<ul> <li><code>multimolecule/ernierna</code>: The ERNIE-RNA model pre-trained on non-coding RNA sequences.</li> <li><code>multimolecule/ernierna.ss</code>: The ERNIE-RNA model fine-tuned on RNA secondary structure prediction.</li> </ul>"},{"location":"models/ernierna/#model-specification","title":"Model Specification","text":"Num Layers Hidden Size Num Heads Intermediate Size Num Parameters (M) FLOPs (G) MACs (G) Max Num Tokens 12 768 12 3072 85.67 22.36 11.17 1024"},{"location":"models/ernierna/#links","title":"Links","text":"<ul> <li>Code: multimolecule.ernierna</li> <li>Data: RNAcentral</li> <li>Paper: ERNIE-RNA: An RNA Language Model with Structure-enhanced Representations</li> <li>Developed by: Weijie Yin, Zhaoyu Zhang, Liang He, Rui Jiang, Shuo Zhang, Gan Liu, Xuegong Zhang, Tao Qin, Zhen Xie</li> <li>Model type: BERT - ERNIE</li> <li>Original Repository: https://github.com/Bruce-ywj/ERNIE-RNA</li> </ul>"},{"location":"models/ernierna/#usage","title":"Usage","text":"<p>The model file depends on the <code>multimolecule</code> library. You can install it using pip:</p> Bash<pre><code>pip install multimolecule\n</code></pre>"},{"location":"models/ernierna/#direct-use","title":"Direct Use","text":"<p>You can use this model directly with a pipeline for masked language modeling:</p> Python<pre><code>&gt;&gt;&gt; import multimolecule  # you must import multimolecule to register models\n&gt;&gt;&gt; from transformers import pipeline\n&gt;&gt;&gt; unmasker = pipeline('fill-mask', model='multimolecule/ernierna')\n&gt;&gt;&gt; unmasker(\"uagc&lt;mask&gt;uaucagacugauguuga\")\n\n[{'score': 0.47122013568878174,\n  'token': 8,\n  'token_str': 'G',\n  'sequence': 'U A G C G U A U C A G A C U G A U G U U G A'},\n {'score': 0.45008403062820435,\n  'token': 6,\n  'token_str': 'A',\n  'sequence': 'U A G C A U A U C A G A C U G A U G U U G A'},\n {'score': 0.03330205753445625,\n  'token': 24,\n  'token_str': '*',\n  'sequence': 'U A G C * U A U C A G A C U G A U G U U G A'},\n {'score': 0.025803660973906517,\n  'token': 25,\n  'token_str': '-',\n  'sequence': 'U A G C - U A U C A G A C U G A U G U U G A'},\n {'score': 0.018313394859433174,\n  'token': 23,\n  'token_str': '.',\n  'sequence': 'U A G C. U A U C A G A C U G A U G U U G A'}]\n</code></pre>"},{"location":"models/ernierna/#downstream-use","title":"Downstream Use","text":""},{"location":"models/ernierna/#extract-features","title":"Extract Features","text":"<p>Here is how to use this model to get the features of a given sequence in PyTorch:</p> Python<pre><code>from multimolecule import RnaTokenizer, ErnieRnaModel\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/ernierna')\nmodel = ErnieRnaModel.from_pretrained('multimolecule/ernierna')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\n\noutput = model(**input)\n</code></pre>"},{"location":"models/ernierna/#sequence-classification-regression","title":"Sequence Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for sequence classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a sequence-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, ErnieRnaForSequencePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/ernierna')\nmodel = ErnieRnaForSequencePrediction.from_pretrained('multimolecule/ernierna')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.tensor([1])\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/ernierna/#nucleotide-classification-regression","title":"Nucleotide Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for nucleotide classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a nucleotide-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, ErnieRnaForNucleotidePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/ernierna')\nmodel = ErnieRnaForNucleotidePrediction.from_pretrained('multimolecule/ernierna')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.randint(2, (len(text), ))\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/ernierna/#training-details","title":"Training Details","text":"<p>ERNIE-RNA used Masked Language Modeling (MLM) as the pre-training objective: taking a sequence, the model randomly masks 15% of the tokens in the input then runs the entire masked sentence through the model and has to predict the masked tokens. This is comparable to the Cloze task in language modeling.</p>"},{"location":"models/ernierna/#training-data","title":"Training Data","text":"<p>The ERNIE-RNA model was pre-trained on RNAcentral. RNAcentral is a comprehensive database of non-coding RNA sequences from a wide range of species. It combines 47 different databases, adding up to around 34 million RNA sequences in total.</p> <p>ERNIE-RNA applied CD-HIT (CD-HIT-EST) with a cut-off at 100% sequence identity to remove redundancy from the RNAcentral, resulting 25 million unique sequences. Sequences longer than 1024 nucleotides were subsequently excluded. The final dataset contains 20.4 million non-redundant RNA sequences. ERNIE-RNA preprocessed all tokens by replacing \u201cT\u201ds with \u201cS\u201ds.</p> <p>Note that <code>RnaTokenizer</code> will convert \u201cT\u201ds to \u201cU\u201ds for you, you may disable this behaviour by passing <code>replace_T_with_U=False</code>.</p>"},{"location":"models/ernierna/#training-procedure","title":"Training Procedure","text":""},{"location":"models/ernierna/#preprocessing","title":"Preprocessing","text":"<p>ERNIE-RNA used masked language modeling (MLM) as the pre-training objective. The masking procedure is similar to the one used in BERT:</p> <ul> <li>15% of the tokens are masked.</li> <li>In 80% of the cases, the masked tokens are replaced by <code>&lt;mask&gt;</code>.</li> <li>In 10% of the cases, the masked tokens are replaced by a random token (different) from the one they replace.</li> <li>In the 10% remaining cases, the masked tokens are left as is.</li> </ul>"},{"location":"models/ernierna/#pretraining","title":"PreTraining","text":"<p>The model was trained on 24 NVIDIA V100 GPUs with 32GiB memories.</p> <ul> <li>Learning rate: 1e-4</li> <li>Weight decay: 0.01</li> <li>Learning rate warm-up: 20,000 steps</li> </ul>"},{"location":"models/ernierna/#citation","title":"Citation","text":"<p>BibTeX:</p> BibTeX<pre><code>@article {Yin2024.03.17.585376,\n    author = {Yin, Weijie and Zhang, Zhaoyu and He, Liang and Jiang, Rui and Zhang, Shuo and Liu, Gan and Zhang, Xuegong and Qin, Tao and Xie, Zhen},\n    title = {ERNIE-RNA: An RNA Language Model with Structure-enhanced Representations},\n    elocation-id = {2024.03.17.585376},\n    year = {2024},\n    doi = {10.1101/2024.03.17.585376},\n    publisher = {Cold Spring Harbor Laboratory},\n    abstract = {With large amounts of unlabeled RNA sequences data produced by high-throughput sequencing technologies, pre-trained RNA language models have been developed to estimate semantic space of RNA molecules, which facilities the understanding of grammar of RNA language. However, existing RNA language models overlook the impact of structure when modeling the RNA semantic space, resulting in incomplete feature extraction and suboptimal performance across various downstream tasks. In this study, we developed a RNA pre-trained language model named ERNIE-RNA (Enhanced Representations with base-pairing restriction for RNA modeling) based on a modified BERT (Bidirectional Encoder Representations from Transformers) by incorporating base-pairing restriction with no MSA (Multiple Sequence Alignment) information. We found that the attention maps from ERNIE-RNA with no fine-tuning are able to capture RNA structure in the zero-shot experiment more precisely than conventional methods such as fine-tuned RNAfold and RNAstructure, suggesting that the ERNIE-RNA can provide comprehensive RNA structural representations. Furthermore, ERNIE-RNA achieved SOTA (state-of-the-art) performance after fine-tuning for various downstream tasks, including RNA structural and functional predictions. In summary, our ERNIE-RNA model provides general features which can be widely and effectively applied in various subsequent research tasks. Our results indicate that introducing key knowledge-based prior information in the BERT framework may be a useful strategy to enhance the performance of other language models.Competing Interest StatementOne patent based on the study was submitted by Z.X. and W.Y., which is entitled as \"A Pre-training Approach for RNA Sequences and Its Applications\"(application number, no 202410262527.5). The remaining authors declare no competing interests.},\n    URL = {https://www.biorxiv.org/content/early/2024/03/17/2024.03.17.585376},\n    eprint = {https://www.biorxiv.org/content/early/2024/03/17/2024.03.17.585376.full.pdf},\n    journal = {bioRxiv}\n}\n</code></pre>"},{"location":"models/ernierna/#contact","title":"Contact","text":"<p>Please use GitHub issues of MultiMolecule for any questions or comments on the model card.</p> <p>Please contact the authors of the ERNIE-RNA paper for questions or comments on the paper/model.</p>"},{"location":"models/ernierna/#license","title":"License","text":"<p>This model is licensed under the AGPL-3.0 License.</p> Text Only<pre><code>SPDX-License-Identifier: AGPL-3.0-or-later\n</code></pre>"},{"location":"models/ernierna/#multimolecule.models.ernierna","title":"<code>multimolecule.models.ernierna</code>","text":""},{"location":"models/ernierna/#multimolecule.models.ernierna.RnaTokenizer","title":"<code>RnaTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>Constructs an RNA tokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>alphabet</code> <code>List[str] | None</code> <p>List of tokens to use. Defaults to IUPAC nucleotide code.</p> <code>None</code> <code>nmers</code> <code>int</code> <p>Size of nmers to tokenize. Defaults to 1.</p> <code>1</code> <code>codon</code> <code>bool</code> <p>Whether to tokenize into codons. Defaults to False.</p> <code>False</code> <code>replace_T_with_U</code> <code>bool</code> <p>Whether to replace T with U. Defaults to True.</p> <code>True</code> <code>do_upper_case</code> <code>bool</code> <p>Whether to convert input to uppercase. Defaults to True.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaTokenizer\n&gt;&gt;&gt; tokenizer = RnaTokenizer()\n&gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n[1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n&gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 3, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 17, 64, 49, 96, 84, 22, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 49, 22, 2]\n&gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\nTraceback (most recent call last):\nValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n</code></pre> Source code in <code>multimolecule/tokenisers/rna/tokenization_rna.py</code> Python<pre><code>class RnaTokenizer(Tokenizer):\n    \"\"\"\n    Constructs an RNA tokenizer.\n\n    Args:\n        alphabet (List[str] | None, optional): List of tokens to use.\n            Defaults to [IUPAC nucleotide code](https://www.bioinformatics.org/sms2/iupac.html).\n        nmers (int, optional): Size of nmers to tokenize.\n            Defaults to 1.\n        codon (bool, optional): Whether to tokenize into codons.\n            Defaults to False.\n        replace_T_with_U (bool, optional): Whether to replace T with U.\n            Defaults to True.\n        do_upper_case (bool, optional): Whether to convert input to uppercase.\n            Defaults to True.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaTokenizer\n        &gt;&gt;&gt; tokenizer = RnaTokenizer()\n        &gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n        [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n        &gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 3, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 17, 64, 49, 96, 84, 22, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 49, 22, 2]\n        &gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\n        Traceback (most recent call last):\n        ValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n    \"\"\"\n\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n\n    def __init__(\n        self,\n        alphabet: List[str] | None = None,\n        nmers: int = 1,\n        codon: bool = False,\n        replace_T_with_U: bool = True,\n        bos_token: str = \"&lt;cls&gt;\",\n        cls_token: str = \"&lt;cls&gt;\",\n        pad_token: str = \"&lt;pad&gt;\",\n        eos_token: str = \"&lt;eos&gt;\",\n        sep_token: str = \"&lt;eos&gt;\",\n        unk_token: str = \"&lt;unk&gt;\",\n        mask_token: str = \"&lt;mask&gt;\",\n        additional_special_tokens: List | Tuple | None = None,\n        do_upper_case: bool = True,\n        **kwargs,\n    ):\n        if codon and nmers &gt; 1:\n            raise ValueError(\"Codon and nmers cannot be used together.\")\n        if codon:\n            nmers = 3  # set to 3 to get correct vocab\n        super().__init__(\n            alphabet=get_vocab_list(alphabet, nmers),\n            bos_token=bos_token,\n            cls_token=cls_token,\n            pad_token=pad_token,\n            eos_token=eos_token,\n            sep_token=sep_token,\n            unk_token=unk_token,\n            mask_token=mask_token,\n            additional_special_tokens=additional_special_tokens,\n            do_upper_case=do_upper_case,\n            **kwargs,\n        )\n        self.replace_T_with_U = replace_T_with_U\n        self.nmers = nmers\n        self.condon = codon\n\n    def _tokenize(self, text: str, **kwargs):\n        if self.do_upper_case:\n            text = text.upper()\n        if self.replace_T_with_U:\n            text = text.replace(\"T\", \"U\")\n        if self.condon:\n            if len(text) % 3 != 0:\n                raise ValueError(\n                    f\"length of input sequence  must be a multiple of 3 for codon tokenization, but got {len(text)}\"\n                )\n            return [text[i : i + 3] for i in range(0, len(text), 3)]\n        if self.nmers &gt; 1:\n            return [text[i : i + self.nmers] for i in range(len(text) - self.nmers + 1)]  # noqa: E203\n        return list(text)\n</code></pre>"},{"location":"models/ernierna/#multimolecule.models.ernierna.ErnieRnaConfig","title":"<code>ErnieRnaConfig</code>","text":"<p>               Bases: <code>PreTrainedConfig</code></p> <p>This is the configuration class to store the configuration of a [<code>ErnieRnaModel</code>]. It is used to instantiate a ErnieRna model according to the specified arguments, defining the model architecture. Instantiating a configuration with the defaults will yield a similar configuration to that of the ErnieRna Bruce-ywj/ERNIE-RNA architecture.</p> <p>Configuration objects inherit from [<code>PreTrainedConfig</code>] and can be used to control the model outputs. Read the documentation from [<code>PreTrainedConfig</code>] for more information.</p> <p>Parameters:</p> Name Type Description Default <code>vocab_size</code> <code>`int`, *optional*, defaults to 26</code> <p>Vocabulary size of the ErnieRna model. Defines the number of different tokens that can be represented by the <code>inputs_ids</code> passed when calling [<code>ErnieRnaModel</code>].</p> <code>26</code> <code>hidden_size</code> <code>`int`, *optional*, defaults to 512</code> <p>Dimensionality of the encoder layers and the pooler layer.</p> <code>768</code> <code>num_hidden_layers</code> <code>`int`, *optional*, defaults to 6</code> <p>Number of hidden layers in the Transformer encoder.</p> <code>12</code> <code>num_attention_heads</code> <code>`int`, *optional*, defaults to 16</code> <p>Number of attention heads for each attention layer in the Transformer encoder.</p> <code>12</code> <code>intermediate_size</code> <code>`int`, *optional*, defaults to 2048</code> <p>Dimensionality of the \u201cintermediate\u201d (often named feed-forward) layer in the Transformer encoder.</p> <code>3072</code> <code>hidden_dropout</code> <code>`float`, *optional*, defaults to 0.1</code> <p>The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.</p> <code>0.1</code> <code>attention_dropout</code> <code>`float`, *optional*, defaults to 0.1</code> <p>The dropout ratio for the attention probabilities.</p> <code>0.1</code> <code>max_position_embeddings</code> <code>`int`, *optional*, defaults to 1026</code> <p>The maximum sequence length that this model might ever be used with. Typically set this to something large just in case (e.g., 512 or 1024 or 2048).</p> <code>1026</code> <code>initializer_range</code> <code>`float`, *optional*, defaults to 0.02</code> <p>The standard deviation of the truncated_normal_initializer for initializing all weight matrices.</p> <code>0.02</code> <code>layer_norm_eps</code> <code>`float`, *optional*, defaults to 1e-12</code> <p>The epsilon used by the layer normalization layers.</p> <code>1e-12</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import ErnieRnaModel, ErnieRnaConfig\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a ERNIE-RNA multimolecule/ernierna style configuration\n&gt;&gt;&gt; configuration = ErnieRnaConfig()\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/ernierna style configuration\n&gt;&gt;&gt; model = ErnieRnaModel(configuration)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Accessing the model configuration\n&gt;&gt;&gt; configuration = model.config\n</code></pre> Source code in <code>multimolecule/models/ernierna/configuration_ernierna.py</code> Python<pre><code>class ErnieRnaConfig(PreTrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`ErnieRnaModel`]. It is used to instantiate a\n    ErnieRna model according to the specified arguments, defining the model architecture. Instantiating a\n    configuration with the defaults will yield a similar configuration to that of the ErnieRna\n    [Bruce-ywj/ERNIE-RNA](https://github.com/Bruce-ywj/ERNIE-RNA) architecture.\n\n    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n    documentation from [`PreTrainedConfig`] for more information.\n\n\n    Args:\n        vocab_size (`int`, *optional*, defaults to 26):\n            Vocabulary size of the ErnieRna model. Defines the number of different tokens that can be represented by\n            the `inputs_ids` passed when calling [`ErnieRnaModel`].\n        hidden_size (`int`, *optional*, defaults to 512):\n            Dimensionality of the encoder layers and the pooler layer.\n        num_hidden_layers (`int`, *optional*, defaults to 6):\n            Number of hidden layers in the Transformer encoder.\n        num_attention_heads (`int`, *optional*, defaults to 16):\n            Number of attention heads for each attention layer in the Transformer encoder.\n        intermediate_size (`int`, *optional*, defaults to 2048):\n            Dimensionality of the \"intermediate\" (often named feed-forward) layer in the Transformer encoder.\n        hidden_dropout (`float`, *optional*, defaults to 0.1):\n            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n        attention_dropout (`float`, *optional*, defaults to 0.1):\n            The dropout ratio for the attention probabilities.\n        max_position_embeddings (`int`, *optional*, defaults to 1026):\n            The maximum sequence length that this model might ever be used with. Typically set this to something large\n            just in case (e.g., 512 or 1024 or 2048).\n        initializer_range (`float`, *optional*, defaults to 0.02):\n            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n        layer_norm_eps (`float`, *optional*, defaults to 1e-12):\n            The epsilon used by the layer normalization layers.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import ErnieRnaModel, ErnieRnaConfig\n\n        &gt;&gt;&gt; # Initializing a ERNIE-RNA multimolecule/ernierna style configuration\n        &gt;&gt;&gt; configuration = ErnieRnaConfig()\n\n        &gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/ernierna style configuration\n        &gt;&gt;&gt; model = ErnieRnaModel(configuration)\n\n        &gt;&gt;&gt; # Accessing the model configuration\n        &gt;&gt;&gt; configuration = model.config\n    \"\"\"\n\n    model_type = \"ernierna\"\n\n    def __init__(\n        self,\n        vocab_size=26,\n        hidden_size=768,\n        num_hidden_layers=12,\n        num_attention_heads=12,\n        intermediate_size=3072,\n        hidden_act=\"gelu\",\n        hidden_dropout=0.1,\n        attention_dropout=0.1,\n        max_position_embeddings=1026,\n        initializer_range=0.02,\n        layer_norm_eps=1e-12,\n        position_embedding_type=\"sinusoidal\",\n        pairwise_alpha=0.8,\n        use_cache=True,\n        head=None,\n        lm_head=None,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n\n        self.vocab_size = vocab_size\n        self.type_vocab_size = 2\n        self.hidden_size = hidden_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_attention_heads = num_attention_heads\n        self.intermediate_size = intermediate_size\n        self.hidden_act = hidden_act\n        self.hidden_dropout = hidden_dropout\n        self.attention_dropout = attention_dropout\n        self.max_position_embeddings = max_position_embeddings\n        self.initializer_range = initializer_range\n        self.layer_norm_eps = layer_norm_eps\n        self.position_embedding_type = position_embedding_type\n        self.pairwise_alpha = pairwise_alpha\n        self.use_cache = use_cache\n        self.head = HeadConfig(**head if head is not None else {})\n        self.lm_head = MaskedLMHeadConfig(**lm_head if lm_head is not None else {})\n</code></pre>"},{"location":"models/ernierna/#multimolecule.models.ernierna.ErnieRnaForContactClassification","title":"<code>ErnieRnaForContactClassification</code>","text":"<p>               Bases: <code>ErnieRnaPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule.models import ErnieRnaConfig, ErnieRnaForContactClassification, RnaTokenizer\n&gt;&gt;&gt; config = ErnieRnaConfig()\n&gt;&gt;&gt; model = ErnieRnaForContactClassification(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer()\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input)\n</code></pre> Source code in <code>multimolecule/models/ernierna/modeling_ernierna.py</code> Python<pre><code>class ErnieRnaForContactClassification(ErnieRnaPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule.models import ErnieRnaConfig, ErnieRnaForContactClassification, RnaTokenizer\n        &gt;&gt;&gt; config = ErnieRnaConfig()\n        &gt;&gt;&gt; model = ErnieRnaForContactClassification(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer()\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input)\n    \"\"\"\n\n    def __init__(self, config: ErnieRnaConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.ernierna = ErnieRnaModel(config)\n        self.lm_head = MaskedLMHead(config)\n        self.ss_head = ErnieRnaContactClassificationHead(config)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels_lm: Tensor | None = None,\n        labels_ss: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_attention_biases: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | ErnieRnaForContactClassificationOutput:\n        if output_attentions is False:\n            warn(\"output_attentions must be True for contact classification and will be ignored.\")\n        outputs = self.ernierna(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=True,\n            output_attention_biases=output_attention_biases,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output_lm = self.lm_head(outputs, labels_lm)\n        output_ss = self.ss_head(outputs[-1][-1], attention_mask, input_ids, labels_ss)\n        logits_lm, loss_lm = output_lm.logits, output_lm.loss\n        logits_ss, loss_ss = output_ss.logits, output_ss.loss\n\n        loss = None\n        if loss_lm is not None and loss_ss is not None:\n            loss = loss_lm + loss_ss\n        elif loss_lm is not None:\n            loss = loss_lm\n        elif loss_ss is not None:\n            loss = loss_ss\n\n        if not return_dict:\n            output = outputs[2:]\n            output = ((logits_ss, loss_ss) + output) if loss_ss is not None else ((logits_ss,) + output)\n            output = ((logits_lm, loss_lm) + output) if loss_lm is not None else ((logits_lm,) + output)\n            return ((loss,) + output) if loss is not None else output\n\n        return ErnieRnaForContactClassificationOutput(\n            loss=loss,\n            logits_lm=logits_lm,\n            loss_lm=loss_lm,\n            logits_ss=logits_ss,\n            loss_ss=loss_ss,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n            attention_biases=outputs.attention_biases,\n        )\n</code></pre>"},{"location":"models/ernierna/#multimolecule.models.ernierna.ErnieRnaForMaskedLM","title":"<code>ErnieRnaForMaskedLM</code>","text":"<p>               Bases: <code>ErnieRnaPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import ErnieRnaConfig, ErnieRnaForMaskedLM, RnaTokenizer\n&gt;&gt;&gt; config = ErnieRnaConfig()\n&gt;&gt;&gt; model = ErnieRnaForMaskedLM(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer()\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 26])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/ernierna/modeling_ernierna.py</code> Python<pre><code>class ErnieRnaForMaskedLM(ErnieRnaPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import ErnieRnaConfig, ErnieRnaForMaskedLM, RnaTokenizer\n        &gt;&gt;&gt; config = ErnieRnaConfig()\n        &gt;&gt;&gt; model = ErnieRnaForMaskedLM(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer()\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 26])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    _tied_weights_keys = [\"predictions.decoder.bias\", \"cls.predictions.decoder.weight\"]\n\n    def __init__(self, config: ErnieRnaConfig):\n        super().__init__(config)\n        if config.is_decoder:\n            logger.warning(\n                \"If you want to use `BertForMaskedLM` make sure `config.is_decoder=False` for \"\n                \"bi-directional self-attention.\"\n            )\n        self.ernierna = ErnieRnaModel(config, add_pooling_layer=False)\n        self.lm_head = MaskedLMHead(config)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_output_embeddings(self):\n        return self.lm_head.decoder\n\n    def set_output_embeddings(self, new_embeddings):\n        self.lm_head.decoder = new_embeddings\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_attention_biases: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | ErnieRnaForMaskedLMOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.ernierna(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_attention_mask,\n            output_attentions=output_attentions,\n            output_attention_biases=output_attention_biases,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.lm_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return ErnieRnaForMaskedLMOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/ernierna/#multimolecule.models.ernierna.ErnieRnaForNucleotidePrediction","title":"<code>ErnieRnaForNucleotidePrediction</code>","text":"<p>               Bases: <code>ErnieRnaPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import ErnieRnaConfig, ErnieRnaForNucleotidePrediction, RnaTokenizer\n&gt;&gt;&gt; config = ErnieRnaConfig()\n&gt;&gt;&gt; model = ErnieRnaForNucleotidePrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer()\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 5, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/ernierna/modeling_ernierna.py</code> Python<pre><code>class ErnieRnaForNucleotidePrediction(ErnieRnaPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import ErnieRnaConfig, ErnieRnaForNucleotidePrediction, RnaTokenizer\n        &gt;&gt;&gt; config = ErnieRnaConfig()\n        &gt;&gt;&gt; model = ErnieRnaForNucleotidePrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer()\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 5, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: ErnieRnaConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.ernierna = ErnieRnaModel(config, add_pooling_layer=True)\n        self.nucleotide_head = NucleotidePredictionHead(config)\n        self.head_config = self.nucleotide_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_attention_biases: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | ErnieRnaNucleotidePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.ernierna(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_attention_biases=output_attention_biases,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.nucleotide_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return ErnieRnaNucleotidePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/ernierna/#multimolecule.models.ernierna.ErnieRnaForSequencePrediction","title":"<code>ErnieRnaForSequencePrediction</code>","text":"<p>               Bases: <code>ErnieRnaPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import ErnieRnaConfig, ErnieRnaForSequencePrediction, RnaTokenizer\n&gt;&gt;&gt; config = ErnieRnaConfig()\n&gt;&gt;&gt; model = ErnieRnaForSequencePrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer()\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input)\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 2])\n</code></pre> Source code in <code>multimolecule/models/ernierna/modeling_ernierna.py</code> Python<pre><code>class ErnieRnaForSequencePrediction(ErnieRnaPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import ErnieRnaConfig, ErnieRnaForSequencePrediction, RnaTokenizer\n        &gt;&gt;&gt; config = ErnieRnaConfig()\n        &gt;&gt;&gt; model = ErnieRnaForSequencePrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer()\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input)\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 2])\n    \"\"\"\n\n    def __init__(self, config: ErnieRnaConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.ernierna = ErnieRnaModel(config)\n        self.sequence_head = SequencePredictionHead(config)\n        self.head_config = self.sequence_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_attention_biases: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | ErnieRnaSequencePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.ernierna(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_attention_biases=output_attention_biases,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.sequence_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return ErnieRnaSequencePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/ernierna/#multimolecule.models.ernierna.ErnieRnaForTokenPrediction","title":"<code>ErnieRnaForTokenPrediction</code>","text":"<p>               Bases: <code>ErnieRnaPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import ErnieRnaConfig, ErnieRnaForTokenPrediction, RnaTokenizer\n&gt;&gt;&gt; config = ErnieRnaConfig()\n&gt;&gt;&gt; model = ErnieRnaForTokenPrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer()\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/ernierna/modeling_ernierna.py</code> Python<pre><code>class ErnieRnaForTokenPrediction(ErnieRnaPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import ErnieRnaConfig, ErnieRnaForTokenPrediction, RnaTokenizer\n        &gt;&gt;&gt; config = ErnieRnaConfig()\n        &gt;&gt;&gt; model = ErnieRnaForTokenPrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer()\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: ErnieRnaConfig):\n        super().__init__(config)\n        self.num_labels = config.num_labels\n        self.ernierna = ErnieRnaModel(config, add_pooling_layer=True)\n        self.token_head = TokenPredictionHead(config)\n        self.head_config = self.token_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_attention_biases: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | ErnieRnaTokenPredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.ernierna(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_attention_biases=output_attention_biases,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.token_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return ErnieRnaTokenPredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/ernierna/#multimolecule.models.ernierna.ErnieRnaModel","title":"<code>ErnieRnaModel</code>","text":"<p>               Bases: <code>ErnieRnaPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import ErnieRnaConfig, ErnieRnaModel, RnaTokenizer\n&gt;&gt;&gt; config = ErnieRnaConfig()\n&gt;&gt;&gt; model = ErnieRnaModel(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer()\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input)\n&gt;&gt;&gt; output[\"last_hidden_state\"].shape\ntorch.Size([1, 7, 768])\n&gt;&gt;&gt; output[\"pooler_output\"].shape\ntorch.Size([1, 768])\n</code></pre> Source code in <code>multimolecule/models/ernierna/modeling_ernierna.py</code> Python<pre><code>class ErnieRnaModel(ErnieRnaPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import ErnieRnaConfig, ErnieRnaModel, RnaTokenizer\n        &gt;&gt;&gt; config = ErnieRnaConfig()\n        &gt;&gt;&gt; model = ErnieRnaModel(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer()\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input)\n        &gt;&gt;&gt; output[\"last_hidden_state\"].shape\n        torch.Size([1, 7, 768])\n        &gt;&gt;&gt; output[\"pooler_output\"].shape\n        torch.Size([1, 768])\n    \"\"\"\n\n    pairwise_bias_map: Tensor\n\n    def __init__(\n        self, config: ErnieRnaConfig, add_pooling_layer: bool = True, tokenizer: PreTrainedTokenizer | None = None\n    ):\n        super().__init__(config)\n        if tokenizer is None:\n            tokenizer = AutoTokenizer.from_pretrained(\"multimolecule/rna\")\n        self.tokenizer = tokenizer\n        self.pad_token_id = tokenizer.pad_token_id\n        self.vocab_size = len(self.tokenizer)\n        if self.vocab_size != config.vocab_size:\n            raise ValueError(\n                f\"Vocab size in tokenizer ({self.vocab_size}) does not match the one in config ({config.vocab_size})\"\n            )\n        token_to_ids = self.tokenizer._token_to_id\n        tokens = sorted(token_to_ids, key=token_to_ids.get)\n        pairwise_bias_dict = get_pairwise_bias_dict(config.pairwise_alpha)\n        self.register_buffer(\n            \"pairwise_bias_map\",\n            torch.tensor([[pairwise_bias_dict.get(f\"{i}{j}\", 0) for i in tokens] for j in tokens]),\n            persistent=False,\n        )\n        self.pairwise_bias_proj = nn.Sequential(\n            nn.Linear(1, config.num_attention_heads // 2),\n            nn.GELU(),\n            nn.Linear(config.num_attention_heads // 2, config.num_attention_heads),\n        )\n        self.embeddings = ErnieRnaEmbeddings(config)\n        self.encoder = ErnieRnaEncoder(config)\n        self.pooler = ErnieRnaPooler(config) if add_pooling_layer else None\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.embeddings.word_embeddings\n\n    def set_input_embeddings(self, value):\n        self.embeddings.word_embeddings = value\n\n    def _prune_heads(self, heads_to_prune):\n        \"\"\"\n        Prunes heads of the model. heads_to_prune: dict of {layer_num: list of heads to prune in this layer} See base\n        class PreTrainedModel\n        \"\"\"\n        for layer, heads in heads_to_prune.items():\n            self.encoder.layer[layer].attention.prune_heads(heads)\n\n    def get_pairwise_bias(\n        self, input_ids: Tensor | NestedTensor, attention_mask: Tensor | NestedTensor | None = None\n    ) -&gt; Tensor | NestedTensor:\n        batch_size, seq_len = input_ids.shape\n\n        # Broadcasting data indices to compute indices\n        data_index_x = input_ids.unsqueeze(2).expand(batch_size, seq_len, seq_len)\n        data_index_y = input_ids.unsqueeze(1).expand(batch_size, seq_len, seq_len)\n\n        # Get bias from pairwise_bias_map\n        bias = self.pairwise_bias_map[data_index_x, data_index_y]\n\n        # Zhiyuan: Is it really necessary to mask the bias? The mask position should have been nan.\n        if attention_mask is not None:\n            attention_mask = attention_mask.unsqueeze(1).expand(batch_size, seq_len, seq_len)\n            bias = bias * attention_mask\n\n        return bias\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        past_key_values: Tuple[Tuple[torch.FloatTensor, torch.FloatTensor], ...] | None = None,\n        use_cache: bool | None = None,\n        output_attentions: bool | None = None,\n        output_attention_biases: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | ErnieRnaModelOutputWithPoolingAndCrossAttentions:\n        r\"\"\"\n        encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n            Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n            the model is configured as a decoder.\n        encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n            the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n            - 1 for tokens that are **not masked**,\n            - 0 for tokens that are **masked**.\n        past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors\n            of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n            Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n        use_cache (`bool`, *optional*):\n            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n            `past_key_values`).\n        \"\"\"\n        if kwargs:\n            warn(\n                f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n                f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n                \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n            )\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        if self.config.is_decoder:\n            use_cache = use_cache if use_cache is not None else self.config.use_cache\n        else:\n            use_cache = False\n\n        attention_bias = self.get_pairwise_bias(input_ids, attention_mask)\n\n        if isinstance(input_ids, NestedTensor):\n            input_ids, attention_mask = input_ids.tensor, input_ids.mask\n        if input_ids is not None and inputs_embeds is not None:\n            raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n        if input_ids is not None:\n            self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n            input_shape = input_ids.size()\n        elif inputs_embeds is not None:\n            input_shape = inputs_embeds.size()[:-1]\n        else:\n            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n        batch_size, seq_length = input_shape\n        device = input_ids.device if input_ids is not None else inputs_embeds.device  # type: ignore[union-attr]\n\n        # past_key_values_length\n        past_key_values_length = past_key_values[0][0].shape[2] if past_key_values is not None else 0\n\n        if attention_mask is None:\n            attention_mask = (\n                input_ids.ne(self.pad_token_id)\n                if self.pad_token_id is not None\n                else torch.ones(((batch_size, seq_length + past_key_values_length)), device=device)\n            )\n\n        # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n        # ourselves in which case we just need to make it broadcastable to all heads.\n        extended_attention_mask: Tensor = self.get_extended_attention_mask(attention_mask, input_shape)\n\n        # If a 2D or 3D attention mask is provided for the cross-attention\n        # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n        if self.config.is_decoder and encoder_hidden_states is not None:\n            encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n            encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n            if encoder_attention_mask is None:\n                encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n            encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n        else:\n            encoder_extended_attention_mask = None\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n        head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n        embedding_output = self.embeddings(\n            input_ids=input_ids,\n            position_ids=position_ids,\n            inputs_embeds=inputs_embeds,\n            past_key_values_length=past_key_values_length,\n        )\n        encoder_outputs = self.encoder(\n            embedding_output,\n            attention_mask=extended_attention_mask,\n            attention_bias=attention_bias,\n            head_mask=head_mask,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_extended_attention_mask,\n            past_key_values=past_key_values,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_attention_biases=output_attention_biases,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n        sequence_output = encoder_outputs[0]\n        pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n        if not return_dict:\n            return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n        return ErnieRnaModelOutputWithPoolingAndCrossAttentions(\n            last_hidden_state=sequence_output,\n            pooler_output=pooled_output,\n            past_key_values=encoder_outputs.past_key_values,\n            hidden_states=encoder_outputs.hidden_states,\n            attention_biases=encoder_outputs.attention_biases,\n            attentions=encoder_outputs.attentions,\n            cross_attentions=encoder_outputs.cross_attentions,\n        )\n</code></pre>"},{"location":"models/ernierna/#multimolecule.models.ernierna.ErnieRnaModel.forward","title":"<code>forward(input_ids, attention_mask=None, position_ids=None, head_mask=None, inputs_embeds=None, encoder_hidden_states=None, encoder_attention_mask=None, past_key_values=None, use_cache=None, output_attentions=None, output_attention_biases=None, output_hidden_states=None, return_dict=None, **kwargs)</code>","text":"<p>encoder_hidden_states  (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, optional):     Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if     the model is configured as a decoder. encoder_attention_mask (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, optional):     Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in     the cross-attention if the model is configured as a decoder. Mask values selected in <code>[0, 1]</code>:</p> Text Only<pre><code>- 1 for tokens that are **not masked**,\n- 0 for tokens that are **masked**.\n</code></pre> <p>past_key_values (<code>tuple(tuple(torch.FloatTensor))</code> of length <code>config.n_layers</code> with each tuple having 4 tensors     of shape <code>(batch_size, num_heads, sequence_length - 1, embed_size_per_head)</code>):     Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.</p> Text Only<pre><code>If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\ndon't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n`decoder_input_ids` of shape `(batch_size, sequence_length)`.\n</code></pre> <p>use_cache (<code>bool</code>, optional):     If set to <code>True</code>, <code>past_key_values</code> key value states are returned and can be used to speed up decoding (see     <code>past_key_values</code>).</p> Source code in <code>multimolecule/models/ernierna/modeling_ernierna.py</code> Python<pre><code>def forward(\n    self,\n    input_ids: Tensor | NestedTensor,\n    attention_mask: Tensor | None = None,\n    position_ids: Tensor | None = None,\n    head_mask: Tensor | None = None,\n    inputs_embeds: Tensor | NestedTensor | None = None,\n    encoder_hidden_states: Tensor | None = None,\n    encoder_attention_mask: Tensor | None = None,\n    past_key_values: Tuple[Tuple[torch.FloatTensor, torch.FloatTensor], ...] | None = None,\n    use_cache: bool | None = None,\n    output_attentions: bool | None = None,\n    output_attention_biases: bool | None = None,\n    output_hidden_states: bool | None = None,\n    return_dict: bool | None = None,\n    **kwargs,\n) -&gt; Tuple[Tensor, ...] | ErnieRnaModelOutputWithPoolingAndCrossAttentions:\n    r\"\"\"\n    encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n        Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n        the model is configured as a decoder.\n    encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n        Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n        the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n        - 1 for tokens that are **not masked**,\n        - 0 for tokens that are **masked**.\n    past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors\n        of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n        Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n        If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n        don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n        `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n    use_cache (`bool`, *optional*):\n        If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n        `past_key_values`).\n    \"\"\"\n    if kwargs:\n        warn(\n            f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n            f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n            \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n        )\n    output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n    output_hidden_states = (\n        output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n    )\n    return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n    if self.config.is_decoder:\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n    else:\n        use_cache = False\n\n    attention_bias = self.get_pairwise_bias(input_ids, attention_mask)\n\n    if isinstance(input_ids, NestedTensor):\n        input_ids, attention_mask = input_ids.tensor, input_ids.mask\n    if input_ids is not None and inputs_embeds is not None:\n        raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n    if input_ids is not None:\n        self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n        input_shape = input_ids.size()\n    elif inputs_embeds is not None:\n        input_shape = inputs_embeds.size()[:-1]\n    else:\n        raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n    batch_size, seq_length = input_shape\n    device = input_ids.device if input_ids is not None else inputs_embeds.device  # type: ignore[union-attr]\n\n    # past_key_values_length\n    past_key_values_length = past_key_values[0][0].shape[2] if past_key_values is not None else 0\n\n    if attention_mask is None:\n        attention_mask = (\n            input_ids.ne(self.pad_token_id)\n            if self.pad_token_id is not None\n            else torch.ones(((batch_size, seq_length + past_key_values_length)), device=device)\n        )\n\n    # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n    # ourselves in which case we just need to make it broadcastable to all heads.\n    extended_attention_mask: Tensor = self.get_extended_attention_mask(attention_mask, input_shape)\n\n    # If a 2D or 3D attention mask is provided for the cross-attention\n    # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n    if self.config.is_decoder and encoder_hidden_states is not None:\n        encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n        encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n        if encoder_attention_mask is None:\n            encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n        encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n    else:\n        encoder_extended_attention_mask = None\n\n    # Prepare head mask if needed\n    # 1.0 in head_mask indicate we keep the head\n    # attention_probs has shape bsz x n_heads x N x N\n    # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n    # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n    head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n    embedding_output = self.embeddings(\n        input_ids=input_ids,\n        position_ids=position_ids,\n        inputs_embeds=inputs_embeds,\n        past_key_values_length=past_key_values_length,\n    )\n    encoder_outputs = self.encoder(\n        embedding_output,\n        attention_mask=extended_attention_mask,\n        attention_bias=attention_bias,\n        head_mask=head_mask,\n        encoder_hidden_states=encoder_hidden_states,\n        encoder_attention_mask=encoder_extended_attention_mask,\n        past_key_values=past_key_values,\n        use_cache=use_cache,\n        output_attentions=output_attentions,\n        output_attention_biases=output_attention_biases,\n        output_hidden_states=output_hidden_states,\n        return_dict=return_dict,\n    )\n    sequence_output = encoder_outputs[0]\n    pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n    if not return_dict:\n        return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n    return ErnieRnaModelOutputWithPoolingAndCrossAttentions(\n        last_hidden_state=sequence_output,\n        pooler_output=pooled_output,\n        past_key_values=encoder_outputs.past_key_values,\n        hidden_states=encoder_outputs.hidden_states,\n        attention_biases=encoder_outputs.attention_biases,\n        attentions=encoder_outputs.attentions,\n        cross_attentions=encoder_outputs.cross_attentions,\n    )\n</code></pre>"},{"location":"models/ernierna/#multimolecule.models.ernierna.ErnieRnaPreTrainedModel","title":"<code>ErnieRnaPreTrainedModel</code>","text":"<p>               Bases: <code>PreTrainedModel</code></p> <p>An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained models.</p> Source code in <code>multimolecule/models/ernierna/modeling_ernierna.py</code> Python<pre><code>class ErnieRnaPreTrainedModel(PreTrainedModel):\n    \"\"\"\n    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n    models.\n    \"\"\"\n\n    config_class = ErnieRnaConfig\n    base_model_prefix = \"ernierna\"\n    supports_gradient_checkpointing = True\n    _no_split_modules = [\"ErnieRnaLayer\", \"ErnieRnaEmbeddings\"]\n\n    # Copied from transformers.models.bert.modeling_bert.BertPreTrainedModel._init_weights\n    def _init_weights(self, module: nn.Module):\n        \"\"\"Initialize the weights\"\"\"\n        if isinstance(module, nn.Linear):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, nn.Embedding):\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.padding_idx is not None:\n                module.weight.data[module.padding_idx].zero_()\n        elif isinstance(module, nn.LayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n</code></pre>"},{"location":"models/rinalmo/","title":"RiNALMo","text":"<p>Pre-trained model on non-coding RNA (ncRNA) using a masked language modeling (MLM) objective.</p>"},{"location":"models/rinalmo/#disclaimer","title":"Disclaimer","text":"<p>This is an UNOFFICIAL implementation of the RiNALMo: General-Purpose RNA Language Models Can Generalize Well on Structure Prediction Tasks by Rafael Josip Peni\u0107, et al.</p> <p>The OFFICIAL repository of RiNALMo is at lbcb-sci/RiNALMo.</p> <p>The team releasing RiNALMo did not write this model card for this model so this model card has been written by the MultiMolecule team.</p>"},{"location":"models/rinalmo/#model-details","title":"Model Details","text":"<p>RiNALMo is a bert-style model pre-trained on a large corpus of non-coding RNA sequences in a self-supervised fashion. This means that the model was trained on the raw nucleotides of RNA sequences only, with an automatic process to generate inputs and labels from those texts. Please refer to the Training Details section for more information on the training process.</p>"},{"location":"models/rinalmo/#variations","title":"Variations","text":"<ul> <li><code>multimolecule/rinalmo</code>: The pre-trained RiNALMo-GiGa model.</li> </ul>"},{"location":"models/rinalmo/#model-specification","title":"Model Specification","text":"Variants Num Parameters (M) FLOPs (G) MACs (G) max token length RiNALMo 650.88 168.92 84.43 1022"},{"location":"models/rinalmo/#links","title":"Links","text":"<ul> <li>Code: multimolecule.rinalmo</li> <li>Data: RNAcentral</li> <li>Paper: RiNALMo: General-Purpose RNA Language Models Can Generalize Well on Structure Prediction Tasks</li> <li>Developed by: Rafael Josip Peni\u0107, Tin Vla\u0161i\u0107, Roland G. Huber, Yue Wan, Mile \u0160iki\u0107</li> <li>Model type: BERT</li> <li>Original Repository: https://github.com/lbcb-sci/RiNALMo</li> </ul>"},{"location":"models/rinalmo/#usage","title":"Usage","text":"<p>The model file depends on the <code>multimolecule</code> library. You can install it using pip:</p> Bash<pre><code>pip install multimolecule\n</code></pre>"},{"location":"models/rinalmo/#direct-use","title":"Direct Use","text":"<p>You can use this model directly with a pipeline for masked language modeling:</p> Python<pre><code>&gt;&gt;&gt; import multimolecule  # you must import multimolecule to register models\n&gt;&gt;&gt; from transformers import pipeline\n&gt;&gt;&gt; unmasker = pipeline('fill-mask', model='multimolecule/rinalmo')\n&gt;&gt;&gt; unmasker(\"uagc&lt;mask&gt;uaucagacugauguuga\")\n\n[{'score': 0.28896641731262207,\n  'token': 6,\n  'token_str': 'A',\n  'sequence': 'U A G C A U A U C A G A C U G A U G U U G A'},\n {'score': 0.27602624893188477,\n  'token': 9,\n  'token_str': 'U',\n  'sequence': 'U A G C U U A U C A G A C U G A U G U U G A'},\n {'score': 0.18329711258411407,\n  'token': 12,\n  'token_str': 'X',\n  'sequence': 'U A G C X U A U C A G A C U G A U G U U G A'},\n {'score': 0.1668907254934311,\n  'token': 7,\n  'token_str': 'C',\n  'sequence': 'U A G C C U A U C A G A C U G A U G U U G A'},\n {'score': 0.08479981869459152,\n  'token': 8,\n  'token_str': 'G',\n  'sequence': 'U A G C G U A U C A G A C U G A U G U U G A'}]\n</code></pre>"},{"location":"models/rinalmo/#downstream-use","title":"Downstream Use","text":""},{"location":"models/rinalmo/#extract-features","title":"Extract Features","text":"<p>Here is how to use this model to get the features of a given sequence in PyTorch:</p> Python<pre><code>from multimolecule import RnaTokenizer, RiNALMoModel\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/rinalmo')\nmodel = RiNALMoModel.from_pretrained('multimolecule/rinalmo')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\n\noutput = model(**input)\n</code></pre>"},{"location":"models/rinalmo/#sequence-classification-regression","title":"Sequence Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for sequence classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a sequence-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, RiNALMoForSequencePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/rinalmo')\nmodel = RiNALMoForSequencePrediction.from_pretrained('multimolecule/rinalmo')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.tensor([1])\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/rinalmo/#nucleotide-classification-regression","title":"Nucleotide Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for nucleotide classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a nucleotide-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, RiNALMoForNucleotidePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/rinalmo')\nmodel = RiNALMoForNucleotidePrediction.from_pretrained('multimolecule/rinalmo')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.randint(2, (len(text), ))\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/rinalmo/#training-details","title":"Training Details","text":"<p>RiNALMo used Masked Language Modeling (MLM) as the pre-training objective: taking a sequence, the model randomly masks 15% of the tokens in the input then runs the entire masked sentence through the model and has to predict the masked tokens. This is comparable to the Cloze task in language modeling.</p>"},{"location":"models/rinalmo/#training-data","title":"Training Data","text":"<p>The RiNALMo model was pre-trained on a cocktail of databases including RNAcentral, Rfam, Ensembl Genome Browser, and Nucleotide. The training data contains 36 million unique ncRNA sequences.</p> <p>To ensure sequence diversity in each training batch, RiNALMo clustered the sequences with MMSeqs2 into 17 million clusters and then sampled each sequence in the batch from a different cluster.</p> <p>RiNALMo preprocessed all tokens by replacing \u201cU\u201ds with \u201cT\u201ds.</p> <p>Note that during model conversions, \u201cT\u201d is replaced with \u201cU\u201d. <code>RnaTokenizer</code> will convert \u201cT\u201ds to \u201cU\u201ds for you, you may disable this behaviour by passing <code>replace_T_with_U=False</code>.</p>"},{"location":"models/rinalmo/#training-procedure","title":"Training Procedure","text":""},{"location":"models/rinalmo/#preprocessing","title":"Preprocessing","text":"<p>RiNALMo used masked language modeling (MLM) as the pre-training objective. The masking procedure is similar to the one used in BERT:</p> <ul> <li>15% of the tokens are masked.</li> <li>In 80% of the cases, the masked tokens are replaced by <code>&lt;mask&gt;</code>.</li> <li>In 10% of the cases, the masked tokens are replaced by a random token (different) from the one they replace.</li> <li>In the 10% remaining cases, the masked tokens are left as is.</li> </ul>"},{"location":"models/rinalmo/#pretraining","title":"PreTraining","text":"<p>The model was trained on 7 NVIDIA A100 GPUs with 80GiB memories.</p> <ul> <li>Learning rate: 5e-5</li> <li>Learning rate scheduler: cosine</li> <li>Learning rate warm-up: 2,000 steps</li> <li>Learning rate minimum: 1e-5</li> <li>Epochs: 6</li> <li>Batch Size: 1344</li> <li>Dropout: 0.1</li> </ul>"},{"location":"models/rinalmo/#citation","title":"Citation","text":"<p>BibTeX:</p> BibTeX<pre><code>@article{penic2024rinalmo,\n  title={RiNALMo: General-Purpose RNA Language Models Can Generalize Well on Structure Prediction Tasks},\n  author={Peni\u0107, Rafael Josip and Vla\u0161i\u0107, Tin and Huber, Roland G. and Wan, Yue and \u0160iki\u0107, Mile},\n  journal={arXiv preprint arXiv:2403.00043},\n  year={2024}\n}\n</code></pre>"},{"location":"models/rinalmo/#contact","title":"Contact","text":"<p>Please use GitHub issues of MultiMolecule for any questions or comments on the model card.</p> <p>Please contact the authors of the RiNALMo paper for questions or comments on the paper/model.</p>"},{"location":"models/rinalmo/#license","title":"License","text":"<p>This model is licensed under the AGPL-3.0 License.</p> Text Only<pre><code>SPDX-License-Identifier: AGPL-3.0-or-later\n</code></pre>"},{"location":"models/rinalmo/#multimolecule.models.rinalmo","title":"<code>multimolecule.models.rinalmo</code>","text":""},{"location":"models/rinalmo/#multimolecule.models.rinalmo.RnaTokenizer","title":"<code>RnaTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>Constructs an RNA tokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>alphabet</code> <code>List[str] | None</code> <p>List of tokens to use. Defaults to IUPAC nucleotide code.</p> <code>None</code> <code>nmers</code> <code>int</code> <p>Size of nmers to tokenize. Defaults to 1.</p> <code>1</code> <code>codon</code> <code>bool</code> <p>Whether to tokenize into codons. Defaults to False.</p> <code>False</code> <code>replace_T_with_U</code> <code>bool</code> <p>Whether to replace T with U. Defaults to True.</p> <code>True</code> <code>do_upper_case</code> <code>bool</code> <p>Whether to convert input to uppercase. Defaults to True.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaTokenizer\n&gt;&gt;&gt; tokenizer = RnaTokenizer()\n&gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n[1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n&gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 3, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 17, 64, 49, 96, 84, 22, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 49, 22, 2]\n&gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\nTraceback (most recent call last):\nValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n</code></pre> Source code in <code>multimolecule/tokenisers/rna/tokenization_rna.py</code> Python<pre><code>class RnaTokenizer(Tokenizer):\n    \"\"\"\n    Constructs an RNA tokenizer.\n\n    Args:\n        alphabet (List[str] | None, optional): List of tokens to use.\n            Defaults to [IUPAC nucleotide code](https://www.bioinformatics.org/sms2/iupac.html).\n        nmers (int, optional): Size of nmers to tokenize.\n            Defaults to 1.\n        codon (bool, optional): Whether to tokenize into codons.\n            Defaults to False.\n        replace_T_with_U (bool, optional): Whether to replace T with U.\n            Defaults to True.\n        do_upper_case (bool, optional): Whether to convert input to uppercase.\n            Defaults to True.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaTokenizer\n        &gt;&gt;&gt; tokenizer = RnaTokenizer()\n        &gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n        [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n        &gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 3, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 17, 64, 49, 96, 84, 22, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 49, 22, 2]\n        &gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\n        Traceback (most recent call last):\n        ValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n    \"\"\"\n\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n\n    def __init__(\n        self,\n        alphabet: List[str] | None = None,\n        nmers: int = 1,\n        codon: bool = False,\n        replace_T_with_U: bool = True,\n        bos_token: str = \"&lt;cls&gt;\",\n        cls_token: str = \"&lt;cls&gt;\",\n        pad_token: str = \"&lt;pad&gt;\",\n        eos_token: str = \"&lt;eos&gt;\",\n        sep_token: str = \"&lt;eos&gt;\",\n        unk_token: str = \"&lt;unk&gt;\",\n        mask_token: str = \"&lt;mask&gt;\",\n        additional_special_tokens: List | Tuple | None = None,\n        do_upper_case: bool = True,\n        **kwargs,\n    ):\n        if codon and nmers &gt; 1:\n            raise ValueError(\"Codon and nmers cannot be used together.\")\n        if codon:\n            nmers = 3  # set to 3 to get correct vocab\n        super().__init__(\n            alphabet=get_vocab_list(alphabet, nmers),\n            bos_token=bos_token,\n            cls_token=cls_token,\n            pad_token=pad_token,\n            eos_token=eos_token,\n            sep_token=sep_token,\n            unk_token=unk_token,\n            mask_token=mask_token,\n            additional_special_tokens=additional_special_tokens,\n            do_upper_case=do_upper_case,\n            **kwargs,\n        )\n        self.replace_T_with_U = replace_T_with_U\n        self.nmers = nmers\n        self.condon = codon\n\n    def _tokenize(self, text: str, **kwargs):\n        if self.do_upper_case:\n            text = text.upper()\n        if self.replace_T_with_U:\n            text = text.replace(\"T\", \"U\")\n        if self.condon:\n            if len(text) % 3 != 0:\n                raise ValueError(\n                    f\"length of input sequence  must be a multiple of 3 for codon tokenization, but got {len(text)}\"\n                )\n            return [text[i : i + 3] for i in range(0, len(text), 3)]\n        if self.nmers &gt; 1:\n            return [text[i : i + self.nmers] for i in range(len(text) - self.nmers + 1)]  # noqa: E203\n        return list(text)\n</code></pre>"},{"location":"models/rinalmo/#multimolecule.models.rinalmo.RiNALMoConfig","title":"<code>RiNALMoConfig</code>","text":"<p>               Bases: <code>PreTrainedConfig</code></p> <p>This is the configuration class to store the configuration of a [<code>RiNALMoModel</code>]. It is used to instantiate a RiNALMo model according to the specified arguments, defining the model architecture. Instantiating a configuration with the defaults will yield a similar configuration to that of the RiNALMo lbcb-sci/RiNALMo architecture.</p> <p>Configuration objects inherit from [<code>PreTrainedConfig</code>] and can be used to control the model outputs. Read the documentation from [<code>PreTrainedConfig</code>] for more information.</p> <p>Parameters:</p> Name Type Description Default <code>vocab_size</code> <code>`int`, *optional*, defaults to 26</code> <p>Vocabulary size of the RiNALMo model. Defines the number of different tokens that can be represented by the <code>inputs_ids</code> passed when calling [<code>RiNALMoModel</code>].</p> <code>26</code> <code>hidden_size</code> <code>`int`, *optional*, defaults to 640</code> <p>Dimensionality of the encoder layers and the pooler layer.</p> <code>1280</code> <code>num_hidden_layers</code> <code>`int`, *optional*, defaults to 12</code> <p>Number of hidden layers in the Transformer encoder.</p> <code>33</code> <code>num_attention_heads</code> <code>`int`, *optional*, defaults to 20</code> <p>Number of attention heads for each attention layer in the Transformer encoder.</p> <code>20</code> <code>intermediate_size</code> <code>`int`, *optional*, defaults to 5120</code> <p>Dimensionality of the \u201cintermediate\u201d (often named feed-forward) layer in the Transformer encoder.</p> <code>5120</code> <code>hidden_dropout</code> <code>`float`, *optional*, defaults to 0.1</code> <p>The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.</p> <code>0.1</code> <code>attention_dropout</code> <code>`float`, *optional*, defaults to 0.1</code> <p>The dropout ratio for the attention probabilities.</p> <code>0.1</code> <code>max_position_embeddings</code> <code>`int`, *optional*, defaults to 1026</code> <p>The maximum sequence length that this model might ever be used with. Typically set this to something large just in case (e.g., 512 or 1024 or 2048).</p> <code>1024</code> <code>initializer_range</code> <code>`float`, *optional*, defaults to 0.02</code> <p>The standard deviation of the truncated_normal_initializer for initializing all weight matrices.</p> <code>0.02</code> <code>layer_norm_eps</code> <code>`float`, *optional*, defaults to 1e-12</code> <p>The epsilon used by the layer normalization layers.</p> <code>1e-12</code> <code>position_embedding_type</code> <code>`str`, *optional*, defaults to `\"rotary\"`</code> <p>Type of position embedding. Choose one of <code>\"absolute\"</code>, <code>\"relative_key\"</code>, <code>\"relative_key_query\", \"rotary\"</code>. For positional embeddings use <code>\"absolute\"</code>. For more information on <code>\"relative_key\"</code>, please refer to Self-Attention with Relative Position Representations (Shaw et al.). For more information on <code>\"relative_key_query\"</code>, please refer to Method 4 in Improve Transformer Models with Better Relative Position Embeddings (Huang et al.).</p> <code>'rotary'</code> <code>is_decoder</code> <code>`bool`, *optional*, defaults to `False`</code> <p>Whether the model is used as a decoder or not. If <code>False</code>, the model is used as an encoder.</p> required <code>use_cache</code> <code>`bool`, *optional*, defaults to `True`</code> <p>Whether or not the model should return the last key/values attentions (not used by all models). Only relevant if <code>config.is_decoder=True</code>.</p> <code>True</code> <code>emb_layer_norm_before</code> <code>`bool`, *optional*</code> <p>Whether to apply layer normalization after embeddings but before the main stem of the network.</p> required <code>token_dropout</code> <code>`bool`, defaults to `False`</code> <p>When this is enabled, masked tokens are treated as if they had been dropped out by input dropout.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RiNALMoModel, RiNALMoConfig\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a RiNALMo multimolecule/rinalmo style configuration\n&gt;&gt;&gt; configuration = RiNALMoConfig()\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/rinalmo style configuration\n&gt;&gt;&gt; model = RiNALMoModel(configuration)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Accessing the model configuration\n&gt;&gt;&gt; configuration = model.config\n</code></pre> Source code in <code>multimolecule/models/rinalmo/configuration_rinalmo.py</code> Python<pre><code>class RiNALMoConfig(PreTrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`RiNALMoModel`]. It is used to instantiate a\n    RiNALMo model according to the specified arguments, defining the model architecture. Instantiating a configuration\n    with the defaults will yield a similar configuration to that of the RiNALMo\n    [lbcb-sci/RiNALMo](https://github.com/lbcb-sci/RiNALMo) architecture.\n\n    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n    documentation from [`PreTrainedConfig`] for more information.\n\n\n    Args:\n        vocab_size (`int`, *optional*, defaults to 26):\n            Vocabulary size of the RiNALMo model. Defines the number of different tokens that can be represented by the\n            `inputs_ids` passed when calling [`RiNALMoModel`].\n        hidden_size (`int`, *optional*, defaults to 640):\n            Dimensionality of the encoder layers and the pooler layer.\n        num_hidden_layers (`int`, *optional*, defaults to 12):\n            Number of hidden layers in the Transformer encoder.\n        num_attention_heads (`int`, *optional*, defaults to 20):\n            Number of attention heads for each attention layer in the Transformer encoder.\n        intermediate_size (`int`, *optional*, defaults to 5120):\n            Dimensionality of the \"intermediate\" (often named feed-forward) layer in the Transformer encoder.\n        hidden_dropout (`float`, *optional*, defaults to 0.1):\n            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n        attention_dropout (`float`, *optional*, defaults to 0.1):\n            The dropout ratio for the attention probabilities.\n        max_position_embeddings (`int`, *optional*, defaults to 1026):\n            The maximum sequence length that this model might ever be used with. Typically set this to something large\n            just in case (e.g., 512 or 1024 or 2048).\n        initializer_range (`float`, *optional*, defaults to 0.02):\n            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n        layer_norm_eps (`float`, *optional*, defaults to 1e-12):\n            The epsilon used by the layer normalization layers.\n        position_embedding_type (`str`, *optional*, defaults to `\"rotary\"`):\n            Type of position embedding. Choose one of `\"absolute\"`, `\"relative_key\"`, `\"relative_key_query\", \"rotary\"`.\n            For positional embeddings use `\"absolute\"`. For more information on `\"relative_key\"`, please refer to\n            [Self-Attention with Relative Position Representations (Shaw et al.)](https://arxiv.org/abs/1803.02155).\n            For more information on `\"relative_key_query\"`, please refer to *Method 4* in [Improve Transformer Models\n            with Better Relative Position Embeddings (Huang et al.)](https://arxiv.org/abs/2009.13658).\n        is_decoder (`bool`, *optional*, defaults to `False`):\n            Whether the model is used as a decoder or not. If `False`, the model is used as an encoder.\n        use_cache (`bool`, *optional*, defaults to `True`):\n            Whether or not the model should return the last key/values attentions (not used by all models). Only\n            relevant if `config.is_decoder=True`.\n        emb_layer_norm_before (`bool`, *optional*):\n            Whether to apply layer normalization after embeddings but before the main stem of the network.\n        token_dropout (`bool`, defaults to `False`):\n            When this is enabled, masked tokens are treated as if they had been dropped out by input dropout.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RiNALMoModel, RiNALMoConfig\n\n        &gt;&gt;&gt; # Initializing a RiNALMo multimolecule/rinalmo style configuration\n        &gt;&gt;&gt; configuration = RiNALMoConfig()\n\n        &gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/rinalmo style configuration\n        &gt;&gt;&gt; model = RiNALMoModel(configuration)\n\n        &gt;&gt;&gt; # Accessing the model configuration\n        &gt;&gt;&gt; configuration = model.config\n    \"\"\"\n\n    model_type = \"rinalmo\"\n\n    def __init__(\n        self,\n        vocab_size=26,\n        hidden_size=1280,\n        num_hidden_layers=33,\n        num_attention_heads=20,\n        intermediate_size=5120,\n        hidden_act=\"gelu\",\n        hidden_dropout=0.1,\n        attention_dropout=0.1,\n        max_position_embeddings=1024,\n        initializer_range=0.02,\n        layer_norm_eps=1e-12,\n        position_embedding_type=\"rotary\",\n        use_cache=True,\n        learnable_beta=True,\n        token_dropout=True,\n        head=None,\n        lm_head=None,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n        self.vocab_size = vocab_size\n        self.hidden_size = hidden_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_attention_heads = num_attention_heads\n        self.intermediate_size = intermediate_size\n        self.hidden_act = hidden_act\n        self.hidden_dropout = hidden_dropout\n        self.attention_dropout = attention_dropout\n        self.max_position_embeddings = max_position_embeddings\n        self.initializer_range = initializer_range\n        self.layer_norm_eps = layer_norm_eps\n        self.position_embedding_type = position_embedding_type\n        self.use_cache = use_cache\n        self.learnable_beta = learnable_beta\n        self.token_dropout = token_dropout\n        self.head = HeadConfig(**head if head is not None else {})\n        self.lm_head = MaskedLMHeadConfig(**lm_head if lm_head is not None else {})\n        self.emb_layer_norm_before = True\n</code></pre>"},{"location":"models/rinalmo/#multimolecule.models.rinalmo.RiNALMoForMaskedLM","title":"<code>RiNALMoForMaskedLM</code>","text":"<p>               Bases: <code>RiNALMoPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RiNALMoConfig, RiNALMoForMaskedLM, RnaTokenizer\n&gt;&gt;&gt; config = RiNALMoConfig()\n&gt;&gt;&gt; model = RiNALMoForMaskedLM(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 26])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/rinalmo/modeling_rinalmo.py</code> Python<pre><code>class RiNALMoForMaskedLM(RiNALMoPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RiNALMoConfig, RiNALMoForMaskedLM, RnaTokenizer\n        &gt;&gt;&gt; config = RiNALMoConfig()\n        &gt;&gt;&gt; model = RiNALMoForMaskedLM(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 26])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    _tied_weights_keys = [\"lm_head.decoder.weight\"]\n\n    def __init__(self, config: RiNALMoConfig):\n        super().__init__(config)\n        if config.is_decoder:\n            logger.warning(\n                \"If you want to use `RiNALMoForMaskedLM` make sure `config.is_decoder=False` for \"\n                \"bi-directional self-attention.\"\n            )\n        self.rinalmo = RiNALMoModel(config, add_pooling_layer=False)\n        self.lm_head = MaskedLMHead(config)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | MaskedLMOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rinalmo(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_attention_mask,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.lm_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return MaskedLMOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/rinalmo/#multimolecule.models.rinalmo.RiNALMoForNucleotidePrediction","title":"<code>RiNALMoForNucleotidePrediction</code>","text":"<p>               Bases: <code>RiNALMoPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RiNALMoConfig, RiNALMoForNucleotidePrediction, RnaTokenizer\n&gt;&gt;&gt; config = RiNALMoConfig()\n&gt;&gt;&gt; model = RiNALMoForNucleotidePrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 5, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/rinalmo/modeling_rinalmo.py</code> Python<pre><code>class RiNALMoForNucleotidePrediction(RiNALMoPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RiNALMoConfig, RiNALMoForNucleotidePrediction, RnaTokenizer\n        &gt;&gt;&gt; config = RiNALMoConfig()\n        &gt;&gt;&gt; model = RiNALMoForNucleotidePrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 5, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: RiNALMoConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.rinalmo = RiNALMoModel(config, add_pooling_layer=True)\n        self.nucleotide_head = NucleotidePredictionHead(config)\n        self.head_config = self.nucleotide_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | NucleotidePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rinalmo(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.nucleotide_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return NucleotidePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/rinalmo/#multimolecule.models.rinalmo.RiNALMoForSequencePrediction","title":"<code>RiNALMoForSequencePrediction</code>","text":"<p>               Bases: <code>RiNALMoPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RiNALMoConfig, RiNALMoForSequencePrediction, RnaTokenizer\n&gt;&gt;&gt; config = RiNALMoConfig()\n&gt;&gt;&gt; model = RiNALMoForSequencePrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.tensor([[1]]))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/rinalmo/modeling_rinalmo.py</code> Python<pre><code>class RiNALMoForSequencePrediction(RiNALMoPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RiNALMoConfig, RiNALMoForSequencePrediction, RnaTokenizer\n        &gt;&gt;&gt; config = RiNALMoConfig()\n        &gt;&gt;&gt; model = RiNALMoForSequencePrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.tensor([[1]]))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: RiNALMoConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.rinalmo = RiNALMoModel(config, add_pooling_layer=True)\n        self.sequence_head = SequencePredictionHead(config)\n        self.head_config = self.sequence_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | SequencePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rinalmo(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.sequence_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return SequencePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/rinalmo/#multimolecule.models.rinalmo.RiNALMoForTokenPrediction","title":"<code>RiNALMoForTokenPrediction</code>","text":"<p>               Bases: <code>RiNALMoPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RiNALMoConfig, RiNALMoForTokenPrediction, RnaTokenizer\n&gt;&gt;&gt; config = RiNALMoConfig()\n&gt;&gt;&gt; model = RiNALMoForTokenPrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/rinalmo/modeling_rinalmo.py</code> Python<pre><code>class RiNALMoForTokenPrediction(RiNALMoPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RiNALMoConfig, RiNALMoForTokenPrediction, RnaTokenizer\n        &gt;&gt;&gt; config = RiNALMoConfig()\n        &gt;&gt;&gt; model = RiNALMoForTokenPrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: RiNALMoConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.rinalmo = RiNALMoModel(config, add_pooling_layer=True)\n        self.token_head = TokenPredictionHead(config)\n        self.head_config = self.token_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | TokenPredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rinalmo(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.token_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return TokenPredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/rinalmo/#multimolecule.models.rinalmo.RiNALMoModel","title":"<code>RiNALMoModel</code>","text":"<p>               Bases: <code>RiNALMoPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RiNALMoConfig, RiNALMoModel, RnaTokenizer\n&gt;&gt;&gt; config = RiNALMoConfig()\n&gt;&gt;&gt; model = RiNALMoModel(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input)\n&gt;&gt;&gt; output[\"last_hidden_state\"].shape\ntorch.Size([1, 7, 1280])\n&gt;&gt;&gt; output[\"pooler_output\"].shape\ntorch.Size([1, 1280])\n</code></pre> Source code in <code>multimolecule/models/rinalmo/modeling_rinalmo.py</code> Python<pre><code>class RiNALMoModel(RiNALMoPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RiNALMoConfig, RiNALMoModel, RnaTokenizer\n        &gt;&gt;&gt; config = RiNALMoConfig()\n        &gt;&gt;&gt; model = RiNALMoModel(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input)\n        &gt;&gt;&gt; output[\"last_hidden_state\"].shape\n        torch.Size([1, 7, 1280])\n        &gt;&gt;&gt; output[\"pooler_output\"].shape\n        torch.Size([1, 1280])\n    \"\"\"\n\n    def __init__(self, config: RiNALMoConfig, add_pooling_layer: bool = True):\n        super().__init__(config)\n        self.pad_token_id = config.pad_token_id\n        self.embeddings = RiNALMoEmbeddings(config)\n        self.encoder = RiNALMoEncoder(config)\n        self.pooler = RiNALMoPooler(config) if add_pooling_layer else None\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.embeddings.word_embeddings\n\n    def set_input_embeddings(self, value):\n        self.embeddings.word_embeddings = value\n\n    def _prune_heads(self, heads_to_prune):\n        \"\"\"\n        Prunes heads of the model. heads_to_prune: dict of {layer_num: list of heads to prune in this layer} See base\n        class PreTrainedModel\n        \"\"\"\n        for layer, heads in heads_to_prune.items():\n            self.encoder.layer[layer].attention.prune_heads(heads)\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        past_key_values: Tuple[Tuple[torch.FloatTensor, torch.FloatTensor], ...] | None = None,\n        use_cache: bool | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | BaseModelOutputWithPoolingAndCrossAttentions:\n        r\"\"\"\n        encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n            Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n            the model is configured as a decoder.\n        encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n            the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n            - 1 for tokens that are **not masked**,\n            - 0 for tokens that are **masked**.\n        past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors\n            of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n            Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n        use_cache (`bool`, *optional*):\n            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n            `past_key_values`).\n        \"\"\"\n        if kwargs:\n            warn(\n                f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n                f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n                \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n            )\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        if self.config.is_decoder:\n            use_cache = use_cache if use_cache is not None else self.config.use_cache\n        else:\n            use_cache = False\n\n        if isinstance(input_ids, NestedTensor):\n            input_ids, attention_mask = input_ids.tensor, input_ids.mask\n        if input_ids is not None and inputs_embeds is not None:\n            raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n        if input_ids is not None:\n            self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n            input_shape = input_ids.size()\n        elif inputs_embeds is not None:\n            input_shape = inputs_embeds.size()[:-1]\n        else:\n            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n        batch_size, seq_length = input_shape\n        device = input_ids.device if input_ids is not None else inputs_embeds.device  # type: ignore[union-attr]\n\n        # past_key_values_length\n        past_key_values_length = past_key_values[0][0].shape[2] if past_key_values is not None else 0\n\n        if attention_mask is None:\n            attention_mask = (\n                input_ids.ne(self.pad_token_id)\n                if self.pad_token_id is not None\n                else torch.ones(((batch_size, seq_length + past_key_values_length)), device=device)\n            )\n\n        # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n        # ourselves in which case we just need to make it broadcastable to all heads.\n        extended_attention_mask: Tensor = self.get_extended_attention_mask(attention_mask, input_shape)\n\n        # If a 2D or 3D attention mask is provided for the cross-attention\n        # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n        if self.config.is_decoder and encoder_hidden_states is not None:\n            encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n            encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n            if encoder_attention_mask is None:\n                encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n            encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n        else:\n            encoder_extended_attention_mask = None\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n        head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n        embedding_output = self.embeddings(\n            input_ids=input_ids,\n            position_ids=position_ids,\n            attention_mask=attention_mask,\n            inputs_embeds=inputs_embeds,\n            past_key_values_length=past_key_values_length,\n        )\n        encoder_outputs = self.encoder(\n            embedding_output,\n            attention_mask=extended_attention_mask,\n            head_mask=head_mask,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_extended_attention_mask,\n            past_key_values=past_key_values,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n        sequence_output = encoder_outputs[0]\n        pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n        if not return_dict:\n            return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n        return BaseModelOutputWithPoolingAndCrossAttentions(\n            last_hidden_state=sequence_output,\n            pooler_output=pooled_output,\n            past_key_values=encoder_outputs.past_key_values,\n            hidden_states=encoder_outputs.hidden_states,\n            attentions=encoder_outputs.attentions,\n            cross_attentions=encoder_outputs.cross_attentions,\n        )\n</code></pre>"},{"location":"models/rinalmo/#multimolecule.models.rinalmo.RiNALMoModel.forward","title":"<code>forward(input_ids, attention_mask=None, position_ids=None, head_mask=None, inputs_embeds=None, encoder_hidden_states=None, encoder_attention_mask=None, past_key_values=None, use_cache=None, output_attentions=None, output_hidden_states=None, return_dict=None, **kwargs)</code>","text":"<p>encoder_hidden_states  (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, optional):     Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if     the model is configured as a decoder. encoder_attention_mask (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, optional):     Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in     the cross-attention if the model is configured as a decoder. Mask values selected in <code>[0, 1]</code>:</p> Text Only<pre><code>- 1 for tokens that are **not masked**,\n- 0 for tokens that are **masked**.\n</code></pre> <p>past_key_values (<code>tuple(tuple(torch.FloatTensor))</code> of length <code>config.n_layers</code> with each tuple having 4 tensors     of shape <code>(batch_size, num_heads, sequence_length - 1, embed_size_per_head)</code>):     Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.</p> Text Only<pre><code>If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\ndon't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n`decoder_input_ids` of shape `(batch_size, sequence_length)`.\n</code></pre> <p>use_cache (<code>bool</code>, optional):     If set to <code>True</code>, <code>past_key_values</code> key value states are returned and can be used to speed up decoding (see     <code>past_key_values</code>).</p> Source code in <code>multimolecule/models/rinalmo/modeling_rinalmo.py</code> Python<pre><code>def forward(\n    self,\n    input_ids: Tensor | NestedTensor,\n    attention_mask: Tensor | None = None,\n    position_ids: Tensor | None = None,\n    head_mask: Tensor | None = None,\n    inputs_embeds: Tensor | NestedTensor | None = None,\n    encoder_hidden_states: Tensor | None = None,\n    encoder_attention_mask: Tensor | None = None,\n    past_key_values: Tuple[Tuple[torch.FloatTensor, torch.FloatTensor], ...] | None = None,\n    use_cache: bool | None = None,\n    output_attentions: bool | None = None,\n    output_hidden_states: bool | None = None,\n    return_dict: bool | None = None,\n    **kwargs,\n) -&gt; Tuple[Tensor, ...] | BaseModelOutputWithPoolingAndCrossAttentions:\n    r\"\"\"\n    encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n        Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n        the model is configured as a decoder.\n    encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n        Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n        the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n        - 1 for tokens that are **not masked**,\n        - 0 for tokens that are **masked**.\n    past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors\n        of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n        Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n        If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n        don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n        `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n    use_cache (`bool`, *optional*):\n        If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n        `past_key_values`).\n    \"\"\"\n    if kwargs:\n        warn(\n            f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n            f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n            \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n        )\n    output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n    output_hidden_states = (\n        output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n    )\n    return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n    if self.config.is_decoder:\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n    else:\n        use_cache = False\n\n    if isinstance(input_ids, NestedTensor):\n        input_ids, attention_mask = input_ids.tensor, input_ids.mask\n    if input_ids is not None and inputs_embeds is not None:\n        raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n    if input_ids is not None:\n        self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n        input_shape = input_ids.size()\n    elif inputs_embeds is not None:\n        input_shape = inputs_embeds.size()[:-1]\n    else:\n        raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n    batch_size, seq_length = input_shape\n    device = input_ids.device if input_ids is not None else inputs_embeds.device  # type: ignore[union-attr]\n\n    # past_key_values_length\n    past_key_values_length = past_key_values[0][0].shape[2] if past_key_values is not None else 0\n\n    if attention_mask is None:\n        attention_mask = (\n            input_ids.ne(self.pad_token_id)\n            if self.pad_token_id is not None\n            else torch.ones(((batch_size, seq_length + past_key_values_length)), device=device)\n        )\n\n    # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n    # ourselves in which case we just need to make it broadcastable to all heads.\n    extended_attention_mask: Tensor = self.get_extended_attention_mask(attention_mask, input_shape)\n\n    # If a 2D or 3D attention mask is provided for the cross-attention\n    # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n    if self.config.is_decoder and encoder_hidden_states is not None:\n        encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n        encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n        if encoder_attention_mask is None:\n            encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n        encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n    else:\n        encoder_extended_attention_mask = None\n\n    # Prepare head mask if needed\n    # 1.0 in head_mask indicate we keep the head\n    # attention_probs has shape bsz x n_heads x N x N\n    # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n    # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n    head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n    embedding_output = self.embeddings(\n        input_ids=input_ids,\n        position_ids=position_ids,\n        attention_mask=attention_mask,\n        inputs_embeds=inputs_embeds,\n        past_key_values_length=past_key_values_length,\n    )\n    encoder_outputs = self.encoder(\n        embedding_output,\n        attention_mask=extended_attention_mask,\n        head_mask=head_mask,\n        encoder_hidden_states=encoder_hidden_states,\n        encoder_attention_mask=encoder_extended_attention_mask,\n        past_key_values=past_key_values,\n        use_cache=use_cache,\n        output_attentions=output_attentions,\n        output_hidden_states=output_hidden_states,\n        return_dict=return_dict,\n    )\n    sequence_output = encoder_outputs[0]\n    pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n    if not return_dict:\n        return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n    return BaseModelOutputWithPoolingAndCrossAttentions(\n        last_hidden_state=sequence_output,\n        pooler_output=pooled_output,\n        past_key_values=encoder_outputs.past_key_values,\n        hidden_states=encoder_outputs.hidden_states,\n        attentions=encoder_outputs.attentions,\n        cross_attentions=encoder_outputs.cross_attentions,\n    )\n</code></pre>"},{"location":"models/rinalmo/#multimolecule.models.rinalmo.RiNALMoPreTrainedModel","title":"<code>RiNALMoPreTrainedModel</code>","text":"<p>               Bases: <code>PreTrainedModel</code></p> <p>An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained models.</p> Source code in <code>multimolecule/models/rinalmo/modeling_rinalmo.py</code> Python<pre><code>class RiNALMoPreTrainedModel(PreTrainedModel):\n    \"\"\"\n    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n    models.\n    \"\"\"\n\n    config_class = RiNALMoConfig\n    base_model_prefix = \"rinalmo\"\n    supports_gradient_checkpointing = True\n    _no_split_modules = [\"RiNALMoLayer\", \"RiNALMoEmbeddings\"]\n\n    # Copied from transformers.models.bert.modeling_bert.BertPreTrainedModel._init_weights\n    def _init_weights(self, module: nn.Module):\n        \"\"\"Initialize the weights\"\"\"\n        if isinstance(module, nn.Linear):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, nn.Embedding):\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.padding_idx is not None:\n                module.weight.data[module.padding_idx].zero_()\n        elif isinstance(module, nn.LayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n</code></pre>"},{"location":"models/rnabert/","title":"RNABERT","text":"<p>Pre-trained model on non-coding RNA (ncRNA) using masked language modeling (MLM) and structural alignment learning (SAL) objectives.</p>"},{"location":"models/rnabert/#disclaimer","title":"Disclaimer","text":"<p>This is an UNOFFICIAL implementation of the Informative RNA-base embedding for functional RNA clustering and structural alignment by Manato Akiyama and Yasubumi Sakakibara.</p> <p>The OFFICIAL repository of RNABERT is at mana438/RNABERT.</p> <p>The team releasing RNABERT did not write this model card for this model so this model card has been written by the MultiMolecule team.</p>"},{"location":"models/rnabert/#model-details","title":"Model Details","text":"<p>RNABERT is a bert-style model pre-trained on a large corpus of non-coding RNA sequences in a self-supervised fashion. This means that the model was trained on the raw nucleotides of RNA sequences only, with an automatic process to generate inputs and labels from those texts. Please refer to the Training Details section for more information on the training process.</p>"},{"location":"models/rnabert/#model-specification","title":"Model Specification","text":"Num Layers Hidden Size Num Heads Intermediate Size Num Parameters (M) FLOPs (G) MACs (G) Max Num Tokens 6 120 12 40 0.48 0.15 0.08 440"},{"location":"models/rnabert/#links","title":"Links","text":"<ul> <li>Code: multimolecule.rnabert</li> <li>Weights: multimolecule/rnabert</li> <li>Data: RNAcentral</li> <li>Paper: Informative RNA-base embedding for functional RNA clustering and structural alignment</li> <li>Developed by: JManato Akiyama and Yasubumi Sakakibara</li> <li>Model type: BERT</li> <li>Original Repository: https://github.com/mana438/RNABERT</li> </ul>"},{"location":"models/rnabert/#usage","title":"Usage","text":"<p>The model file depends on the <code>multimolecule</code> library. You can install it using pip:</p> Bash<pre><code>pip install multimolecule\n</code></pre>"},{"location":"models/rnabert/#direct-use","title":"Direct Use","text":"<p>You can use this model directly with a pipeline for masked language modeling:</p> Python<pre><code>&gt;&gt;&gt; import multimolecule  # you must import multimolecule to register models\n&gt;&gt;&gt; from transformers import pipeline\n&gt;&gt;&gt; unmasker = pipeline('fill-mask', model='multimolecule/rnabert')\n&gt;&gt;&gt; unmasker(\"uagc&lt;mask&gt;uaucagacugauguuga\")\n\n[{'score': 0.038491372019052505,\n  'token': 5,\n  'token_str': '&lt;null&gt;',\n  'sequence': 'U A G C U A U C A G A C U G A U G U U G A'},\n {'score': 0.03848646208643913,\n  'token': 23,\n  'token_str': '.',\n  'sequence': 'U A G C. U A U C A G A C U G A U G U U G A'},\n {'score': 0.03846566751599312,\n  'token': 0,\n  'token_str': '&lt;pad&gt;',\n  'sequence': 'U A G C U A U C A G A C U G A U G U U G A'},\n {'score': 0.03846472129225731,\n  'token': 9,\n  'token_str': 'U',\n  'sequence': 'U A G C U U A U C A G A C U G A U G U U G A'},\n {'score': 0.03846454620361328,\n  'token': 19,\n  'token_str': 'W',\n  'sequence': 'U A G C W U A U C A G A C U G A U G U U G A'}]\n</code></pre>"},{"location":"models/rnabert/#downstream-use","title":"Downstream Use","text":""},{"location":"models/rnabert/#extract-features","title":"Extract Features","text":"<p>Here is how to use this model to get the features of a given sequence in PyTorch:</p> Python<pre><code>from multimolecule import RnaTokenizer, RnaBertModel\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/rnabert')\nmodel = RnaBertModel.from_pretrained('multimolecule/rnabert')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\n\noutput = model(**input)\n</code></pre>"},{"location":"models/rnabert/#sequence-classification-regression","title":"Sequence Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for sequence classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a sequence-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, RnaBertForSequencePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/rnabert')\nmodel = RnaBertForSequencePrediction.from_pretrained('multimolecule/rnabert')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.tensor([1])\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/rnabert/#nucleotide-classification-regression","title":"Nucleotide Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for nucleotide classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a nucleotide-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, RnaBertForNucleotidePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/rnabert')\nmodel = RnaBertForNucleotidePrediction.from_pretrained('multimolecule/rnabert')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.randint(2, (len(text), ))\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/rnabert/#training-details","title":"Training Details","text":"<p>RNABERT has two pre-training objectives: masked language modeling (MLM) and structural alignment learning (SAL).</p> <ul> <li>Masked Language Modeling (MLM): taking a sequence, the model randomly masks 15% of the tokens in the input then runs the entire masked sentence through the model and has to predict the masked tokens. This is comparable to the Cloze task in language modeling.</li> <li>Structural Alignment Learning (SAL): the model learns to predict the structural alignment of two RNA sequences. The model is trained to predict the alignment score of two RNA sequences using the Needleman-Wunsch algorithm.</li> </ul>"},{"location":"models/rnabert/#training-data","title":"Training Data","text":"<p>The RNABERT model was pre-trained on RNAcentral. RNAcentral is a comprehensive database of non-coding RNA sequences from a wide range of species. It combines 47 different databases, adding up to around 27 million RNA sequences in total. RNABERT used a subset of 76, 237 human ncRNA sequences from RNAcentral for pre-training.</p> <p>RNABERT preprocessed all tokens by replacing \u201cU\u201ds with \u201cT\u201ds.</p> <p>Note that during model conversions, \u201cT\u201d is replaced with \u201cU\u201d. <code>RnaTokenizer</code> will convert \u201cT\u201ds to \u201cU\u201ds for you, you may disable this behaviour by passing <code>replace_T_with_U=False</code>.</p>"},{"location":"models/rnabert/#training-procedure","title":"Training Procedure","text":""},{"location":"models/rnabert/#preprocessing","title":"Preprocessing","text":"<p>RNABERT preprocess the dataset by applying 10 different mask patterns to the 72, 237 human ncRNA sequences. The final dataset contains 722, 370 sequences. The masking procedure is similar to the one used in BERT:</p> <ul> <li>15% of the tokens are masked.</li> <li>In 80% of the cases, the masked tokens are replaced by <code>&lt;mask&gt;</code>.</li> <li>In 10% of the cases, the masked tokens are replaced by a random token (different) from the one they replace.</li> <li>In the 10% remaining cases, the masked tokens are left as is.</li> </ul>"},{"location":"models/rnabert/#pretraining","title":"PreTraining","text":"<p>The model was trained on 1 NVIDIA V100 GPU.</p>"},{"location":"models/rnabert/#citation","title":"Citation","text":"<p>BibTeX:</p> BibTeX<pre><code>@article{akiyama2022informative,\n    author = {Akiyama, Manato and Sakakibara, Yasubumi},\n    title = \"{Informative RNA base embedding for RNA structural alignment and clustering by deep representation learning}\",\n    journal = {NAR Genomics and Bioinformatics},\n    volume = {4},\n    number = {1},\n    pages = {lqac012},\n    year = {2022},\n    month = {02},\n    abstract = \"{Effective embedding is actively conducted by applying deep learning to biomolecular information. Obtaining better embeddings enhances the quality of downstream analyses, such as DNA sequence motif detection and protein function prediction. In this study, we adopt a pre-training algorithm for the effective embedding of RNA bases to acquire semantically rich representations and apply this algorithm to two fundamental RNA sequence problems: structural alignment and clustering. By using the pre-training algorithm to embed the four bases of RNA in a position-dependent manner using a large number of RNA sequences from various RNA families, a context-sensitive embedding representation is obtained. As a result, not only base information but also secondary structure and context information of RNA sequences are embedded for each base. We call this \u2018informative base embedding\u2019 and use it to achieve accuracies superior to those of existing state-of-the-art methods on RNA structural alignment and RNA family clustering tasks. Furthermore, upon performing RNA sequence alignment by combining this informative base embedding with a simple Needleman\u2013Wunsch alignment algorithm, we succeed in calculating structural alignments with a time complexity of O(n2) instead of the O(n6) time complexity of the naive implementation of Sankoff-style algorithm for input RNA sequence of length n.}\",\n    issn = {2631-9268},\n    doi = {10.1093/nargab/lqac012},\n    url = {https://doi.org/10.1093/nargab/lqac012},\n    eprint = {https://academic.oup.com/nargab/article-pdf/4/1/lqac012/42577168/lqac012.pdf},\n}\n</code></pre>"},{"location":"models/rnabert/#contact","title":"Contact","text":"<p>Please use GitHub issues of MultiMolecule for any questions or comments on the model card.</p> <p>Please contact the authors of the RNABERT paper for questions or comments on the paper/model.</p>"},{"location":"models/rnabert/#license","title":"License","text":"<p>This model is licensed under the AGPL-3.0 License.</p> Text Only<pre><code>SPDX-License-Identifier: AGPL-3.0-or-later\n</code></pre>"},{"location":"models/rnabert/#multimolecule.models.rnabert","title":"<code>multimolecule.models.rnabert</code>","text":""},{"location":"models/rnabert/#multimolecule.models.rnabert.RnaTokenizer","title":"<code>RnaTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>Constructs an RNA tokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>alphabet</code> <code>List[str] | None</code> <p>List of tokens to use. Defaults to IUPAC nucleotide code.</p> <code>None</code> <code>nmers</code> <code>int</code> <p>Size of nmers to tokenize. Defaults to 1.</p> <code>1</code> <code>codon</code> <code>bool</code> <p>Whether to tokenize into codons. Defaults to False.</p> <code>False</code> <code>replace_T_with_U</code> <code>bool</code> <p>Whether to replace T with U. Defaults to True.</p> <code>True</code> <code>do_upper_case</code> <code>bool</code> <p>Whether to convert input to uppercase. Defaults to True.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaTokenizer\n&gt;&gt;&gt; tokenizer = RnaTokenizer()\n&gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n[1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n&gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 3, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 17, 64, 49, 96, 84, 22, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 49, 22, 2]\n&gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\nTraceback (most recent call last):\nValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n</code></pre> Source code in <code>multimolecule/tokenisers/rna/tokenization_rna.py</code> Python<pre><code>class RnaTokenizer(Tokenizer):\n    \"\"\"\n    Constructs an RNA tokenizer.\n\n    Args:\n        alphabet (List[str] | None, optional): List of tokens to use.\n            Defaults to [IUPAC nucleotide code](https://www.bioinformatics.org/sms2/iupac.html).\n        nmers (int, optional): Size of nmers to tokenize.\n            Defaults to 1.\n        codon (bool, optional): Whether to tokenize into codons.\n            Defaults to False.\n        replace_T_with_U (bool, optional): Whether to replace T with U.\n            Defaults to True.\n        do_upper_case (bool, optional): Whether to convert input to uppercase.\n            Defaults to True.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaTokenizer\n        &gt;&gt;&gt; tokenizer = RnaTokenizer()\n        &gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n        [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n        &gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 3, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 17, 64, 49, 96, 84, 22, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 49, 22, 2]\n        &gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\n        Traceback (most recent call last):\n        ValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n    \"\"\"\n\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n\n    def __init__(\n        self,\n        alphabet: List[str] | None = None,\n        nmers: int = 1,\n        codon: bool = False,\n        replace_T_with_U: bool = True,\n        bos_token: str = \"&lt;cls&gt;\",\n        cls_token: str = \"&lt;cls&gt;\",\n        pad_token: str = \"&lt;pad&gt;\",\n        eos_token: str = \"&lt;eos&gt;\",\n        sep_token: str = \"&lt;eos&gt;\",\n        unk_token: str = \"&lt;unk&gt;\",\n        mask_token: str = \"&lt;mask&gt;\",\n        additional_special_tokens: List | Tuple | None = None,\n        do_upper_case: bool = True,\n        **kwargs,\n    ):\n        if codon and nmers &gt; 1:\n            raise ValueError(\"Codon and nmers cannot be used together.\")\n        if codon:\n            nmers = 3  # set to 3 to get correct vocab\n        super().__init__(\n            alphabet=get_vocab_list(alphabet, nmers),\n            bos_token=bos_token,\n            cls_token=cls_token,\n            pad_token=pad_token,\n            eos_token=eos_token,\n            sep_token=sep_token,\n            unk_token=unk_token,\n            mask_token=mask_token,\n            additional_special_tokens=additional_special_tokens,\n            do_upper_case=do_upper_case,\n            **kwargs,\n        )\n        self.replace_T_with_U = replace_T_with_U\n        self.nmers = nmers\n        self.condon = codon\n\n    def _tokenize(self, text: str, **kwargs):\n        if self.do_upper_case:\n            text = text.upper()\n        if self.replace_T_with_U:\n            text = text.replace(\"T\", \"U\")\n        if self.condon:\n            if len(text) % 3 != 0:\n                raise ValueError(\n                    f\"length of input sequence  must be a multiple of 3 for codon tokenization, but got {len(text)}\"\n                )\n            return [text[i : i + 3] for i in range(0, len(text), 3)]\n        if self.nmers &gt; 1:\n            return [text[i : i + self.nmers] for i in range(len(text) - self.nmers + 1)]  # noqa: E203\n        return list(text)\n</code></pre>"},{"location":"models/rnabert/#multimolecule.models.rnabert.RnaBertConfig","title":"<code>RnaBertConfig</code>","text":"<p>               Bases: <code>PreTrainedConfig</code></p> <p>This is the configuration class to store the configuration of a [<code>RnaBertModel</code>]. It is used to instantiate a RnaBert model according to the specified arguments, defining the model architecture. Instantiating a configuration with the defaults will yield a similar configuration to that of the RnaBert mana438/RNABERT architecture.</p> <p>Configuration objects inherit from [<code>PreTrainedConfig</code>] and can be used to control the model outputs. Read the documentation from [<code>PreTrainedConfig</code>] for more information.</p> <p>Parameters:</p> Name Type Description Default <code>vocab_size</code> <code>`int`, *optional*, defaults to 26</code> <p>Vocabulary size of the RnaBert model. Defines the number of different tokens that can be represented by the <code>inputs_ids</code> passed when calling [<code>RnaBertModel</code>].</p> <code>26</code> <code>hidden_size</code> <code>`int`, *optional*, defaults to 120</code> <p>Dimensionality of the encoder layers and the pooler layer.</p> <code>None</code> <code>num_hidden_layers</code> <code>`int`, *optional*, defaults to 12</code> <p>Number of hidden layers in the Transformer encoder.</p> <code>6</code> <code>num_attention_heads</code> <code>`int`, *optional*, defaults to 6</code> <p>Number of attention heads for each attention layer in the Transformer encoder.</p> <code>12</code> <code>intermediate_size</code> <code>`int`, *optional*, defaults to 40</code> <p>Dimensionality of the \u201cintermediate\u201d (often named feed-forward) layer in the Transformer encoder.</p> <code>40</code> <code>hidden_dropout</code> <code>`float`, *optional*, defaults to 0.0</code> <p>The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.</p> <code>0.0</code> <code>attention_dropout</code> <code>`float`, *optional*, defaults to 0.0</code> <p>The dropout ratio for the attention probabilities.</p> <code>0.0</code> <code>max_position_embeddings</code> <code>`int`, *optional*, defaults to 440</code> <p>The maximum sequence length that this model might ever be used with. Typically set this to something large just in case (e.g., 512 or 1024 or 2048).</p> <code>440</code> <code>initializer_range</code> <code>`float`, *optional*, defaults to 0.02</code> <p>The standard deviation of the truncated_normal_initializer for initializing all weight matrices.</p> <code>0.02</code> <code>layer_norm_eps</code> <code>`float`, *optional*, defaults to 1e-12</code> <p>The epsilon used by the layer normalization layers.</p> <code>1e-12</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaBertModel, RnaBertConfig\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a RNABERT multimolecule/rnabert style configuration\n&gt;&gt;&gt; configuration = RnaBertConfig()\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/rnabert style configuration\n&gt;&gt;&gt; model = RnaBertModel(configuration)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Accessing the model configuration\n&gt;&gt;&gt; configuration = model.config\n</code></pre> Source code in <code>multimolecule/models/rnabert/configuration_rnabert.py</code> Python<pre><code>class RnaBertConfig(PreTrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`RnaBertModel`]. It is used to instantiate a\n    RnaBert model according to the specified arguments, defining the model architecture. Instantiating a configuration\n    with the defaults will yield a similar configuration to that of the RnaBert\n    [mana438/RNABERT](https://github.com/mana438/RNABERT) architecture.\n\n    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n    documentation from [`PreTrainedConfig`] for more information.\n\n\n    Args:\n        vocab_size (`int`, *optional*, defaults to 26):\n            Vocabulary size of the RnaBert model. Defines the number of different tokens that can be represented by the\n            `inputs_ids` passed when calling [`RnaBertModel`].\n        hidden_size (`int`, *optional*, defaults to 120):\n            Dimensionality of the encoder layers and the pooler layer.\n        num_hidden_layers (`int`, *optional*, defaults to 12):\n            Number of hidden layers in the Transformer encoder.\n        num_attention_heads (`int`, *optional*, defaults to 6):\n            Number of attention heads for each attention layer in the Transformer encoder.\n        intermediate_size (`int`, *optional*, defaults to 40):\n            Dimensionality of the \"intermediate\" (often named feed-forward) layer in the Transformer encoder.\n        hidden_dropout (`float`, *optional*, defaults to 0.0):\n            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n        attention_dropout (`float`, *optional*, defaults to 0.0):\n            The dropout ratio for the attention probabilities.\n        max_position_embeddings (`int`, *optional*, defaults to 440):\n            The maximum sequence length that this model might ever be used with. Typically set this to something large\n            just in case (e.g., 512 or 1024 or 2048).\n        initializer_range (`float`, *optional*, defaults to 0.02):\n            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n        layer_norm_eps (`float`, *optional*, defaults to 1e-12):\n            The epsilon used by the layer normalization layers.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaBertModel, RnaBertConfig\n\n        &gt;&gt;&gt; # Initializing a RNABERT multimolecule/rnabert style configuration\n        &gt;&gt;&gt; configuration = RnaBertConfig()\n\n        &gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/rnabert style configuration\n        &gt;&gt;&gt; model = RnaBertModel(configuration)\n\n        &gt;&gt;&gt; # Accessing the model configuration\n        &gt;&gt;&gt; configuration = model.config\n    \"\"\"\n\n    model_type = \"rnabert\"\n\n    def __init__(\n        self,\n        vocab_size=26,\n        ss_vocab_size=8,\n        hidden_size=None,\n        multiple=None,\n        num_hidden_layers=6,\n        num_attention_heads=12,\n        intermediate_size=40,\n        hidden_act=\"gelu\",\n        hidden_dropout=0.0,\n        attention_dropout=0.0,\n        max_position_embeddings=440,\n        initializer_range=0.02,\n        layer_norm_eps=1e-12,\n        position_embedding_type=\"absolute\",\n        use_cache=True,\n        head=None,\n        lm_head=None,\n        **kwargs,\n    ):\n        if hidden_size is None:\n            hidden_size = num_attention_heads * multiple if multiple is not None else 120\n        super().__init__(**kwargs)\n\n        self.vocab_size = vocab_size\n        self.ss_vocab_size = ss_vocab_size\n        self.type_vocab_size = 2\n        self.hidden_size = hidden_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_attention_heads = num_attention_heads\n        self.intermediate_size = intermediate_size\n        self.hidden_act = hidden_act\n        self.hidden_dropout = hidden_dropout\n        self.attention_dropout = attention_dropout\n        self.max_position_embeddings = max_position_embeddings\n        self.initializer_range = initializer_range\n        self.layer_norm_eps = layer_norm_eps\n        self.position_embedding_type = position_embedding_type\n        self.use_cache = use_cache\n        self.head = HeadConfig(**head if head is not None else {})\n        self.lm_head = MaskedLMHeadConfig(**lm_head if lm_head is not None else {})\n</code></pre>"},{"location":"models/rnabert/#multimolecule.models.rnabert.RnaBertForMaskedLM","title":"<code>RnaBertForMaskedLM</code>","text":"<p>               Bases: <code>RnaBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaBertConfig, RnaBertForMaskedLM, RnaTokenizer\n&gt;&gt;&gt; config = RnaBertConfig()\n&gt;&gt;&gt; model = RnaBertForMaskedLM(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 26])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/rnabert/modeling_rnabert.py</code> Python<pre><code>class RnaBertForMaskedLM(RnaBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaBertConfig, RnaBertForMaskedLM, RnaTokenizer\n        &gt;&gt;&gt; config = RnaBertConfig()\n        &gt;&gt;&gt; model = RnaBertForMaskedLM(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 26])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: RnaBertConfig):\n        super().__init__(config)\n        self.rnabert = RnaBertModel(config, add_pooling_layer=False)\n        self.lm_head = MaskedLMHead(config)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool = False,\n        output_hidden_states: bool = False,\n        return_dict: bool = True,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | MaskedLMOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rnabert(\n            input_ids,\n            attention_mask,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.lm_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return MaskedLMOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/rnabert/#multimolecule.models.rnabert.RnaBertForNucleotidePrediction","title":"<code>RnaBertForNucleotidePrediction</code>","text":"<p>               Bases: <code>RnaBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaBertConfig, RnaBertForNucleotidePrediction, RnaTokenizer\n&gt;&gt;&gt; config = RnaBertConfig()\n&gt;&gt;&gt; model = RnaBertForNucleotidePrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 5, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/rnabert/modeling_rnabert.py</code> Python<pre><code>class RnaBertForNucleotidePrediction(RnaBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaBertConfig, RnaBertForNucleotidePrediction, RnaTokenizer\n        &gt;&gt;&gt; config = RnaBertConfig()\n        &gt;&gt;&gt; model = RnaBertForNucleotidePrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 5, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: RnaBertConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.rnabert = RnaBertModel(config, add_pooling_layer=True)\n        self.nucleotide_head = NucleotidePredictionHead(config)\n        self.head_config = self.nucleotide_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | NucleotidePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rnabert(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.nucleotide_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return NucleotidePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/rnabert/#multimolecule.models.rnabert.RnaBertForPreTraining","title":"<code>RnaBertForPreTraining</code>","text":"<p>               Bases: <code>RnaBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaBertConfig, RnaBertForPreTraining, RnaTokenizer\n&gt;&gt;&gt; config = RnaBertConfig()\n&gt;&gt;&gt; model = RnaBertForPreTraining(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels_mlm=input[\"input_ids\"])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;AddBackward0&gt;)\n&gt;&gt;&gt; output[\"logits_mlm\"].shape\ntorch.Size([1, 7, 26])\n&gt;&gt;&gt; output[\"logits_ss\"].shape\ntorch.Size([1, 7, 8])\n&gt;&gt;&gt; output[\"logits_sal\"].shape\ntorch.Size([1, 2])\n</code></pre> Source code in <code>multimolecule/models/rnabert/modeling_rnabert.py</code> Python<pre><code>class RnaBertForPreTraining(RnaBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaBertConfig, RnaBertForPreTraining, RnaTokenizer\n        &gt;&gt;&gt; config = RnaBertConfig()\n        &gt;&gt;&gt; model = RnaBertForPreTraining(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels_mlm=input[\"input_ids\"])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;AddBackward0&gt;)\n        &gt;&gt;&gt; output[\"logits_mlm\"].shape\n        torch.Size([1, 7, 26])\n        &gt;&gt;&gt; output[\"logits_ss\"].shape\n        torch.Size([1, 7, 8])\n        &gt;&gt;&gt; output[\"logits_sal\"].shape\n        torch.Size([1, 2])\n    \"\"\"\n\n    def __init__(self, config: RnaBertConfig):\n        super().__init__(config)\n        self.rnabert = RnaBertModel(config, add_pooling_layer=True)\n        self.pretrain_head = RnaBertPreTrainingHeads(config)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        labels_mlm: Tensor | None = None,\n        labels_ss: Tensor | None = None,\n        labels_sal: Tensor | None = None,\n        output_attentions: bool = False,\n        output_hidden_states: bool = False,\n        return_dict: bool = True,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | RnaBertForPreTrainingOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rnabert(\n            input_ids,\n            attention_mask,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        total_loss, logits_mlm, logits_ss, logits_sal = self.pretrain_head(\n            outputs, labels_mlm=labels_mlm, labels_ss=labels_ss, labels_sal=labels_sal\n        )\n\n        if not return_dict:\n            output = (logits_mlm, logits_ss, logits_sal) + outputs[2:]\n            return ((total_loss,) + output) if total_loss is not None else output\n\n        return RnaBertForPreTrainingOutput(\n            loss=total_loss,\n            logits_mlm=logits_mlm,\n            logits_ss=logits_ss,\n            logits_sal=logits_sal,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/rnabert/#multimolecule.models.rnabert.RnaBertForSequencePrediction","title":"<code>RnaBertForSequencePrediction</code>","text":"<p>               Bases: <code>RnaBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaBertConfig, RnaBertForSequencePrediction, RnaTokenizer\n&gt;&gt;&gt; config = RnaBertConfig()\n&gt;&gt;&gt; model = RnaBertForSequencePrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.tensor([[1]]))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/rnabert/modeling_rnabert.py</code> Python<pre><code>class RnaBertForSequencePrediction(RnaBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaBertConfig, RnaBertForSequencePrediction, RnaTokenizer\n        &gt;&gt;&gt; config = RnaBertConfig()\n        &gt;&gt;&gt; model = RnaBertForSequencePrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.tensor([[1]]))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: RnaBertConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.rnabert = RnaBertModel(config, add_pooling_layer=True)\n        self.sequence_head = SequencePredictionHead(config)\n        self.head_config = self.sequence_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | SequencePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rnabert(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.sequence_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return SequencePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/rnabert/#multimolecule.models.rnabert.RnaBertForTokenPrediction","title":"<code>RnaBertForTokenPrediction</code>","text":"<p>               Bases: <code>RnaBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaBertConfig, RnaBertForTokenPrediction, RnaTokenizer\n&gt;&gt;&gt; config = RnaBertConfig()\n&gt;&gt;&gt; model = RnaBertForTokenPrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/rnabert/modeling_rnabert.py</code> Python<pre><code>class RnaBertForTokenPrediction(RnaBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaBertConfig, RnaBertForTokenPrediction, RnaTokenizer\n        &gt;&gt;&gt; config = RnaBertConfig()\n        &gt;&gt;&gt; model = RnaBertForTokenPrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: RnaBertConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.rnabert = RnaBertModel(config, add_pooling_layer=True)\n        self.token_head = TokenPredictionHead(config)\n        self.head_config = self.token_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | TokenPredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rnabert(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.token_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return TokenPredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/rnabert/#multimolecule.models.rnabert.RnaBertModel","title":"<code>RnaBertModel</code>","text":"<p>               Bases: <code>RnaBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaBertConfig, RnaBertModel, RnaTokenizer\n&gt;&gt;&gt; config = RnaBertConfig()\n&gt;&gt;&gt; model = RnaBertModel(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input)\n&gt;&gt;&gt; output[\"last_hidden_state\"].shape\ntorch.Size([1, 7, 120])\n&gt;&gt;&gt; output[\"pooler_output\"].shape\ntorch.Size([1, 120])\n</code></pre> Source code in <code>multimolecule/models/rnabert/modeling_rnabert.py</code> Python<pre><code>class RnaBertModel(RnaBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaBertConfig, RnaBertModel, RnaTokenizer\n        &gt;&gt;&gt; config = RnaBertConfig()\n        &gt;&gt;&gt; model = RnaBertModel(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input)\n        &gt;&gt;&gt; output[\"last_hidden_state\"].shape\n        torch.Size([1, 7, 120])\n        &gt;&gt;&gt; output[\"pooler_output\"].shape\n        torch.Size([1, 120])\n    \"\"\"\n\n    def __init__(self, config: RnaBertConfig, add_pooling_layer: bool = True):\n        super().__init__(config)\n        self.pad_token_id = config.pad_token_id\n        self.embeddings = RnaBertEmbeddings(config)\n        self.encoder = RnaBertEncoder(config)\n        self.pooler = RnaBertPooler(config) if add_pooling_layer else None\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.embeddings.word_embeddings\n\n    def set_input_embeddings(self, value):\n        self.embeddings.word_embeddings = value\n\n    def _prune_heads(self, heads_to_prune):\n        \"\"\"\n        Prunes heads of the model. heads_to_prune: dict of {layer_num: list of heads to prune in this layer} See base\n        class PreTrainedModel\n        \"\"\"\n        for layer, heads in heads_to_prune.items():\n            self.encoder.layer[layer].attention.prune_heads(heads)\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        past_key_values: Tuple[Tuple[torch.FloatTensor, torch.FloatTensor], ...] | None = None,\n        use_cache: bool | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | BaseModelOutputWithPoolingAndCrossAttentions:\n        r\"\"\"\n        encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n            Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n            the model is configured as a decoder.\n        encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n            the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n            - 1 for tokens that are **not masked**,\n            - 0 for tokens that are **masked**.\n        past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors\n            of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n            Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n        use_cache (`bool`, *optional*):\n            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n            `past_key_values`).\n        \"\"\"\n        if kwargs:\n            warn(\n                f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n                f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n                \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n            )\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        if self.config.is_decoder:\n            use_cache = use_cache if use_cache is not None else self.config.use_cache\n        else:\n            use_cache = False\n\n        if isinstance(input_ids, NestedTensor):\n            input_ids, attention_mask = input_ids.tensor, input_ids.mask\n        if input_ids is not None and inputs_embeds is not None:\n            raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n        if input_ids is not None:\n            self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n            input_shape = input_ids.size()\n        elif inputs_embeds is not None:\n            input_shape = inputs_embeds.size()[:-1]\n        else:\n            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n        batch_size, seq_length = input_shape\n        device = input_ids.device if input_ids is not None else inputs_embeds.device  # type: ignore[union-attr]\n\n        # past_key_values_length\n        past_key_values_length = past_key_values[0][0].shape[2] if past_key_values is not None else 0\n\n        if attention_mask is None:\n            attention_mask = (\n                input_ids.ne(self.pad_token_id)\n                if self.pad_token_id is not None\n                else torch.ones(((batch_size, seq_length + past_key_values_length)), device=device)\n            )\n\n        # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n        # ourselves in which case we just need to make it broadcastable to all heads.\n        extended_attention_mask: Tensor = self.get_extended_attention_mask(attention_mask, input_shape)\n\n        # If a 2D or 3D attention mask is provided for the cross-attention\n        # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n        if self.config.is_decoder and encoder_hidden_states is not None:\n            encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n            encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n            if encoder_attention_mask is None:\n                encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n            encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n        else:\n            encoder_extended_attention_mask = None\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n        head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n        embedding_output = self.embeddings(\n            input_ids=input_ids,\n            position_ids=position_ids,\n            inputs_embeds=inputs_embeds,\n            past_key_values_length=past_key_values_length,\n        )\n        encoder_outputs = self.encoder(\n            embedding_output,\n            attention_mask=extended_attention_mask,\n            head_mask=head_mask,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_extended_attention_mask,\n            past_key_values=past_key_values,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n        sequence_output = encoder_outputs[0]\n        pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n        if not return_dict:\n            return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n        return BaseModelOutputWithPoolingAndCrossAttentions(\n            last_hidden_state=sequence_output,\n            pooler_output=pooled_output,\n            past_key_values=encoder_outputs.past_key_values,\n            hidden_states=encoder_outputs.hidden_states,\n            attentions=encoder_outputs.attentions,\n            cross_attentions=encoder_outputs.cross_attentions,\n        )\n</code></pre>"},{"location":"models/rnabert/#multimolecule.models.rnabert.RnaBertModel.forward","title":"<code>forward(input_ids, attention_mask=None, position_ids=None, head_mask=None, inputs_embeds=None, encoder_hidden_states=None, encoder_attention_mask=None, past_key_values=None, use_cache=None, output_attentions=None, output_hidden_states=None, return_dict=None, **kwargs)</code>","text":"<p>encoder_hidden_states  (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, optional):     Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if     the model is configured as a decoder. encoder_attention_mask (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, optional):     Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in     the cross-attention if the model is configured as a decoder. Mask values selected in <code>[0, 1]</code>:</p> Text Only<pre><code>- 1 for tokens that are **not masked**,\n- 0 for tokens that are **masked**.\n</code></pre> <p>past_key_values (<code>tuple(tuple(torch.FloatTensor))</code> of length <code>config.n_layers</code> with each tuple having 4 tensors     of shape <code>(batch_size, num_heads, sequence_length - 1, embed_size_per_head)</code>):     Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.</p> Text Only<pre><code>If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\ndon't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n`decoder_input_ids` of shape `(batch_size, sequence_length)`.\n</code></pre> <p>use_cache (<code>bool</code>, optional):     If set to <code>True</code>, <code>past_key_values</code> key value states are returned and can be used to speed up decoding (see     <code>past_key_values</code>).</p> Source code in <code>multimolecule/models/rnabert/modeling_rnabert.py</code> Python<pre><code>def forward(\n    self,\n    input_ids: Tensor | NestedTensor,\n    attention_mask: Tensor | None = None,\n    position_ids: Tensor | None = None,\n    head_mask: Tensor | None = None,\n    inputs_embeds: Tensor | NestedTensor | None = None,\n    encoder_hidden_states: Tensor | None = None,\n    encoder_attention_mask: Tensor | None = None,\n    past_key_values: Tuple[Tuple[torch.FloatTensor, torch.FloatTensor], ...] | None = None,\n    use_cache: bool | None = None,\n    output_attentions: bool | None = None,\n    output_hidden_states: bool | None = None,\n    return_dict: bool | None = None,\n    **kwargs,\n) -&gt; Tuple[Tensor, ...] | BaseModelOutputWithPoolingAndCrossAttentions:\n    r\"\"\"\n    encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n        Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n        the model is configured as a decoder.\n    encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n        Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n        the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n        - 1 for tokens that are **not masked**,\n        - 0 for tokens that are **masked**.\n    past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors\n        of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n        Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n        If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n        don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n        `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n    use_cache (`bool`, *optional*):\n        If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n        `past_key_values`).\n    \"\"\"\n    if kwargs:\n        warn(\n            f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n            f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n            \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n        )\n    output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n    output_hidden_states = (\n        output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n    )\n    return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n    if self.config.is_decoder:\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n    else:\n        use_cache = False\n\n    if isinstance(input_ids, NestedTensor):\n        input_ids, attention_mask = input_ids.tensor, input_ids.mask\n    if input_ids is not None and inputs_embeds is not None:\n        raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n    if input_ids is not None:\n        self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n        input_shape = input_ids.size()\n    elif inputs_embeds is not None:\n        input_shape = inputs_embeds.size()[:-1]\n    else:\n        raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n    batch_size, seq_length = input_shape\n    device = input_ids.device if input_ids is not None else inputs_embeds.device  # type: ignore[union-attr]\n\n    # past_key_values_length\n    past_key_values_length = past_key_values[0][0].shape[2] if past_key_values is not None else 0\n\n    if attention_mask is None:\n        attention_mask = (\n            input_ids.ne(self.pad_token_id)\n            if self.pad_token_id is not None\n            else torch.ones(((batch_size, seq_length + past_key_values_length)), device=device)\n        )\n\n    # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n    # ourselves in which case we just need to make it broadcastable to all heads.\n    extended_attention_mask: Tensor = self.get_extended_attention_mask(attention_mask, input_shape)\n\n    # If a 2D or 3D attention mask is provided for the cross-attention\n    # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n    if self.config.is_decoder and encoder_hidden_states is not None:\n        encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n        encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n        if encoder_attention_mask is None:\n            encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n        encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n    else:\n        encoder_extended_attention_mask = None\n\n    # Prepare head mask if needed\n    # 1.0 in head_mask indicate we keep the head\n    # attention_probs has shape bsz x n_heads x N x N\n    # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n    # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n    head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n    embedding_output = self.embeddings(\n        input_ids=input_ids,\n        position_ids=position_ids,\n        inputs_embeds=inputs_embeds,\n        past_key_values_length=past_key_values_length,\n    )\n    encoder_outputs = self.encoder(\n        embedding_output,\n        attention_mask=extended_attention_mask,\n        head_mask=head_mask,\n        encoder_hidden_states=encoder_hidden_states,\n        encoder_attention_mask=encoder_extended_attention_mask,\n        past_key_values=past_key_values,\n        use_cache=use_cache,\n        output_attentions=output_attentions,\n        output_hidden_states=output_hidden_states,\n        return_dict=return_dict,\n    )\n    sequence_output = encoder_outputs[0]\n    pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n    if not return_dict:\n        return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n    return BaseModelOutputWithPoolingAndCrossAttentions(\n        last_hidden_state=sequence_output,\n        pooler_output=pooled_output,\n        past_key_values=encoder_outputs.past_key_values,\n        hidden_states=encoder_outputs.hidden_states,\n        attentions=encoder_outputs.attentions,\n        cross_attentions=encoder_outputs.cross_attentions,\n    )\n</code></pre>"},{"location":"models/rnabert/#multimolecule.models.rnabert.RnaBertPreTrainedModel","title":"<code>RnaBertPreTrainedModel</code>","text":"<p>               Bases: <code>PreTrainedModel</code></p> <p>An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained models.</p> Source code in <code>multimolecule/models/rnabert/modeling_rnabert.py</code> Python<pre><code>class RnaBertPreTrainedModel(PreTrainedModel):\n    \"\"\"\n    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n    models.\n    \"\"\"\n\n    config_class = RnaBertConfig\n    base_model_prefix = \"rnabert\"\n    supports_gradient_checkpointing = True\n    _no_split_modules = [\"RnaBertLayer\", \"RnaBertEmbeddings\"]\n\n    # Copied from transformers.models.bert.modeling_bert.BertPreTrainedModel._init_weights\n    def _init_weights(self, module: nn.Module):\n        \"\"\"Initialize the weights\"\"\"\n        if isinstance(module, nn.Linear):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, nn.Embedding):\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.padding_idx is not None:\n                module.weight.data[module.padding_idx].zero_()\n        elif isinstance(module, nn.LayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n</code></pre>"},{"location":"models/rnafm/","title":"RNA-FM","text":"<p>Pre-trained model on non-coding RNA (ncRNA) and mRNA CoDing Sequence (CDS) using a masked language modeling (MLM) objective.</p>"},{"location":"models/rnafm/#disclaimer","title":"Disclaimer","text":"<p>This is an UNOFFICIAL implementation of the Interpretable RNA Foundation Model from Unannotated Data for Highly Accurate RNA Structure and Function Predictions by Jiayang Chen, Zhihang Hue, Siqi Sun, et al.</p> <p>The OFFICIAL repository of RNA-FM is at ml4bio/RNA-FM.</p> <p>The team releasing RNA-FM did not write this model card for this model so this model card has been written by the MultiMolecule team.</p>"},{"location":"models/rnafm/#model-details","title":"Model Details","text":"<p>RNA-FM is a bert-style model pre-trained on a large corpus of non-coding RNA sequences in a self-supervised fashion. This means that the model was trained on the raw nucleotides of RNA sequences only, with an automatic process to generate inputs and labels from those texts. Please refer to the Training Details section for more information on the training process.</p>"},{"location":"models/rnafm/#variations","title":"Variations","text":"<ul> <li><code>multimolecule/rnafm</code>: The RNA-FM model pre-trained on non-coding RNA sequences.</li> <li><code>multimolecule/mrnafm</code>: The RNA-FM model pre-trained on mRNA coding sequences.</li> </ul>"},{"location":"models/rnafm/#model-specification","title":"Model Specification","text":"Variants Num Layers Hidden Size Num Heads Intermediate Size Num Parameters (M) FLOPs (G) MACs (G) Max Num Tokens RNA-FM 12 640 20 5120 99.52 25.68 12.83 1024 mRNA-FM 1280 239.25 61.43 30.7"},{"location":"models/rnafm/#links","title":"Links","text":"<ul> <li>Code: multimolecule.rnafm</li> <li>Data: RNAcentral</li> <li>Paper: Interpretable RNA Foundation Model from Unannotated Data for Highly Accurate RNA Structure and Function Predictions</li> <li>Developed by: Jiayang Chen, Zhihang Hu, Siqi Sun, Qingxiong Tan, Yixuan Wang, Qinze Yu, Licheng Zong, Liang Hong, Jin Xiao, Tao Shen, Irwin King, Yu Li</li> <li>Model type: BERT - ESM</li> <li>Original Repository: https://github.com/ml4bio/RNA-FM</li> </ul>"},{"location":"models/rnafm/#usage","title":"Usage","text":"<p>The model file depends on the <code>multimolecule</code> library. You can install it using pip:</p> Bash<pre><code>pip install multimolecule\n</code></pre>"},{"location":"models/rnafm/#direct-use","title":"Direct Use","text":"<p>You can use this model directly with a pipeline for masked language modeling:</p> Python<pre><code>&gt;&gt;&gt; import multimolecule  # you must import multimolecule to register models\n&gt;&gt;&gt; from transformers import pipeline\n&gt;&gt;&gt; unmasker = pipeline('fill-mask', model='multimolecule/rnafm')\n&gt;&gt;&gt; unmasker(\"uagc&lt;mask&gt;uaucagacugauguuga\")\n\n[{'score': 0.32435303926467896,\n  'token': 24,\n  'token_str': '*',\n  'sequence': 'U A G C * U A U C A G A C U G A U G U U G A'},\n {'score': 0.28287413716316223,\n  'token': 11,\n  'token_str': 'I',\n  'sequence': 'U A G C I U A U C A G A C U G A U G U U G A'},\n {'score': 0.11811278015375137,\n  'token': 23,\n  'token_str': '.',\n  'sequence': 'U A G C. U A U C A G A C U G A U G U U G A'},\n {'score': 0.08698639273643494,\n  'token': 6,\n  'token_str': 'A',\n  'sequence': 'U A G C A U A U C A G A C U G A U G U U G A'},\n {'score': 0.06751123070716858,\n  'token': 9,\n  'token_str': 'U',\n  'sequence': 'U A G C U U A U C A G A C U G A U G U U G A'}]\n</code></pre>"},{"location":"models/rnafm/#downstream-use","title":"Downstream Use","text":""},{"location":"models/rnafm/#extract-features","title":"Extract Features","text":"<p>Here is how to use this model to get the features of a given sequence in PyTorch:</p> Python<pre><code>from multimolecule import RnaTokenizer, RnaFmModel\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/rnafm')\nmodel = RnaFmModel.from_pretrained('multimolecule/rnafm')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\n\noutput = model(**input)\n</code></pre>"},{"location":"models/rnafm/#sequence-classification-regression","title":"Sequence Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for sequence classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a sequence-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, RnaFmForSequencePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/rnafm')\nmodel = RnaFmForSequencePrediction.from_pretrained('multimolecule/rnafm')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.tensor([1])\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/rnafm/#nucleotide-classification-regression","title":"Nucleotide Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for nucleotide classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a nucleotide-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, RnaFmForNucleotidePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/rnafm')\nmodel = RnaFmForNucleotidePrediction.from_pretrained('multimolecule/rnafm')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.randint(2, (len(text), ))\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/rnafm/#training-details","title":"Training Details","text":"<p>RNA-FM used Masked Language Modeling (MLM) as the pre-training objective: taking a sequence, the model randomly masks 15% of the tokens in the input then runs the entire masked sentence through the model and has to predict the masked tokens. This is comparable to the Cloze task in language modeling.</p>"},{"location":"models/rnafm/#training-data","title":"Training Data","text":"<p>The RNA-FM model was pre-trained on RNAcentral. RNAcentral is a comprehensive database of non-coding RNA sequences from a wide range of species. It combines 47 different databases, adding up to around 27 million RNA sequences in total.</p> <p>RNA-FM applied CD-HIT (CD-HIT-EST) with a cut-off at 100% sequence identity to remove redundancy from the RNAcentral. The final dataset contains 23.7 million non-redundant RNA sequences.</p> <p>RNA-FM preprocessed all tokens by replacing \u201cU\u201ds with \u201cT\u201ds.</p> <p>Note that during model conversions, \u201cT\u201d is replaced with \u201cU\u201d. <code>RnaTokenizer</code> will convert \u201cT\u201ds to \u201cU\u201ds for you, you may disable this behaviour by passing <code>replace_T_with_U=False</code>.</p>"},{"location":"models/rnafm/#training-procedure","title":"Training Procedure","text":""},{"location":"models/rnafm/#preprocessing","title":"Preprocessing","text":"<p>RNA-FM used masked language modeling (MLM) as the pre-training objective. The masking procedure is similar to the one used in BERT:</p> <ul> <li>15% of the tokens are masked.</li> <li>In 80% of the cases, the masked tokens are replaced by <code>&lt;mask&gt;</code>.</li> <li>In 10% of the cases, the masked tokens are replaced by a random token (different) from the one they replace.</li> <li>In the 10% remaining cases, the masked tokens are left as is.</li> </ul>"},{"location":"models/rnafm/#pretraining","title":"PreTraining","text":"<p>The model was trained on 8 NVIDIA A100 GPUs with 80GiB memories.</p> <ul> <li>Learning rate: 1e-4</li> <li>Weight decay: 0.01</li> <li>Learning rate scheduler: inverse square root</li> <li>Learning rate warm-up: 10,000 steps</li> </ul>"},{"location":"models/rnafm/#citation","title":"Citation","text":"<p>BibTeX:</p> BibTeX<pre><code>@article{chen2022interpretable,\n  title={Interpretable rna foundation model from unannotated data for highly accurate rna structure and function predictions},\n  author={Chen, Jiayang and Hu, Zhihang and Sun, Siqi and Tan, Qingxiong and Wang, Yixuan and Yu, Qinze and Zong, Licheng and Hong, Liang and Xiao, Jin and King, Irwin and others},\n  journal={arXiv preprint arXiv:2204.00300},\n  year={2022}\n}\n</code></pre>"},{"location":"models/rnafm/#contact","title":"Contact","text":"<p>Please use GitHub issues of MultiMolecule for any questions or comments on the model card.</p> <p>Please contact the authors of the RNA-FM paper for questions or comments on the paper/model.</p>"},{"location":"models/rnafm/#license","title":"License","text":"<p>This model is licensed under the AGPL-3.0 License.</p> Text Only<pre><code>SPDX-License-Identifier: AGPL-3.0-or-later\n</code></pre>"},{"location":"models/rnafm/#multimolecule.models.rnafm","title":"<code>multimolecule.models.rnafm</code>","text":""},{"location":"models/rnafm/#multimolecule.models.rnafm.RnaTokenizer","title":"<code>RnaTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>Constructs an RNA tokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>alphabet</code> <code>List[str] | None</code> <p>List of tokens to use. Defaults to IUPAC nucleotide code.</p> <code>None</code> <code>nmers</code> <code>int</code> <p>Size of nmers to tokenize. Defaults to 1.</p> <code>1</code> <code>codon</code> <code>bool</code> <p>Whether to tokenize into codons. Defaults to False.</p> <code>False</code> <code>replace_T_with_U</code> <code>bool</code> <p>Whether to replace T with U. Defaults to True.</p> <code>True</code> <code>do_upper_case</code> <code>bool</code> <p>Whether to convert input to uppercase. Defaults to True.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaTokenizer\n&gt;&gt;&gt; tokenizer = RnaTokenizer()\n&gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n[1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n&gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 3, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 17, 64, 49, 96, 84, 22, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 49, 22, 2]\n&gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\nTraceback (most recent call last):\nValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n</code></pre> Source code in <code>multimolecule/tokenisers/rna/tokenization_rna.py</code> Python<pre><code>class RnaTokenizer(Tokenizer):\n    \"\"\"\n    Constructs an RNA tokenizer.\n\n    Args:\n        alphabet (List[str] | None, optional): List of tokens to use.\n            Defaults to [IUPAC nucleotide code](https://www.bioinformatics.org/sms2/iupac.html).\n        nmers (int, optional): Size of nmers to tokenize.\n            Defaults to 1.\n        codon (bool, optional): Whether to tokenize into codons.\n            Defaults to False.\n        replace_T_with_U (bool, optional): Whether to replace T with U.\n            Defaults to True.\n        do_upper_case (bool, optional): Whether to convert input to uppercase.\n            Defaults to True.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaTokenizer\n        &gt;&gt;&gt; tokenizer = RnaTokenizer()\n        &gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n        [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n        &gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 3, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 17, 64, 49, 96, 84, 22, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 49, 22, 2]\n        &gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\n        Traceback (most recent call last):\n        ValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n    \"\"\"\n\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n\n    def __init__(\n        self,\n        alphabet: List[str] | None = None,\n        nmers: int = 1,\n        codon: bool = False,\n        replace_T_with_U: bool = True,\n        bos_token: str = \"&lt;cls&gt;\",\n        cls_token: str = \"&lt;cls&gt;\",\n        pad_token: str = \"&lt;pad&gt;\",\n        eos_token: str = \"&lt;eos&gt;\",\n        sep_token: str = \"&lt;eos&gt;\",\n        unk_token: str = \"&lt;unk&gt;\",\n        mask_token: str = \"&lt;mask&gt;\",\n        additional_special_tokens: List | Tuple | None = None,\n        do_upper_case: bool = True,\n        **kwargs,\n    ):\n        if codon and nmers &gt; 1:\n            raise ValueError(\"Codon and nmers cannot be used together.\")\n        if codon:\n            nmers = 3  # set to 3 to get correct vocab\n        super().__init__(\n            alphabet=get_vocab_list(alphabet, nmers),\n            bos_token=bos_token,\n            cls_token=cls_token,\n            pad_token=pad_token,\n            eos_token=eos_token,\n            sep_token=sep_token,\n            unk_token=unk_token,\n            mask_token=mask_token,\n            additional_special_tokens=additional_special_tokens,\n            do_upper_case=do_upper_case,\n            **kwargs,\n        )\n        self.replace_T_with_U = replace_T_with_U\n        self.nmers = nmers\n        self.condon = codon\n\n    def _tokenize(self, text: str, **kwargs):\n        if self.do_upper_case:\n            text = text.upper()\n        if self.replace_T_with_U:\n            text = text.replace(\"T\", \"U\")\n        if self.condon:\n            if len(text) % 3 != 0:\n                raise ValueError(\n                    f\"length of input sequence  must be a multiple of 3 for codon tokenization, but got {len(text)}\"\n                )\n            return [text[i : i + 3] for i in range(0, len(text), 3)]\n        if self.nmers &gt; 1:\n            return [text[i : i + self.nmers] for i in range(len(text) - self.nmers + 1)]  # noqa: E203\n        return list(text)\n</code></pre>"},{"location":"models/rnafm/#multimolecule.models.rnafm.RnaFmConfig","title":"<code>RnaFmConfig</code>","text":"<p>               Bases: <code>PreTrainedConfig</code></p> <p>This is the configuration class to store the configuration of a [<code>RnaFmModel</code>]. It is used to instantiate a RNA-FM model according to the specified arguments, defining the model architecture. Instantiating a configuration with the defaults will yield a similar configuration to that of the RNA-FM ml4bio/RNA-FM architecture.</p> <p>Configuration objects inherit from [<code>PreTrainedConfig</code>] and can be used to control the model outputs. Read the documentation from [<code>PreTrainedConfig</code>] for more information.</p> <p>Parameters:</p> Name Type Description Default <code>vocab_size</code> <code>`int`, *optional*, defaults to 26 if `codon=False` else 131</code> <p>Vocabulary size of the RNA-FM model. Defines the number of different tokens that can be represented by the <code>inputs_ids</code> passed when calling [<code>RnaFmModel</code>].</p> <code>None</code> <code>codon</code> <code>`bool`, *optional*, defaults to `False`</code> <p>Whether to use codon tokenization.</p> <code>False</code> <code>hidden_size</code> <code>`int`, *optional*, defaults to 640</code> <p>Dimensionality of the encoder layers and the pooler layer.</p> <code>640</code> <code>num_hidden_layers</code> <code>`int`, *optional*, defaults to 12</code> <p>Number of hidden layers in the Transformer encoder.</p> <code>12</code> <code>num_attention_heads</code> <code>`int`, *optional*, defaults to 20</code> <p>Number of attention heads for each attention layer in the Transformer encoder.</p> <code>20</code> <code>intermediate_size</code> <code>`int`, *optional*, defaults to 5120</code> <p>Dimensionality of the \u201cintermediate\u201d (often named feed-forward) layer in the Transformer encoder.</p> <code>5120</code> <code>hidden_dropout</code> <code>`float`, *optional*, defaults to 0.1</code> <p>The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.</p> <code>0.1</code> <code>attention_dropout</code> <code>`float`, *optional*, defaults to 0.1</code> <p>The dropout ratio for the attention probabilities.</p> <code>0.1</code> <code>max_position_embeddings</code> <code>`int`, *optional*, defaults to 1026</code> <p>The maximum sequence length that this model might ever be used with. Typically set this to something large just in case (e.g., 512 or 1024 or 2048).</p> <code>1026</code> <code>initializer_range</code> <code>`float`, *optional*, defaults to 0.02</code> <p>The standard deviation of the truncated_normal_initializer for initializing all weight matrices.</p> <code>0.02</code> <code>layer_norm_eps</code> <code>`float`, *optional*, defaults to 1e-12</code> <p>The epsilon used by the layer normalization layers.</p> <code>1e-12</code> <code>position_embedding_type</code> <code>`str`, *optional*, defaults to `\"absolute\"`</code> <p>Type of position embedding. Choose one of <code>\"absolute\"</code>, <code>\"relative_key\"</code>, <code>\"relative_key_query\", \"rotary\"</code>. For positional embeddings use <code>\"absolute\"</code>. For more information on <code>\"relative_key\"</code>, please refer to Self-Attention with Relative Position Representations (Shaw et al.). For more information on <code>\"relative_key_query\"</code>, please refer to Method 4 in Improve Transformer Models with Better Relative Position Embeddings (Huang et al.).</p> <code>'absolute'</code> <code>is_decoder</code> <code>`bool`, *optional*, defaults to `False`</code> <p>Whether the model is used as a decoder or not. If <code>False</code>, the model is used as an encoder.</p> required <code>use_cache</code> <code>`bool`, *optional*, defaults to `True`</code> <p>Whether or not the model should return the last key/values attentions (not used by all models). Only relevant if <code>config.is_decoder=True</code>.</p> <code>True</code> <code>emb_layer_norm_before</code> <code>`bool`, *optional*</code> <p>Whether to apply layer normalization after embeddings but before the main stem of the network.</p> <code>True</code> <code>token_dropout</code> <code>`bool`, defaults to `False`</code> <p>When this is enabled, masked tokens are treated as if they had been dropped out by input dropout.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaFmModel, RnaFmConfig\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a RNA-FM multimolecule/rnafm style configuration\n&gt;&gt;&gt; configuration = RnaFmConfig()\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/rnafm style configuration\n&gt;&gt;&gt; model = RnaFmModel(configuration)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Accessing the model configuration\n&gt;&gt;&gt; configuration = model.config\n</code></pre> Source code in <code>multimolecule/models/rnafm/configuration_rnafm.py</code> Python<pre><code>class RnaFmConfig(PreTrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`RnaFmModel`]. It is used to instantiate a RNA-FM\n    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n    defaults will yield a similar configuration to that of the RNA-FM\n    [ml4bio/RNA-FM](https://github.com/ml4bio/RNA-FM) architecture.\n\n    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n    documentation from [`PreTrainedConfig`] for more information.\n\n\n    Args:\n        vocab_size (`int`, *optional*, defaults to 26 if `codon=False` else 131):\n            Vocabulary size of the RNA-FM model. Defines the number of different tokens that can be represented by the\n            `inputs_ids` passed when calling [`RnaFmModel`].\n        codon (`bool`, *optional*, defaults to `False`):\n            Whether to use codon tokenization.\n        hidden_size (`int`, *optional*, defaults to 640):\n            Dimensionality of the encoder layers and the pooler layer.\n        num_hidden_layers (`int`, *optional*, defaults to 12):\n            Number of hidden layers in the Transformer encoder.\n        num_attention_heads (`int`, *optional*, defaults to 20):\n            Number of attention heads for each attention layer in the Transformer encoder.\n        intermediate_size (`int`, *optional*, defaults to 5120):\n            Dimensionality of the \"intermediate\" (often named feed-forward) layer in the Transformer encoder.\n        hidden_dropout (`float`, *optional*, defaults to 0.1):\n            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n        attention_dropout (`float`, *optional*, defaults to 0.1):\n            The dropout ratio for the attention probabilities.\n        max_position_embeddings (`int`, *optional*, defaults to 1026):\n            The maximum sequence length that this model might ever be used with. Typically set this to something large\n            just in case (e.g., 512 or 1024 or 2048).\n        initializer_range (`float`, *optional*, defaults to 0.02):\n            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n        layer_norm_eps (`float`, *optional*, defaults to 1e-12):\n            The epsilon used by the layer normalization layers.\n        position_embedding_type (`str`, *optional*, defaults to `\"absolute\"`):\n            Type of position embedding. Choose one of `\"absolute\"`, `\"relative_key\"`, `\"relative_key_query\", \"rotary\"`.\n            For positional embeddings use `\"absolute\"`. For more information on `\"relative_key\"`, please refer to\n            [Self-Attention with Relative Position Representations (Shaw et al.)](https://arxiv.org/abs/1803.02155).\n            For more information on `\"relative_key_query\"`, please refer to *Method 4* in [Improve Transformer Models\n            with Better Relative Position Embeddings (Huang et al.)](https://arxiv.org/abs/2009.13658).\n        is_decoder (`bool`, *optional*, defaults to `False`):\n            Whether the model is used as a decoder or not. If `False`, the model is used as an encoder.\n        use_cache (`bool`, *optional*, defaults to `True`):\n            Whether or not the model should return the last key/values attentions (not used by all models). Only\n            relevant if `config.is_decoder=True`.\n        emb_layer_norm_before (`bool`, *optional*):\n            Whether to apply layer normalization after embeddings but before the main stem of the network.\n        token_dropout (`bool`, defaults to `False`):\n            When this is enabled, masked tokens are treated as if they had been dropped out by input dropout.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaFmModel, RnaFmConfig\n\n        &gt;&gt;&gt; # Initializing a RNA-FM multimolecule/rnafm style configuration\n        &gt;&gt;&gt; configuration = RnaFmConfig()\n\n        &gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/rnafm style configuration\n        &gt;&gt;&gt; model = RnaFmModel(configuration)\n\n        &gt;&gt;&gt; # Accessing the model configuration\n        &gt;&gt;&gt; configuration = model.config\n    \"\"\"\n\n    model_type = \"rnafm\"\n\n    def __init__(\n        self,\n        vocab_size=None,\n        codon=False,\n        hidden_size=640,\n        num_hidden_layers=12,\n        num_attention_heads=20,\n        intermediate_size=5120,\n        hidden_act=\"gelu\",\n        hidden_dropout=0.1,\n        attention_dropout=0.1,\n        max_position_embeddings=1026,\n        initializer_range=0.02,\n        layer_norm_eps=1e-12,\n        position_embedding_type=\"absolute\",\n        use_cache=True,\n        emb_layer_norm_before=True,\n        token_dropout=True,\n        head=None,\n        lm_head=None,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n        if vocab_size is None:\n            vocab_size = 131 if codon else 26\n        self.vocab_size = vocab_size\n        self.codon = codon\n        self.hidden_size = hidden_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_attention_heads = num_attention_heads\n        self.intermediate_size = intermediate_size\n        self.hidden_act = hidden_act\n        self.hidden_dropout = hidden_dropout\n        self.attention_dropout = attention_dropout\n        self.max_position_embeddings = max_position_embeddings\n        self.initializer_range = initializer_range\n        self.layer_norm_eps = layer_norm_eps\n        self.position_embedding_type = position_embedding_type\n        self.use_cache = use_cache\n        self.emb_layer_norm_before = emb_layer_norm_before\n        self.token_dropout = token_dropout\n        self.head = HeadConfig(**head if head is not None else {})\n        self.lm_head = MaskedLMHeadConfig(**lm_head if lm_head is not None else {})\n</code></pre>"},{"location":"models/rnafm/#multimolecule.models.rnafm.RnaFmForMaskedLM","title":"<code>RnaFmForMaskedLM</code>","text":"<p>               Bases: <code>RnaFmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaFmConfig, RnaFmForMaskedLM, RnaTokenizer\n&gt;&gt;&gt; config = RnaFmConfig()\n&gt;&gt;&gt; model = RnaFmForMaskedLM(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 26])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/rnafm/modeling_rnafm.py</code> Python<pre><code>class RnaFmForMaskedLM(RnaFmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaFmConfig, RnaFmForMaskedLM, RnaTokenizer\n        &gt;&gt;&gt; config = RnaFmConfig()\n        &gt;&gt;&gt; model = RnaFmForMaskedLM(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 26])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    _tied_weights_keys = [\"lm_head.decoder.weight\"]\n\n    def __init__(self, config: RnaFmConfig):\n        super().__init__(config)\n        if config.is_decoder:\n            logger.warning(\n                \"If you want to use `RnaFmForMaskedLM` make sure `config.is_decoder=False` for \"\n                \"bi-directional self-attention.\"\n            )\n        self.rnafm = RnaFmModel(config, add_pooling_layer=False)\n        self.lm_head = MaskedLMHead(config)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | MaskedLMOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rnafm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_attention_mask,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.lm_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return MaskedLMOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/rnafm/#multimolecule.models.rnafm.RnaFmForNucleotidePrediction","title":"<code>RnaFmForNucleotidePrediction</code>","text":"<p>               Bases: <code>RnaFmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaFmConfig, RnaFmForNucleotidePrediction, RnaTokenizer\n&gt;&gt;&gt; config = RnaFmConfig()\n&gt;&gt;&gt; model = RnaFmForNucleotidePrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 5, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/rnafm/modeling_rnafm.py</code> Python<pre><code>class RnaFmForNucleotidePrediction(RnaFmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaFmConfig, RnaFmForNucleotidePrediction, RnaTokenizer\n        &gt;&gt;&gt; config = RnaFmConfig()\n        &gt;&gt;&gt; model = RnaFmForNucleotidePrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 5, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: RnaFmConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.rnafm = RnaFmModel(config, add_pooling_layer=True)\n        self.nucleotide_head = NucleotidePredictionHead(config)\n        self.head_config = self.nucleotide_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | NucleotidePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rnafm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.nucleotide_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return NucleotidePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/rnafm/#multimolecule.models.rnafm.RnaFmForPreTraining","title":"<code>RnaFmForPreTraining</code>","text":"<p>               Bases: <code>RnaFmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaFmConfig, RnaFmForPreTraining, RnaTokenizer\n&gt;&gt;&gt; config = RnaFmConfig()\n&gt;&gt;&gt; model = RnaFmForPreTraining(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels_mlm=input[\"input_ids\"])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;AddBackward0&gt;)\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 26])\n&gt;&gt;&gt; output[\"contact_map\"].shape\ntorch.Size([1, 5, 5, 2])\n</code></pre> Source code in <code>multimolecule/models/rnafm/modeling_rnafm.py</code> Python<pre><code>class RnaFmForPreTraining(RnaFmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaFmConfig, RnaFmForPreTraining, RnaTokenizer\n        &gt;&gt;&gt; config = RnaFmConfig()\n        &gt;&gt;&gt; model = RnaFmForPreTraining(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels_mlm=input[\"input_ids\"])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;AddBackward0&gt;)\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 26])\n        &gt;&gt;&gt; output[\"contact_map\"].shape\n        torch.Size([1, 5, 5, 2])\n    \"\"\"\n\n    _tied_weights_keys = [\"head.predictions.decoder.weight\"]\n\n    def __init__(self, config: RnaFmConfig):\n        super().__init__(config)\n        if config.is_decoder:\n            logger.warning(\n                \"If you want to use `RnaFmForPreTraining` make sure `config.is_decoder=False` for \"\n                \"bi-directional self-attention.\"\n            )\n        self.rnafm = RnaFmModel(config, add_pooling_layer=False)\n        self.pretrain_head = RnaFmPreTrainingHeads(config)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_output_embeddings(self):\n        return self.pretrain_head.predictions.decoder\n\n    def set_output_embeddings(self, embeddings):\n        self.pretrain_head.predictions.decoder = embeddings\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        labels_mlm: Tensor | None = None,\n        labels_contact: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | RnaFmForPreTrainingOutput:\n        if output_attentions is False:\n            warn(\"output_attentions must be True for contact classification and will be ignored.\")\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rnafm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_attention_mask,\n            output_attentions=True,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        total_loss, logits, contact_map = self.pretrain_head(\n            outputs, attention_mask, input_ids, labels_mlm=labels_mlm, labels_contact=labels_contact\n        )\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((total_loss,) + output) if total_loss is not None else output\n\n        return RnaFmForPreTrainingOutput(\n            loss=total_loss,\n            logits=logits,\n            contact_map=contact_map,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/rnafm/#multimolecule.models.rnafm.RnaFmForSequencePrediction","title":"<code>RnaFmForSequencePrediction</code>","text":"<p>               Bases: <code>RnaFmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaFmConfig, RnaFmForSequencePrediction, RnaTokenizer\n&gt;&gt;&gt; config = RnaFmConfig()\n&gt;&gt;&gt; model = RnaFmForSequencePrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.tensor([[1]]))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/rnafm/modeling_rnafm.py</code> Python<pre><code>class RnaFmForSequencePrediction(RnaFmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaFmConfig, RnaFmForSequencePrediction, RnaTokenizer\n        &gt;&gt;&gt; config = RnaFmConfig()\n        &gt;&gt;&gt; model = RnaFmForSequencePrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.tensor([[1]]))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: RnaFmConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.rnafm = RnaFmModel(config, add_pooling_layer=True)\n        self.sequence_head = SequencePredictionHead(config)\n        self.head_config = self.sequence_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | SequencePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rnafm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.sequence_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return SequencePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/rnafm/#multimolecule.models.rnafm.RnaFmForTokenPrediction","title":"<code>RnaFmForTokenPrediction</code>","text":"<p>               Bases: <code>RnaFmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaFmConfig, RnaFmForTokenPrediction, RnaTokenizer\n&gt;&gt;&gt; config = RnaFmConfig()\n&gt;&gt;&gt; model = RnaFmForTokenPrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/rnafm/modeling_rnafm.py</code> Python<pre><code>class RnaFmForTokenPrediction(RnaFmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaFmConfig, RnaFmForTokenPrediction, RnaTokenizer\n        &gt;&gt;&gt; config = RnaFmConfig()\n        &gt;&gt;&gt; model = RnaFmForTokenPrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: RnaFmConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.rnafm = RnaFmModel(config, add_pooling_layer=True)\n        self.token_head = TokenPredictionHead(config)\n        self.head_config = self.token_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | TokenPredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rnafm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.token_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return TokenPredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/rnafm/#multimolecule.models.rnafm.RnaFmModel","title":"<code>RnaFmModel</code>","text":"<p>               Bases: <code>RnaFmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaFmConfig, RnaFmModel, RnaTokenizer\n&gt;&gt;&gt; config = RnaFmConfig()\n&gt;&gt;&gt; model = RnaFmModel(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input)\n&gt;&gt;&gt; output[\"last_hidden_state\"].shape\ntorch.Size([1, 7, 640])\n&gt;&gt;&gt; output[\"pooler_output\"].shape\ntorch.Size([1, 640])\n</code></pre> Source code in <code>multimolecule/models/rnafm/modeling_rnafm.py</code> Python<pre><code>class RnaFmModel(RnaFmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaFmConfig, RnaFmModel, RnaTokenizer\n        &gt;&gt;&gt; config = RnaFmConfig()\n        &gt;&gt;&gt; model = RnaFmModel(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input)\n        &gt;&gt;&gt; output[\"last_hidden_state\"].shape\n        torch.Size([1, 7, 640])\n        &gt;&gt;&gt; output[\"pooler_output\"].shape\n        torch.Size([1, 640])\n    \"\"\"\n\n    def __init__(self, config: RnaFmConfig, add_pooling_layer: bool = True):\n        super().__init__(config)\n        self.pad_token_id = config.pad_token_id\n        self.embeddings = RnaFmEmbeddings(config)\n        self.encoder = RnaFmEncoder(config)\n        self.pooler = RnaFmPooler(config) if add_pooling_layer else None\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.embeddings.word_embeddings\n\n    def set_input_embeddings(self, value):\n        self.embeddings.word_embeddings = value\n\n    def _prune_heads(self, heads_to_prune):\n        \"\"\"\n        Prunes heads of the model. heads_to_prune: dict of {layer_num: list of heads to prune in this layer} See base\n        class PreTrainedModel\n        \"\"\"\n        for layer, heads in heads_to_prune.items():\n            self.encoder.layer[layer].attention.prune_heads(heads)\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        past_key_values: Tuple[Tuple[torch.FloatTensor, torch.FloatTensor], ...] | None = None,\n        use_cache: bool | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | BaseModelOutputWithPoolingAndCrossAttentions:\n        r\"\"\"\n        encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n            Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n            the model is configured as a decoder.\n        encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n            the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n            - 1 for tokens that are **not masked**,\n            - 0 for tokens that are **masked**.\n        past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors\n            of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n            Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n        use_cache (`bool`, *optional*):\n            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n            `past_key_values`).\n        \"\"\"\n        if kwargs:\n            warn(\n                f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n                f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n                \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n            )\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        if self.config.is_decoder:\n            use_cache = use_cache if use_cache is not None else self.config.use_cache\n        else:\n            use_cache = False\n\n        if isinstance(input_ids, NestedTensor):\n            input_ids, attention_mask = input_ids.tensor, input_ids.mask\n        if input_ids is not None and inputs_embeds is not None:\n            raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n        if input_ids is not None:\n            self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n            input_shape = input_ids.size()\n        elif inputs_embeds is not None:\n            input_shape = inputs_embeds.size()[:-1]\n        else:\n            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n        batch_size, seq_length = input_shape\n        device = input_ids.device if input_ids is not None else inputs_embeds.device  # type: ignore[union-attr]\n\n        # past_key_values_length\n        past_key_values_length = past_key_values[0][0].shape[2] if past_key_values is not None else 0\n\n        if attention_mask is None:\n            attention_mask = (\n                input_ids.ne(self.pad_token_id)\n                if self.pad_token_id is not None\n                else torch.ones(((batch_size, seq_length + past_key_values_length)), device=device)\n            )\n\n        # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n        # ourselves in which case we just need to make it broadcastable to all heads.\n        extended_attention_mask: Tensor = self.get_extended_attention_mask(attention_mask, input_shape)\n\n        # If a 2D or 3D attention mask is provided for the cross-attention\n        # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n        if self.config.is_decoder and encoder_hidden_states is not None:\n            encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n            encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n            if encoder_attention_mask is None:\n                encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n            encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n        else:\n            encoder_extended_attention_mask = None\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n        head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n        embedding_output = self.embeddings(\n            input_ids=input_ids,\n            position_ids=position_ids,\n            attention_mask=attention_mask,\n            inputs_embeds=inputs_embeds,\n            past_key_values_length=past_key_values_length,\n        )\n        encoder_outputs = self.encoder(\n            embedding_output,\n            attention_mask=extended_attention_mask,\n            head_mask=head_mask,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_extended_attention_mask,\n            past_key_values=past_key_values,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n        sequence_output = encoder_outputs[0]\n        pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n        if not return_dict:\n            return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n        return BaseModelOutputWithPoolingAndCrossAttentions(\n            last_hidden_state=sequence_output,\n            pooler_output=pooled_output,\n            past_key_values=encoder_outputs.past_key_values,\n            hidden_states=encoder_outputs.hidden_states,\n            attentions=encoder_outputs.attentions,\n            cross_attentions=encoder_outputs.cross_attentions,\n        )\n</code></pre>"},{"location":"models/rnafm/#multimolecule.models.rnafm.RnaFmModel.forward","title":"<code>forward(input_ids, attention_mask=None, position_ids=None, head_mask=None, inputs_embeds=None, encoder_hidden_states=None, encoder_attention_mask=None, past_key_values=None, use_cache=None, output_attentions=None, output_hidden_states=None, return_dict=None, **kwargs)</code>","text":"<p>encoder_hidden_states  (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, optional):     Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if     the model is configured as a decoder. encoder_attention_mask (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, optional):     Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in     the cross-attention if the model is configured as a decoder. Mask values selected in <code>[0, 1]</code>:</p> Text Only<pre><code>- 1 for tokens that are **not masked**,\n- 0 for tokens that are **masked**.\n</code></pre> <p>past_key_values (<code>tuple(tuple(torch.FloatTensor))</code> of length <code>config.n_layers</code> with each tuple having 4 tensors     of shape <code>(batch_size, num_heads, sequence_length - 1, embed_size_per_head)</code>):     Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.</p> Text Only<pre><code>If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\ndon't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n`decoder_input_ids` of shape `(batch_size, sequence_length)`.\n</code></pre> <p>use_cache (<code>bool</code>, optional):     If set to <code>True</code>, <code>past_key_values</code> key value states are returned and can be used to speed up decoding (see     <code>past_key_values</code>).</p> Source code in <code>multimolecule/models/rnafm/modeling_rnafm.py</code> Python<pre><code>def forward(\n    self,\n    input_ids: Tensor | NestedTensor,\n    attention_mask: Tensor | None = None,\n    position_ids: Tensor | None = None,\n    head_mask: Tensor | None = None,\n    inputs_embeds: Tensor | NestedTensor | None = None,\n    encoder_hidden_states: Tensor | None = None,\n    encoder_attention_mask: Tensor | None = None,\n    past_key_values: Tuple[Tuple[torch.FloatTensor, torch.FloatTensor], ...] | None = None,\n    use_cache: bool | None = None,\n    output_attentions: bool | None = None,\n    output_hidden_states: bool | None = None,\n    return_dict: bool | None = None,\n    **kwargs,\n) -&gt; Tuple[Tensor, ...] | BaseModelOutputWithPoolingAndCrossAttentions:\n    r\"\"\"\n    encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n        Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n        the model is configured as a decoder.\n    encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n        Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n        the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n        - 1 for tokens that are **not masked**,\n        - 0 for tokens that are **masked**.\n    past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors\n        of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n        Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n        If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n        don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n        `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n    use_cache (`bool`, *optional*):\n        If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n        `past_key_values`).\n    \"\"\"\n    if kwargs:\n        warn(\n            f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n            f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n            \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n        )\n    output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n    output_hidden_states = (\n        output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n    )\n    return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n    if self.config.is_decoder:\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n    else:\n        use_cache = False\n\n    if isinstance(input_ids, NestedTensor):\n        input_ids, attention_mask = input_ids.tensor, input_ids.mask\n    if input_ids is not None and inputs_embeds is not None:\n        raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n    if input_ids is not None:\n        self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n        input_shape = input_ids.size()\n    elif inputs_embeds is not None:\n        input_shape = inputs_embeds.size()[:-1]\n    else:\n        raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n    batch_size, seq_length = input_shape\n    device = input_ids.device if input_ids is not None else inputs_embeds.device  # type: ignore[union-attr]\n\n    # past_key_values_length\n    past_key_values_length = past_key_values[0][0].shape[2] if past_key_values is not None else 0\n\n    if attention_mask is None:\n        attention_mask = (\n            input_ids.ne(self.pad_token_id)\n            if self.pad_token_id is not None\n            else torch.ones(((batch_size, seq_length + past_key_values_length)), device=device)\n        )\n\n    # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n    # ourselves in which case we just need to make it broadcastable to all heads.\n    extended_attention_mask: Tensor = self.get_extended_attention_mask(attention_mask, input_shape)\n\n    # If a 2D or 3D attention mask is provided for the cross-attention\n    # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n    if self.config.is_decoder and encoder_hidden_states is not None:\n        encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n        encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n        if encoder_attention_mask is None:\n            encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n        encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n    else:\n        encoder_extended_attention_mask = None\n\n    # Prepare head mask if needed\n    # 1.0 in head_mask indicate we keep the head\n    # attention_probs has shape bsz x n_heads x N x N\n    # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n    # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n    head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n    embedding_output = self.embeddings(\n        input_ids=input_ids,\n        position_ids=position_ids,\n        attention_mask=attention_mask,\n        inputs_embeds=inputs_embeds,\n        past_key_values_length=past_key_values_length,\n    )\n    encoder_outputs = self.encoder(\n        embedding_output,\n        attention_mask=extended_attention_mask,\n        head_mask=head_mask,\n        encoder_hidden_states=encoder_hidden_states,\n        encoder_attention_mask=encoder_extended_attention_mask,\n        past_key_values=past_key_values,\n        use_cache=use_cache,\n        output_attentions=output_attentions,\n        output_hidden_states=output_hidden_states,\n        return_dict=return_dict,\n    )\n    sequence_output = encoder_outputs[0]\n    pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n    if not return_dict:\n        return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n    return BaseModelOutputWithPoolingAndCrossAttentions(\n        last_hidden_state=sequence_output,\n        pooler_output=pooled_output,\n        past_key_values=encoder_outputs.past_key_values,\n        hidden_states=encoder_outputs.hidden_states,\n        attentions=encoder_outputs.attentions,\n        cross_attentions=encoder_outputs.cross_attentions,\n    )\n</code></pre>"},{"location":"models/rnafm/#multimolecule.models.rnafm.RnaFmPreTrainedModel","title":"<code>RnaFmPreTrainedModel</code>","text":"<p>               Bases: <code>PreTrainedModel</code></p> <p>An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained models.</p> Source code in <code>multimolecule/models/rnafm/modeling_rnafm.py</code> Python<pre><code>class RnaFmPreTrainedModel(PreTrainedModel):\n    \"\"\"\n    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n    models.\n    \"\"\"\n\n    config_class = RnaFmConfig\n    base_model_prefix = \"rnafm\"\n    supports_gradient_checkpointing = True\n    _no_split_modules = [\"RnaFmLayer\", \"RnaFmEmbeddings\"]\n\n    # Copied from transformers.models.bert.modeling_bert.BertPreTrainedModel._init_weights\n    def _init_weights(self, module: nn.Module):\n        \"\"\"Initialize the weights\"\"\"\n        if isinstance(module, nn.Linear):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, nn.Embedding):\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.padding_idx is not None:\n                module.weight.data[module.padding_idx].zero_()\n        elif isinstance(module, nn.LayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n</code></pre>"},{"location":"models/rnamsm/","title":"RNA-MSM","text":"<p>Pre-trained model on non-coding RNA (ncRNA) with multi (homologous) sequence alignment using a masked language modeling (MLM) objective.</p>"},{"location":"models/rnamsm/#disclaimer","title":"Disclaimer","text":"<p>This is an UNOFFICIAL implementation of the Multiple sequence alignment-based RNA language model and its application to structural inference by Yikun Zhang, Mei Lang, Jiuhong Jiang, Zhiqiang Gao, et al.</p> <p>The OFFICIAL repository of RNA-MSM is at yikunpku/RNA-MSM.</p> <p>The team releasing RNA-MSM did not write this model card for this model so this model card has been written by the MultiMolecule team.</p>"},{"location":"models/rnamsm/#model-details","title":"Model Details","text":"<p>RNA-MSM is a bert-style model pre-trained on a large corpus of non-coding RNA sequences in a self-supervised fashion. This means that the model was trained on the raw nucleotides of RNA sequences only, with an automatic process to generate inputs and labels from those texts. Please refer to the Training Details section for more information on the training process.</p>"},{"location":"models/rnamsm/#model-specification","title":"Model Specification","text":"Num Layers Hidden Size Num Heads Intermediate Size Num Parameters (M) FLOPs (G) MACs (G) Max Num Tokens 10 768 12 3072 95.92 21.66 10.57 1024"},{"location":"models/rnamsm/#links","title":"Links","text":"<ul> <li>Code: multimolecule.rnamsm</li> <li>Weights: multimolecule/rnamsm</li> <li>Data: Rfam</li> <li>Paper: Multiple sequence alignment-based RNA language model and its application to structural inference</li> <li>Developed by: Yikun Zhang, Mei Lang, Jiuhong Jiang, Zhiqiang Gao, Fan Xu, Thomas Litfin, Ke Chen, Jaswinder Singh, Xiansong Huang, Guoli Song, Yonghong Tian, Jian Zhan, Jie Chen, Yaoqi Zhou</li> <li>Model type: BERT - MSA</li> <li>Original Repository: https://github.com/yikunpku/RNA-MSM</li> </ul>"},{"location":"models/rnamsm/#usage","title":"Usage","text":"<p>The model file depends on the <code>multimolecule</code> library. You can install it using pip:</p> Bash<pre><code>pip install multimolecule\n</code></pre>"},{"location":"models/rnamsm/#direct-use","title":"Direct Use","text":"<p>You can use this model directly with a pipeline for masked language modeling:</p> Python<pre><code>&gt;&gt;&gt; import multimolecule  # you must import multimolecule to register models\n&gt;&gt;&gt; from transformers import pipeline\n&gt;&gt;&gt; unmasker = pipeline('fill-mask', model='multimolecule/rnamsm')\n&gt;&gt;&gt; unmasker(\"uagc&lt;mask&gt;uaucagacugauguuga\")\n\n[{'score': 0.28535839915275574,\n  'token': 9,\n  'token_str': 'U',\n  'sequence': 'U A G C U U A U C A G A C U G A U G U U G A'},\n {'score': 0.2532415986061096,\n  'token': 22,\n  'token_str': 'K',\n  'sequence': 'U A G C K U A U C A G A C U G A U G U U G A'},\n {'score': 0.2247398942708969,\n  'token': 8,\n  'token_str': 'G',\n  'sequence': 'U A G C G U A U C A G A C U G A U G U U G A'},\n {'score': 0.06841657310724258,\n  'token': 15,\n  'token_str': 'D',\n  'sequence': 'U A G C D U A U C A G A C U G A U G U U G A'},\n {'score': 0.03774874284863472,\n  'token': 19,\n  'token_str': 'W',\n  'sequence': 'U A G C W U A U C A G A C U G A U G U U G A'}]\n</code></pre>"},{"location":"models/rnamsm/#downstream-use","title":"Downstream Use","text":""},{"location":"models/rnamsm/#extract-features","title":"Extract Features","text":"<p>Here is how to use this model to get the features of a given sequence in PyTorch:</p> Python<pre><code>from multimolecule import RnaTokenizer, RnaMsmModel\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/rnamsm')\nmodel = RnaMsmModel.from_pretrained('multimolecule/rnamsm')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\n\noutput = model(**input)\n</code></pre>"},{"location":"models/rnamsm/#sequence-classification-regression","title":"Sequence Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for sequence classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a sequence-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, RnaMsmForSequencePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/rnamsm')\nmodel = RnaMsmForSequencePrediction.from_pretrained('multimolecule/rnamsm')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.tensor([1])\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/rnamsm/#nucleotide-classification-regression","title":"Nucleotide Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for nucleotide classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a nucleotide-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, RnaMsmForNucleotidePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/rnamsm')\nmodel = RnaMsmForNucleotidPrediction.from_pretrained('multimolecule/rnamsm')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.randint(2, (len(text), ))\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/rnamsm/#training-details","title":"Training Details","text":"<p>RNA-MSM used Masked Language Modeling (MLM) as the pre-training objective: taking a sequence, the model randomly masks 15% of the tokens in the input then runs the entire masked sentence through the model and has to predict the masked tokens. This is comparable to the Cloze task in language modeling.</p>"},{"location":"models/rnamsm/#training-data","title":"Training Data","text":"<p>The RNA-MSM model was pre-trained on Rfam. Rfam database is a collection of RNA families, each represented by multiple sequence alignments, consensus secondary structures and covariance models. RNA-MSM used Rfam 14.7 which contains 4,069 RNA families.</p> <p>To avoid potential overfitting in structural inference, RNA-MSM excluded families with experimentally determined structures, such as ribosomal RNAs, transfer RNAs, and small nuclear RNAs. The final dataset contains 3,932 RNA families. The median value for the number of MSA sequences for these families by RNAcmap3 is 2,184.</p> <p>To increase the number of homologous sequences, RNA-MSM used an automatic pipeline, RNAcmap3, for homolog search and sequence alignment. RNAcmap3 is a pipeline that combines the BLAST-N, INFERNAL, Easel, RNAfold and evolutionary coupling tools to generate homologous sequences.</p> <p>RNA-MSM preprocessed all tokens by replacing \u201cT\u201ds with \u201cU\u201ds and substituting \u201cR\u201d, \u201cY\u201d, \u201cK\u201d, \u201cM\u201d, \u201cS\u201d, \u201cW\u201d, \u201cB\u201d, \u201cD\u201d, \u201cH\u201d, \u201cV\u201d, \u201cN\u201d with \u201cX\u201d.</p> <p>Note that <code>RnaTokenizer</code> will convert \u201cT\u201ds to \u201cU\u201ds for you, you may disable this behaviour by passing <code>replace_T_with_U=False</code>. <code>RnaTokenizer</code> does not perform other substitutions.</p>"},{"location":"models/rnamsm/#training-procedure","title":"Training Procedure","text":""},{"location":"models/rnamsm/#preprocessing","title":"Preprocessing","text":"<p>RNA-MSM used masked language modeling (MLM) as the pre-training objective. The masking procedure is similar to the one used in BERT:</p> <ul> <li>15% of the tokens are masked.</li> <li>In 80% of the cases, the masked tokens are replaced by <code>&lt;mask&gt;</code>.</li> <li>In 10% of the cases, the masked tokens are replaced by a random token (different) from the one they replace.</li> <li>In the 10% remaining cases, the masked tokens are left as is.</li> </ul>"},{"location":"models/rnamsm/#pretraining","title":"PreTraining","text":"<p>The model was trained on 8 NVIDIA V100 GPUs with 32GiB memories.</p> <ul> <li>Learning rate: 3e-4</li> <li>Weight decay: 3e-4</li> <li>Optimizer: Adam</li> <li>Learning rate warm-up: 16,000 steps</li> <li>Epochs: 300</li> <li>Batch Size: 1</li> <li>Dropout: 0.1</li> </ul>"},{"location":"models/rnamsm/#citation","title":"Citation","text":"<p>BibTeX:</p> BibTeX<pre><code>@article{zhang2023multiple,\n    author = {Zhang, Yikun and Lang, Mei and Jiang, Jiuhong and Gao, Zhiqiang and Xu, Fan and Litfin, Thomas and Chen, Ke and Singh, Jaswinder and Huang, Xiansong and Song, Guoli and Tian, Yonghong and Zhan, Jian and Chen, Jie and Zhou, Yaoqi},\n    title = \"{Multiple sequence alignment-based RNA language model and its application to structural inference}\",\n    journal = {Nucleic Acids Research},\n    volume = {52},\n    number = {1},\n    pages = {e3-e3},\n    year = {2023},\n    month = {11},\n    abstract = \"{Compared with proteins, DNA and RNA are more difficult languages to interpret because four-letter coded DNA/RNA sequences have less information content than 20-letter coded protein sequences. While BERT (Bidirectional Encoder Representations from Transformers)-like language models have been developed for RNA, they are ineffective at capturing the evolutionary information from homologous sequences because\u00a0unlike proteins, RNA sequences are less conserved. Here, we have developed an unsupervised multiple sequence alignment-based RNA language model (RNA-MSM) by utilizing homologous sequences from an automatic pipeline, RNAcmap, as it can provide significantly more homologous sequences than manually annotated Rfam. We demonstrate that the resulting unsupervised, two-dimensional attention maps and one-dimensional embeddings from RNA-MSM contain structural information. In fact, they can be directly mapped with high accuracy to 2D base pairing probabilities and 1D solvent accessibilities, respectively. Further fine-tuning led to significantly improved performance on these two downstream tasks compared with existing state-of-the-art techniques including SPOT-RNA2 and RNAsnap2. By comparison, RNA-FM, a BERT-based RNA language model, performs worse than one-hot encoding with its embedding in base pair and solvent-accessible surface area prediction. We anticipate that the pre-trained RNA-MSM model can be fine-tuned on many other tasks related to RNA structure and function.}\",\n    issn = {0305-1048},\n    doi = {10.1093/nar/gkad1031},\n    url = {https://doi.org/10.1093/nar/gkad1031},\n    eprint = {https://academic.oup.com/nar/article-pdf/52/1/e3/55443207/gkad1031.pdf},\n}\n</code></pre>"},{"location":"models/rnamsm/#contact","title":"Contact","text":"<p>Please use GitHub issues of MultiMolecule for any questions or comments on the model card.</p> <p>Please contact the authors of the RNA-MSM paper for questions or comments on the paper/model.</p>"},{"location":"models/rnamsm/#license","title":"License","text":"<p>This model is licensed under the AGPL-3.0 License.</p> Text Only<pre><code>SPDX-License-Identifier: AGPL-3.0-or-later\n</code></pre>"},{"location":"models/rnamsm/#multimolecule.models.rnamsm","title":"<code>multimolecule.models.rnamsm</code>","text":""},{"location":"models/rnamsm/#multimolecule.models.rnamsm.RnaTokenizer","title":"<code>RnaTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>Constructs an RNA tokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>alphabet</code> <code>List[str] | None</code> <p>List of tokens to use. Defaults to IUPAC nucleotide code.</p> <code>None</code> <code>nmers</code> <code>int</code> <p>Size of nmers to tokenize. Defaults to 1.</p> <code>1</code> <code>codon</code> <code>bool</code> <p>Whether to tokenize into codons. Defaults to False.</p> <code>False</code> <code>replace_T_with_U</code> <code>bool</code> <p>Whether to replace T with U. Defaults to True.</p> <code>True</code> <code>do_upper_case</code> <code>bool</code> <p>Whether to convert input to uppercase. Defaults to True.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaTokenizer\n&gt;&gt;&gt; tokenizer = RnaTokenizer()\n&gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n[1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n&gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 3, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 17, 64, 49, 96, 84, 22, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 49, 22, 2]\n&gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\nTraceback (most recent call last):\nValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n</code></pre> Source code in <code>multimolecule/tokenisers/rna/tokenization_rna.py</code> Python<pre><code>class RnaTokenizer(Tokenizer):\n    \"\"\"\n    Constructs an RNA tokenizer.\n\n    Args:\n        alphabet (List[str] | None, optional): List of tokens to use.\n            Defaults to [IUPAC nucleotide code](https://www.bioinformatics.org/sms2/iupac.html).\n        nmers (int, optional): Size of nmers to tokenize.\n            Defaults to 1.\n        codon (bool, optional): Whether to tokenize into codons.\n            Defaults to False.\n        replace_T_with_U (bool, optional): Whether to replace T with U.\n            Defaults to True.\n        do_upper_case (bool, optional): Whether to convert input to uppercase.\n            Defaults to True.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaTokenizer\n        &gt;&gt;&gt; tokenizer = RnaTokenizer()\n        &gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n        [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n        &gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 3, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 17, 64, 49, 96, 84, 22, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 49, 22, 2]\n        &gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\n        Traceback (most recent call last):\n        ValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n    \"\"\"\n\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n\n    def __init__(\n        self,\n        alphabet: List[str] | None = None,\n        nmers: int = 1,\n        codon: bool = False,\n        replace_T_with_U: bool = True,\n        bos_token: str = \"&lt;cls&gt;\",\n        cls_token: str = \"&lt;cls&gt;\",\n        pad_token: str = \"&lt;pad&gt;\",\n        eos_token: str = \"&lt;eos&gt;\",\n        sep_token: str = \"&lt;eos&gt;\",\n        unk_token: str = \"&lt;unk&gt;\",\n        mask_token: str = \"&lt;mask&gt;\",\n        additional_special_tokens: List | Tuple | None = None,\n        do_upper_case: bool = True,\n        **kwargs,\n    ):\n        if codon and nmers &gt; 1:\n            raise ValueError(\"Codon and nmers cannot be used together.\")\n        if codon:\n            nmers = 3  # set to 3 to get correct vocab\n        super().__init__(\n            alphabet=get_vocab_list(alphabet, nmers),\n            bos_token=bos_token,\n            cls_token=cls_token,\n            pad_token=pad_token,\n            eos_token=eos_token,\n            sep_token=sep_token,\n            unk_token=unk_token,\n            mask_token=mask_token,\n            additional_special_tokens=additional_special_tokens,\n            do_upper_case=do_upper_case,\n            **kwargs,\n        )\n        self.replace_T_with_U = replace_T_with_U\n        self.nmers = nmers\n        self.condon = codon\n\n    def _tokenize(self, text: str, **kwargs):\n        if self.do_upper_case:\n            text = text.upper()\n        if self.replace_T_with_U:\n            text = text.replace(\"T\", \"U\")\n        if self.condon:\n            if len(text) % 3 != 0:\n                raise ValueError(\n                    f\"length of input sequence  must be a multiple of 3 for codon tokenization, but got {len(text)}\"\n                )\n            return [text[i : i + 3] for i in range(0, len(text), 3)]\n        if self.nmers &gt; 1:\n            return [text[i : i + self.nmers] for i in range(len(text) - self.nmers + 1)]  # noqa: E203\n        return list(text)\n</code></pre>"},{"location":"models/rnamsm/#multimolecule.models.rnamsm.RnaMsmConfig","title":"<code>RnaMsmConfig</code>","text":"<p>               Bases: <code>PreTrainedConfig</code></p> <p>This is the configuration class to store the configuration of a [<code>RnaMsmModel</code>]. It is used to instantiate a RnaMsm model according to the specified arguments, defining the model architecture. Instantiating a configuration with the defaults will yield a similar configuration to that of the RnaMsm yikunpku/RNA-MSM architecture.</p> <p>Configuration objects inherit from [<code>PreTrainedConfig</code>] and can be used to control the model outputs. Read the documentation from [<code>PreTrainedConfig</code>] for more information.</p> <p>Parameters:</p> Name Type Description Default <code>vocab_size</code> <code>`int`, *optional*, defaults to 26</code> <p>Vocabulary size of the RnaMsm model. Defines the number of different tokens that can be represented by the <code>inputs_ids</code> passed when calling [<code>RnaMsmModel</code>].</p> <code>26</code> <code>hidden_size</code> <code>`int`, *optional*, defaults to 768</code> <p>Dimensionality of the encoder layers and the pooler layer.</p> <code>768</code> <code>num_hidden_layers</code> <code>`int`, *optional*, defaults to 10</code> <p>Number of hidden layers in the Transformer encoder.</p> <code>10</code> <code>num_attention_heads</code> <code>`int`, *optional*, defaults to 12</code> <p>Number of attention heads for each attention layer in the Transformer encoder.</p> <code>12</code> <code>intermediate_size</code> <code>`int`, *optional*, defaults to 3072</code> <p>Dimensionality of the \u201cintermediate\u201d (often named feed-forward) layer in the Transformer encoder.</p> <code>3072</code> <code>hidden_dropout</code> <code>`float`, *optional*, defaults to 0.1</code> <p>The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.</p> <code>0.1</code> <code>attention_dropout</code> <code>`float`, *optional*, defaults to 0.1</code> <p>The dropout ratio for the attention probabilities.</p> <code>0.1</code> <code>max_position_embeddings</code> <code>`int`, *optional*, defaults to 1024</code> <p>The maximum sequence length that this model might ever be used with. Typically set this to something large just in case (e.g., 512 or 1024 or 2048).</p> <code>1024</code> <code>initializer_range</code> <code>`float`, *optional*, defaults to 0.02</code> <p>The standard deviation of the truncated_normal_initializer for initializing all weight matrices.</p> <code>0.02</code> <code>layer_norm_eps</code> <code>`float`, *optional*, defaults to 1e-12</code> <p>The epsilon used by the layer normalization layers.</p> <code>1e-12</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaMsmModel, RnaMsmConfig\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a RNA-MSM multimolecule/rnamsm style configuration\n&gt;&gt;&gt; configuration = RnaMsmConfig()\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/rnamsm style configuration\n&gt;&gt;&gt; model = RnaMsmModel(configuration)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Accessing the model configuration\n&gt;&gt;&gt; configuration = model.config\n</code></pre> Source code in <code>multimolecule/models/rnamsm/configuration_rnamsm.py</code> Python<pre><code>class RnaMsmConfig(PreTrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`RnaMsmModel`]. It is used to instantiate a\n    RnaMsm model according to the specified arguments, defining the model architecture. Instantiating a configuration\n    with the defaults will yield a similar configuration to that of the RnaMsm\n    [yikunpku/RNA-MSM](https://github.com/yikunpku/RNA-MSM) architecture.\n\n    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n    documentation from [`PreTrainedConfig`] for more information.\n\n\n    Args:\n        vocab_size (`int`, *optional*, defaults to 26):\n            Vocabulary size of the RnaMsm model. Defines the number of different tokens that can be represented by the\n            `inputs_ids` passed when calling [`RnaMsmModel`].\n        hidden_size (`int`, *optional*, defaults to 768):\n            Dimensionality of the encoder layers and the pooler layer.\n        num_hidden_layers (`int`, *optional*, defaults to 10):\n            Number of hidden layers in the Transformer encoder.\n        num_attention_heads (`int`, *optional*, defaults to 12):\n            Number of attention heads for each attention layer in the Transformer encoder.\n        intermediate_size (`int`, *optional*, defaults to 3072):\n            Dimensionality of the \"intermediate\" (often named feed-forward) layer in the Transformer encoder.\n        hidden_dropout (`float`, *optional*, defaults to 0.1):\n            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n        attention_dropout (`float`, *optional*, defaults to 0.1):\n            The dropout ratio for the attention probabilities.\n        max_position_embeddings (`int`, *optional*, defaults to 1024):\n            The maximum sequence length that this model might ever be used with. Typically set this to something large\n            just in case (e.g., 512 or 1024 or 2048).\n        initializer_range (`float`, *optional*, defaults to 0.02):\n            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n        layer_norm_eps (`float`, *optional*, defaults to 1e-12):\n            The epsilon used by the layer normalization layers.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaMsmModel, RnaMsmConfig\n\n        &gt;&gt;&gt; # Initializing a RNA-MSM multimolecule/rnamsm style configuration\n        &gt;&gt;&gt; configuration = RnaMsmConfig()\n\n        &gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/rnamsm style configuration\n        &gt;&gt;&gt; model = RnaMsmModel(configuration)\n\n        &gt;&gt;&gt; # Accessing the model configuration\n        &gt;&gt;&gt; configuration = model.config\n    \"\"\"\n\n    model_type = \"rnamsm\"\n\n    def __init__(\n        self,\n        vocab_size=26,\n        hidden_size=768,\n        num_hidden_layers=10,\n        num_attention_heads=12,\n        intermediate_size=3072,\n        hidden_act=\"gelu\",\n        hidden_dropout=0.1,\n        attention_dropout=0.1,\n        max_position_embeddings=1024,\n        initializer_range=0.02,\n        layer_norm_eps=1e-12,\n        position_embedding_type=\"absolute\",\n        use_cache=True,\n        max_tokens_per_msa=2**14,\n        layer_type=\"standard\",\n        attention_type=\"standard\",\n        embed_positions_msa=True,\n        attention_bias=True,\n        head=None,\n        lm_head=None,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n\n        self.vocab_size = vocab_size\n        self.hidden_size = hidden_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_attention_heads = num_attention_heads\n        self.intermediate_size = intermediate_size\n        self.hidden_act = hidden_act\n        self.hidden_dropout = hidden_dropout\n        self.attention_dropout = attention_dropout\n        self.max_position_embeddings = max_position_embeddings\n        self.initializer_range = initializer_range\n        self.layer_norm_eps = layer_norm_eps\n        self.position_embedding_type = position_embedding_type\n        self.use_cache = use_cache\n        self.max_tokens_per_msa = max_tokens_per_msa\n        self.layer_type = layer_type\n        self.attention_type = attention_type\n        self.embed_positions_msa = embed_positions_msa\n        self.attention_bias = attention_bias\n        self.head = HeadConfig(**head if head is not None else {})\n        self.lm_head = MaskedLMHeadConfig(**lm_head if lm_head is not None else {})\n</code></pre>"},{"location":"models/rnamsm/#multimolecule.models.rnamsm.RnaMsmForMaskedLM","title":"<code>RnaMsmForMaskedLM</code>","text":"<p>               Bases: <code>RnaMsmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaMsmConfig, RnaMsmForMaskedLM, RnaTokenizer\n&gt;&gt;&gt; config = RnaMsmConfig()\n&gt;&gt;&gt; model = RnaMsmForMaskedLM(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 26])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/rnamsm/modeling_rnamsm.py</code> Python<pre><code>class RnaMsmForMaskedLM(RnaMsmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaMsmConfig, RnaMsmForMaskedLM, RnaTokenizer\n        &gt;&gt;&gt; config = RnaMsmConfig()\n        &gt;&gt;&gt; model = RnaMsmForMaskedLM(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 26])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: RnaMsmConfig):\n        super().__init__(config)\n        self.rnamsm = RnaMsmModel(config, add_pooling_layer=False)\n        self.lm_head = MaskedLMHead(config, weight=self.rnamsm.embeddings.word_embeddings.weight)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | RnaMsmForMaskedLMOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rnamsm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.lm_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return RnaMsmForMaskedLMOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            col_attentions=outputs.col_attentions,\n            row_attentions=outputs.row_attentions,\n        )\n</code></pre>"},{"location":"models/rnamsm/#multimolecule.models.rnamsm.RnaMsmForNucleotidePrediction","title":"<code>RnaMsmForNucleotidePrediction</code>","text":"<p>               Bases: <code>RnaMsmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaMsmConfig, RnaMsmForNucleotidePrediction, RnaTokenizer\n&gt;&gt;&gt; config = RnaMsmConfig()\n&gt;&gt;&gt; model = RnaMsmForNucleotidePrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 5, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/rnamsm/modeling_rnamsm.py</code> Python<pre><code>class RnaMsmForNucleotidePrediction(RnaMsmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaMsmConfig, RnaMsmForNucleotidePrediction, RnaTokenizer\n        &gt;&gt;&gt; config = RnaMsmConfig()\n        &gt;&gt;&gt; model = RnaMsmForNucleotidePrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 5, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: RnaMsmConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.rnamsm = RnaMsmModel(config, add_pooling_layer=True)\n        self.nucleotide_head = NucleotidePredictionHead(config)\n        self.head_config = self.nucleotide_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool = False,\n        output_hidden_states: bool = False,\n        return_dict: bool = True,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | RnaMsmNucleotidePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rnamsm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.nucleotide_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return RnaMsmNucleotidePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            col_attentions=outputs.col_attentions,\n            row_attentions=outputs.row_attentions,\n        )\n</code></pre>"},{"location":"models/rnamsm/#multimolecule.models.rnamsm.RnaMsmForPreTraining","title":"<code>RnaMsmForPreTraining</code>","text":"<p>               Bases: <code>RnaMsmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaMsmConfig, RnaMsmForPreTraining, RnaTokenizer\n&gt;&gt;&gt; config = RnaMsmConfig()\n&gt;&gt;&gt; model = RnaMsmForPreTraining(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels_mlm=input[\"input_ids\"])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;AddBackward0&gt;)\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 26])\n&gt;&gt;&gt; output[\"contact_map\"].shape\ntorch.Size([1, 5, 5, 2])\n</code></pre> Source code in <code>multimolecule/models/rnamsm/modeling_rnamsm.py</code> Python<pre><code>class RnaMsmForPreTraining(RnaMsmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaMsmConfig, RnaMsmForPreTraining, RnaTokenizer\n        &gt;&gt;&gt; config = RnaMsmConfig()\n        &gt;&gt;&gt; model = RnaMsmForPreTraining(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels_mlm=input[\"input_ids\"])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;AddBackward0&gt;)\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 26])\n        &gt;&gt;&gt; output[\"contact_map\"].shape\n        torch.Size([1, 5, 5, 2])\n    \"\"\"\n\n    def __init__(self, config: RnaMsmConfig):\n        super().__init__(config)\n        self.rnamsm = RnaMsmModel(config, add_pooling_layer=False)\n        self.pretrain_head = RnaMsmPreTrainingHeads(config, weight=self.rnamsm.embeddings.word_embeddings.weight)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels_mlm: Tensor | None = None,\n        labels_contact: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | RnaMsmForPreTrainingOutput:\n        if output_attentions is False:\n            warn(\"output_attentions must be True for contact classification and will be ignored.\")\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rnamsm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            inputs_embeds=inputs_embeds,\n            output_attentions=True,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        total_loss, logits, contact_map = self.pretrain_head(\n            outputs, attention_mask, input_ids, labels_mlm=labels_mlm, labels_contact=labels_contact\n        )\n\n        if not return_dict:\n            output = (logits, contact_map) + outputs[2:]\n            return ((total_loss,) + output) if total_loss is not None else output\n\n        return RnaMsmForPreTrainingOutput(\n            loss=total_loss,\n            logits=logits,\n            contact_map=contact_map,\n            hidden_states=outputs.hidden_states,\n            col_attentions=outputs.col_attentions,\n            row_attentions=outputs.row_attentions,\n        )\n</code></pre>"},{"location":"models/rnamsm/#multimolecule.models.rnamsm.RnaMsmForSequencePrediction","title":"<code>RnaMsmForSequencePrediction</code>","text":"<p>               Bases: <code>RnaMsmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaMsmConfig, RnaMsmForSequencePrediction, RnaTokenizer\n&gt;&gt;&gt; config = RnaMsmConfig()\n&gt;&gt;&gt; model = RnaMsmForSequencePrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.tensor([[1]]))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/rnamsm/modeling_rnamsm.py</code> Python<pre><code>class RnaMsmForSequencePrediction(RnaMsmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaMsmConfig, RnaMsmForSequencePrediction, RnaTokenizer\n        &gt;&gt;&gt; config = RnaMsmConfig()\n        &gt;&gt;&gt; model = RnaMsmForSequencePrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.tensor([[1]]))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: RnaMsmConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.rnamsm = RnaMsmModel(config, add_pooling_layer=True)\n        self.sequence_head = SequencePredictionHead(config)\n        self.head_config = self.sequence_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool = False,\n        output_hidden_states: bool = False,\n        return_dict: bool = True,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | RnaMsmSequencePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rnamsm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.sequence_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return RnaMsmSequencePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            col_attentions=outputs.col_attentions,\n            row_attentions=outputs.row_attentions,\n        )\n</code></pre>"},{"location":"models/rnamsm/#multimolecule.models.rnamsm.RnaMsmForTokenPrediction","title":"<code>RnaMsmForTokenPrediction</code>","text":"<p>               Bases: <code>RnaMsmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaMsmConfig, RnaMsmForTokenPrediction, RnaTokenizer\n&gt;&gt;&gt; config = RnaMsmConfig()\n&gt;&gt;&gt; model = RnaMsmForTokenPrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/rnamsm/modeling_rnamsm.py</code> Python<pre><code>class RnaMsmForTokenPrediction(RnaMsmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaMsmConfig, RnaMsmForTokenPrediction, RnaTokenizer\n        &gt;&gt;&gt; config = RnaMsmConfig()\n        &gt;&gt;&gt; model = RnaMsmForTokenPrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: RnaMsmConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.rnamsm = RnaMsmModel(config, add_pooling_layer=True)\n        self.token_head = TokenPredictionHead(config)\n        self.head_config = self.token_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool = False,\n        output_hidden_states: bool = False,\n        return_dict: bool = True,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | RnaMsmTokenPredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.rnamsm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.token_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return RnaMsmTokenPredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            col_attentions=outputs.col_attentions,\n            row_attentions=outputs.row_attentions,\n        )\n</code></pre>"},{"location":"models/rnamsm/#multimolecule.models.rnamsm.RnaMsmModel","title":"<code>RnaMsmModel</code>","text":"<p>               Bases: <code>RnaMsmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaMsmConfig, RnaMsmModel, RnaTokenizer\n&gt;&gt;&gt; config = RnaMsmConfig()\n&gt;&gt;&gt; model = RnaMsmModel(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input)\n&gt;&gt;&gt; output[\"last_hidden_state\"].shape\ntorch.Size([1, 7, 768])\n&gt;&gt;&gt; output[\"pooler_output\"].shape\ntorch.Size([1, 768])\n</code></pre> Source code in <code>multimolecule/models/rnamsm/modeling_rnamsm.py</code> Python<pre><code>class RnaMsmModel(RnaMsmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaMsmConfig, RnaMsmModel, RnaTokenizer\n        &gt;&gt;&gt; config = RnaMsmConfig()\n        &gt;&gt;&gt; model = RnaMsmModel(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input)\n        &gt;&gt;&gt; output[\"last_hidden_state\"].shape\n        torch.Size([1, 7, 768])\n        &gt;&gt;&gt; output[\"pooler_output\"].shape\n        torch.Size([1, 768])\n    \"\"\"\n\n    def __init__(self, config: RnaMsmConfig, add_pooling_layer: bool = True):\n        super().__init__(config)\n        self.pad_token_id = config.pad_token_id\n        self.embeddings = RnaMsmEmbeddings(config)\n        self.encoder = RnaMsmEncoder(config)\n        self.pooler = RnaMsmPooler(config) if add_pooling_layer else None\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | RnaMsmModelOutputWithPooling:\n        if kwargs:\n            warn(\n                f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n                f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n                \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n            )\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        if isinstance(input_ids, NestedTensor):\n            input_ids, attention_mask = input_ids.tensor, input_ids.mask\n        if input_ids is not None and inputs_embeds is not None:\n            raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n        if input_ids is not None:\n            self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n        elif inputs_embeds is None:\n            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n        if attention_mask is None:\n            attention_mask = (\n                input_ids.ne(self.pad_token_id) if self.pad_token_id is not None else torch.ones_like(input_ids)\n            )\n\n        unsqueeze_input = input_ids.ndim == 2\n        if unsqueeze_input:\n            input_ids = input_ids.unsqueeze(1)\n        if attention_mask.ndim == 2:\n            attention_mask = attention_mask.unsqueeze(1)\n\n        embedding_output = self.embeddings(\n            input_ids=input_ids,\n            position_ids=position_ids,\n            attention_mask=attention_mask,\n            inputs_embeds=inputs_embeds,\n        )\n        encoder_outputs = self.encoder(\n            embedding_output,\n            attention_mask=attention_mask,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n        sequence_output = encoder_outputs[0]\n        if unsqueeze_input:\n            sequence_output = sequence_output.squeeze(1)\n        pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n        if not return_dict:\n            return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n        return RnaMsmModelOutputWithPooling(\n            last_hidden_state=sequence_output,\n            pooler_output=pooled_output,\n            hidden_states=encoder_outputs.hidden_states,\n            col_attentions=encoder_outputs.col_attentions,\n            row_attentions=encoder_outputs.row_attentions,\n        )\n</code></pre>"},{"location":"models/rnamsm/#multimolecule.models.rnamsm.RnaMsmPreTrainedModel","title":"<code>RnaMsmPreTrainedModel</code>","text":"<p>               Bases: <code>PreTrainedModel</code></p> <p>An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained models.</p> Source code in <code>multimolecule/models/rnamsm/modeling_rnamsm.py</code> Python<pre><code>class RnaMsmPreTrainedModel(PreTrainedModel):\n    \"\"\"\n    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n    models.\n    \"\"\"\n\n    config_class = RnaMsmConfig\n    base_model_prefix = \"rnamsm\"\n    supports_gradient_checkpointing = True\n    _no_split_modules = [\"RnaMsmLayer\", \"RnaMsmAxialLayer\", \"RnaMsmPkmLayer\", \"RnaMsmEmbeddings\"]\n\n    # Copied from transformers.models.bert.modeling_bert.BertPreTrainedModel._init_weights\n    def _init_weights(self, module: nn.Module):\n        \"\"\"Initialize the weights\"\"\"\n        if isinstance(module, nn.Linear):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, nn.Embedding):\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.padding_idx is not None:\n                module.weight.data[module.padding_idx].zero_()\n        elif isinstance(module, nn.LayerNorm) and module.elementwise_affine:\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n</code></pre>"},{"location":"models/splicebert/","title":"SpliceBERT","text":"<p>Pre-trained model on messenger RNA precursor (pre-mRNA) using a masked language modeling (MLM) objective.</p>"},{"location":"models/splicebert/#disclaimer","title":"Disclaimer","text":"<p>This is an UNOFFICIAL implementation of the Self-supervised learning on millions of pre-mRNA sequences improves sequence-based RNA splicing prediction by Ken Chen, et al.</p> <p>The OFFICIAL repository of SpliceBERT is at chenkenbio/SpliceBERT.</p> <p>The team releasing SpliceBERT did not write this model card for this model so this model card has been written by the MultiMolecule team.</p>"},{"location":"models/splicebert/#model-details","title":"Model Details","text":"<p>SpliceBERT is a bert-style model pre-trained on a large corpus of messenger RNA precursor sequences in a self-supervised fashion. This means that the model was trained on the raw nucleotides of RNA sequences only, with an automatic process to generate inputs and labels from those texts. Please refer to the Training Details section for more information on the training process.</p>"},{"location":"models/splicebert/#variations","title":"Variations","text":"<ul> <li><code>multimolecule/splicebert</code>: The SpliceBERT model.</li> <li><code>multimolecule/splicebert.510nt</code>: The intermediate SpliceBERT model.</li> <li><code>multimolecule/splicebert-human.510nt</code>: The intermediate SpliceBERT model pre-trained on human data only.</li> </ul>"},{"location":"models/splicebert/#model-specification","title":"Model Specification","text":"Variants Num Layers Hidden Size Num Heads Intermediate Size Num Parameters (M) FLOPs (G) MACs (G) Max Num Tokens splicebert 6 512 16 2048 19.72 5.04 2.52 1024 splicebert.510nt 19.45 510 splicebert-human.510nt"},{"location":"models/splicebert/#links","title":"Links","text":"<ul> <li>Code: multimolecule.splicebert</li> <li>Data: UCSC Genome Browser</li> <li>Paper: Self-supervised learning on millions of pre-mRNA sequences improves sequence-based RNA splicing prediction</li> <li>Developed by: Ken Chen, Yue Zhou, Maolin Ding, Yu Wang, Zhixiang Ren, Yuedong Yang</li> <li>Model type: BERT - FlashAttention</li> <li>Original Repository: https://github.com/chenkenbio/SpliceBERT</li> </ul>"},{"location":"models/splicebert/#usage","title":"Usage","text":"<p>The model file depends on the <code>multimolecule</code> library. You can install it using pip:</p> Bash<pre><code>pip install multimolecule\n</code></pre>"},{"location":"models/splicebert/#direct-use","title":"Direct Use","text":"<p>You can use this model directly with a pipeline for masked language modeling:</p> Python<pre><code>&gt;&gt;&gt; import multimolecule  # you must import multimolecule to register models\n&gt;&gt;&gt; from transformers import pipeline\n&gt;&gt;&gt; unmasker = pipeline('fill-mask', model='multimolecule/splicebert')\n&gt;&gt;&gt; unmasker(\"uagc&lt;mask&gt;uaucagacugauguuga\")\n\n[{'score': 0.09628374129533768,\n  'token': 6,\n  'token_str': 'A',\n  'sequence': 'U A G C A U A U C A G A C U G A U G U U G A'},\n {'score': 0.09019321203231812,\n  'token': 19,\n  'token_str': 'W',\n  'sequence': 'U A G C W U A U C A G A C U G A U G U U G A'},\n {'score': 0.08448788523674011,\n  'token': 9,\n  'token_str': 'U',\n  'sequence': 'U A G C U U A U C A G A C U G A U G U U G A'},\n {'score': 0.07201363891363144,\n  'token': 14,\n  'token_str': 'H',\n  'sequence': 'U A G C H U A U C A G A C U G A U G U U G A'},\n {'score': 0.06648518145084381,\n  'token': 17,\n  'token_str': 'M',\n  'sequence': 'U A G C M U A U C A G A C U G A U G U U G A'}]\n</code></pre>"},{"location":"models/splicebert/#downstream-use","title":"Downstream Use","text":""},{"location":"models/splicebert/#extract-features","title":"Extract Features","text":"<p>Here is how to use this model to get the features of a given sequence in PyTorch:</p> Python<pre><code>from multimolecule import RnaTokenizer, SpliceBertModel\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/splicebert')\nmodel = SpliceBertModel.from_pretrained('multimolecule/splicebert')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\n\noutput = model(**input)\n</code></pre>"},{"location":"models/splicebert/#sequence-classification-regression","title":"Sequence Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for sequence classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a sequence-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, SpliceBertForSequencePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/splicebert')\nmodel = SpliceBertForSequencePrediction.from_pretrained('multimolecule/splicebert')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.tensor([1])\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/splicebert/#nucleotide-classification-regression","title":"Nucleotide Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for nucleotide classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a nucleotide-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, SpliceBertForNucleotidePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/splicebert')\nmodel = SpliceBertForNucleotidePrediction.from_pretrained('multimolecule/splicebert')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.randint(2, (len(text), ))\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/splicebert/#training-details","title":"Training Details","text":"<p>SpliceBERT used Masked Language Modeling (MLM) as the pre-training objective: taking a sequence, the model randomly masks 15% of the tokens in the input then runs the entire masked sentence through the model and has to predict the masked tokens. This is comparable to the Cloze task in language modeling.</p>"},{"location":"models/splicebert/#training-data","title":"Training Data","text":"<p>The SpliceBERT model was pre-trained on messenger RNA precursor sequences from UCSC Genome Browser. UCSC Genome Browser provides visualization, analysis, and download of comprehensive vertebrate genome data with aligned annotation tracks (known genes, predicted genes, ESTs, mRNAs, CpG islands, etc.).</p> <p>SpliceBERT collected reference genomes and gene annotations from the UCSC Genome Browser for 72 vertebrate species. It applied bedtools getfasta to extract pre-mRNA sequences from the reference genomes based on the gene annotations. The pre-mRNA sequences are then used to pre-train SpliceBERT. The pre-training data contains 2 million pre-mRNA sequences with a total length of 65 billion nucleotides.</p> <p>Note <code>RnaTokenizer</code> will convert \u201cT\u201ds to \u201cU\u201ds for you, you may disable this behaviour by passing <code>replace_T_with_U=False</code>.</p>"},{"location":"models/splicebert/#training-procedure","title":"Training Procedure","text":""},{"location":"models/splicebert/#preprocessing","title":"Preprocessing","text":"<p>SpliceBERT used masked language modeling (MLM) as the pre-training objective. The masking procedure is similar to the one used in BERT:</p> <ul> <li>15% of the tokens are masked.</li> <li>In 80% of the cases, the masked tokens are replaced by <code>&lt;mask&gt;</code>.</li> <li>In 10% of the cases, the masked tokens are replaced by a random token (different) from the one they replace.</li> <li>In the 10% remaining cases, the masked tokens are left as is.</li> </ul>"},{"location":"models/splicebert/#pretraining","title":"PreTraining","text":"<p>The model was trained on 8 NVIDIA V100 GPUs.</p> <ul> <li>Learning rate: 1e-4</li> <li>Learning rate scheduler: ReduceLROnPlateau(patience=3)</li> <li>Optimizer: AdamW</li> </ul> <p>SpliceBERT trained model in a two-stage training process:</p> <ol> <li>Pre-train with sequences of a fixed length of 510 nucleotides.</li> <li>Pre-train with sequences of a variable length between 64 and 1024 nucleotides.</li> </ol> <p>The intermediate model after the first stage is available as <code>multimolecule/splicebert.510nt</code>.</p> <p>SpliceBERT also pre-trained a model on human data only to validate the contribution of multi-species pre-training. The intermediate model after the first stage is available as <code>multimolecule/splicebert-human.510nt</code>.</p>"},{"location":"models/splicebert/#citation","title":"Citation","text":"<p>BibTeX:</p> BibTeX<pre><code>@article {chen2023self,\n    author = {Chen, Ken and Zhou, Yue and Ding, Maolin and Wang, Yu and Ren, Zhixiang and Yang, Yuedong},\n    title = {Self-supervised learning on millions of pre-mRNA sequences improves sequence-based RNA splicing prediction},\n    elocation-id = {2023.01.31.526427},\n    year = {2023},\n    doi = {10.1101/2023.01.31.526427},\n    publisher = {Cold Spring Harbor Laboratory},\n    abstract = {RNA splicing is an important post-transcriptional process of gene expression in eukaryotic cells. Predicting RNA splicing from primary sequences can facilitate the interpretation of genomic variants. In this study, we developed a novel self-supervised pre-trained language model, SpliceBERT, to improve sequence-based RNA splicing prediction. Pre-training on pre-mRNA sequences from vertebrates enables SpliceBERT to capture evolutionary conservation information and characterize the unique property of splice sites. SpliceBERT also improves zero-shot prediction of variant effects on splicing by considering sequence context information, and achieves superior performance for predicting branchpoint in the human genome and splice sites across species. Our study highlighted the importance of pre-training genomic language models on a diverse range of species and suggested that pre-trained language models were promising for deciphering the sequence logic of RNA splicing.Competing Interest StatementThe authors have declared no competing interest.},\n    URL = {https://www.biorxiv.org/content/early/2023/05/09/2023.01.31.526427},\n    eprint = {https://www.biorxiv.org/content/early/2023/05/09/2023.01.31.526427.full.pdf},\n    journal = {bioRxiv}\n}\n</code></pre>"},{"location":"models/splicebert/#contact","title":"Contact","text":"<p>Please use GitHub issues of MultiMolecule for any questions or comments on the model card.</p> <p>Please contact the authors of the SpliceBERT paper for questions or comments on the paper/model.</p>"},{"location":"models/splicebert/#license","title":"License","text":"<p>This model is licensed under the AGPL-3.0 License.</p> Text Only<pre><code>SPDX-License-Identifier: AGPL-3.0-or-later\n</code></pre>"},{"location":"models/splicebert/#multimolecule.models.splicebert","title":"<code>multimolecule.models.splicebert</code>","text":""},{"location":"models/splicebert/#multimolecule.models.splicebert.RnaTokenizer","title":"<code>RnaTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>Constructs an RNA tokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>alphabet</code> <code>List[str] | None</code> <p>List of tokens to use. Defaults to IUPAC nucleotide code.</p> <code>None</code> <code>nmers</code> <code>int</code> <p>Size of nmers to tokenize. Defaults to 1.</p> <code>1</code> <code>codon</code> <code>bool</code> <p>Whether to tokenize into codons. Defaults to False.</p> <code>False</code> <code>replace_T_with_U</code> <code>bool</code> <p>Whether to replace T with U. Defaults to True.</p> <code>True</code> <code>do_upper_case</code> <code>bool</code> <p>Whether to convert input to uppercase. Defaults to True.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaTokenizer\n&gt;&gt;&gt; tokenizer = RnaTokenizer()\n&gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n[1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n&gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 3, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 17, 64, 49, 96, 84, 22, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 49, 22, 2]\n&gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\nTraceback (most recent call last):\nValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n</code></pre> Source code in <code>multimolecule/tokenisers/rna/tokenization_rna.py</code> Python<pre><code>class RnaTokenizer(Tokenizer):\n    \"\"\"\n    Constructs an RNA tokenizer.\n\n    Args:\n        alphabet (List[str] | None, optional): List of tokens to use.\n            Defaults to [IUPAC nucleotide code](https://www.bioinformatics.org/sms2/iupac.html).\n        nmers (int, optional): Size of nmers to tokenize.\n            Defaults to 1.\n        codon (bool, optional): Whether to tokenize into codons.\n            Defaults to False.\n        replace_T_with_U (bool, optional): Whether to replace T with U.\n            Defaults to True.\n        do_upper_case (bool, optional): Whether to convert input to uppercase.\n            Defaults to True.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaTokenizer\n        &gt;&gt;&gt; tokenizer = RnaTokenizer()\n        &gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n        [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n        &gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 3, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 17, 64, 49, 96, 84, 22, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 49, 22, 2]\n        &gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\n        Traceback (most recent call last):\n        ValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n    \"\"\"\n\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n\n    def __init__(\n        self,\n        alphabet: List[str] | None = None,\n        nmers: int = 1,\n        codon: bool = False,\n        replace_T_with_U: bool = True,\n        bos_token: str = \"&lt;cls&gt;\",\n        cls_token: str = \"&lt;cls&gt;\",\n        pad_token: str = \"&lt;pad&gt;\",\n        eos_token: str = \"&lt;eos&gt;\",\n        sep_token: str = \"&lt;eos&gt;\",\n        unk_token: str = \"&lt;unk&gt;\",\n        mask_token: str = \"&lt;mask&gt;\",\n        additional_special_tokens: List | Tuple | None = None,\n        do_upper_case: bool = True,\n        **kwargs,\n    ):\n        if codon and nmers &gt; 1:\n            raise ValueError(\"Codon and nmers cannot be used together.\")\n        if codon:\n            nmers = 3  # set to 3 to get correct vocab\n        super().__init__(\n            alphabet=get_vocab_list(alphabet, nmers),\n            bos_token=bos_token,\n            cls_token=cls_token,\n            pad_token=pad_token,\n            eos_token=eos_token,\n            sep_token=sep_token,\n            unk_token=unk_token,\n            mask_token=mask_token,\n            additional_special_tokens=additional_special_tokens,\n            do_upper_case=do_upper_case,\n            **kwargs,\n        )\n        self.replace_T_with_U = replace_T_with_U\n        self.nmers = nmers\n        self.condon = codon\n\n    def _tokenize(self, text: str, **kwargs):\n        if self.do_upper_case:\n            text = text.upper()\n        if self.replace_T_with_U:\n            text = text.replace(\"T\", \"U\")\n        if self.condon:\n            if len(text) % 3 != 0:\n                raise ValueError(\n                    f\"length of input sequence  must be a multiple of 3 for codon tokenization, but got {len(text)}\"\n                )\n            return [text[i : i + 3] for i in range(0, len(text), 3)]\n        if self.nmers &gt; 1:\n            return [text[i : i + self.nmers] for i in range(len(text) - self.nmers + 1)]  # noqa: E203\n        return list(text)\n</code></pre>"},{"location":"models/splicebert/#multimolecule.models.splicebert.SpliceBertConfig","title":"<code>SpliceBertConfig</code>","text":"<p>               Bases: <code>PreTrainedConfig</code></p> <p>This is the configuration class to store the configuration of a [<code>SpliceBertModel</code>]. It is used to instantiate a SpliceBert model according to the specified arguments, defining the model architecture. Instantiating a configuration with the defaults will yield a similar configuration to that of the SpliceBert biomed-AI/SpliceBERT architecture.</p> <p>Configuration objects inherit from [<code>PreTrainedConfig</code>] and can be used to control the model outputs. Read the documentation from [<code>PreTrainedConfig</code>] for more information.</p> <p>Parameters:</p> Name Type Description Default <code>vocab_size</code> <code>`int`, *optional*, defaults to 26</code> <p>Vocabulary size of the SpliceBert model. Defines the number of different tokens that can be represented by the <code>inputs_ids</code> passed when calling [<code>SpliceBertModel</code>].</p> <code>26</code> <code>hidden_size</code> <code>`int`, *optional*, defaults to 512</code> <p>Dimensionality of the encoder layers and the pooler layer.</p> <code>512</code> <code>num_hidden_layers</code> <code>`int`, *optional*, defaults to 6</code> <p>Number of hidden layers in the Transformer encoder.</p> <code>6</code> <code>num_attention_heads</code> <code>`int`, *optional*, defaults to 16</code> <p>Number of attention heads for each attention layer in the Transformer encoder.</p> <code>16</code> <code>intermediate_size</code> <code>`int`, *optional*, defaults to 2048</code> <p>Dimensionality of the \u201cintermediate\u201d (often named feed-forward) layer in the Transformer encoder.</p> <code>2048</code> <code>hidden_dropout</code> <code>`float`, *optional*, defaults to 0.1</code> <p>The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.</p> <code>0.1</code> <code>attention_dropout</code> <code>`float`, *optional*, defaults to 0.1</code> <p>The dropout ratio for the attention probabilities.</p> <code>0.1</code> <code>max_position_embeddings</code> <code>`int`, *optional*, defaults to 1026</code> <p>The maximum sequence length that this model might ever be used with. Typically set this to something large just in case (e.g., 512 or 1024 or 2048).</p> <code>1026</code> <code>initializer_range</code> <code>`float`, *optional*, defaults to 0.02</code> <p>The standard deviation of the truncated_normal_initializer for initializing all weight matrices.</p> <code>0.02</code> <code>layer_norm_eps</code> <code>`float`, *optional*, defaults to 1e-12</code> <p>The epsilon used by the layer normalization layers.</p> <code>1e-12</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import SpliceBertModel, SpliceBertConfig\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a SpliceBERT multimolecule/splicebert style configuration\n&gt;&gt;&gt; configuration = SpliceBertConfig()\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/splicebert style configuration\n&gt;&gt;&gt; model = SpliceBertModel(configuration)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Accessing the model configuration\n&gt;&gt;&gt; configuration = model.config\n</code></pre> Source code in <code>multimolecule/models/splicebert/configuration_splicebert.py</code> Python<pre><code>class SpliceBertConfig(PreTrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`SpliceBertModel`]. It is used to instantiate a\n    SpliceBert model according to the specified arguments, defining the model architecture. Instantiating a\n    configuration with the defaults will yield a similar configuration to that of the SpliceBert\n    [biomed-AI/SpliceBERT](https://github.com/biomed-AI/SpliceBERT) architecture.\n\n    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n    documentation from [`PreTrainedConfig`] for more information.\n\n\n    Args:\n        vocab_size (`int`, *optional*, defaults to 26):\n            Vocabulary size of the SpliceBert model. Defines the number of different tokens that can be represented by\n            the `inputs_ids` passed when calling [`SpliceBertModel`].\n        hidden_size (`int`, *optional*, defaults to 512):\n            Dimensionality of the encoder layers and the pooler layer.\n        num_hidden_layers (`int`, *optional*, defaults to 6):\n            Number of hidden layers in the Transformer encoder.\n        num_attention_heads (`int`, *optional*, defaults to 16):\n            Number of attention heads for each attention layer in the Transformer encoder.\n        intermediate_size (`int`, *optional*, defaults to 2048):\n            Dimensionality of the \"intermediate\" (often named feed-forward) layer in the Transformer encoder.\n        hidden_dropout (`float`, *optional*, defaults to 0.1):\n            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n        attention_dropout (`float`, *optional*, defaults to 0.1):\n            The dropout ratio for the attention probabilities.\n        max_position_embeddings (`int`, *optional*, defaults to 1026):\n            The maximum sequence length that this model might ever be used with. Typically set this to something large\n            just in case (e.g., 512 or 1024 or 2048).\n        initializer_range (`float`, *optional*, defaults to 0.02):\n            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n        layer_norm_eps (`float`, *optional*, defaults to 1e-12):\n            The epsilon used by the layer normalization layers.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import SpliceBertModel, SpliceBertConfig\n\n        &gt;&gt;&gt; # Initializing a SpliceBERT multimolecule/splicebert style configuration\n        &gt;&gt;&gt; configuration = SpliceBertConfig()\n\n        &gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/splicebert style configuration\n        &gt;&gt;&gt; model = SpliceBertModel(configuration)\n\n        &gt;&gt;&gt; # Accessing the model configuration\n        &gt;&gt;&gt; configuration = model.config\n    \"\"\"\n\n    model_type = \"splicebert\"\n\n    def __init__(\n        self,\n        vocab_size=26,\n        hidden_size=512,\n        num_hidden_layers=6,\n        num_attention_heads=16,\n        intermediate_size=2048,\n        hidden_act=\"gelu\",\n        hidden_dropout=0.1,\n        attention_dropout=0.1,\n        max_position_embeddings=1026,\n        initializer_range=0.02,\n        layer_norm_eps=1e-12,\n        position_embedding_type=\"absolute\",\n        use_cache=True,\n        head=None,\n        lm_head=None,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n\n        self.vocab_size = vocab_size\n        self.type_vocab_size = 2\n        self.hidden_size = hidden_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_attention_heads = num_attention_heads\n        self.intermediate_size = intermediate_size\n        self.hidden_act = hidden_act\n        self.hidden_dropout = hidden_dropout\n        self.attention_dropout = attention_dropout\n        self.max_position_embeddings = max_position_embeddings\n        self.initializer_range = initializer_range\n        self.layer_norm_eps = layer_norm_eps\n        self.position_embedding_type = position_embedding_type\n        self.use_cache = use_cache\n        self.head = HeadConfig(**head if head is not None else {})\n        self.lm_head = MaskedLMHeadConfig(**lm_head if lm_head is not None else {})\n</code></pre>"},{"location":"models/splicebert/#multimolecule.models.splicebert.SpliceBertForMaskedLM","title":"<code>SpliceBertForMaskedLM</code>","text":"<p>               Bases: <code>SpliceBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import SpliceBertConfig, SpliceBertForMaskedLM, RnaTokenizer\n&gt;&gt;&gt; config = SpliceBertConfig()\n&gt;&gt;&gt; model = SpliceBertForMaskedLM(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 26])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/splicebert/modeling_splicebert.py</code> Python<pre><code>class SpliceBertForMaskedLM(SpliceBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import SpliceBertConfig, SpliceBertForMaskedLM, RnaTokenizer\n        &gt;&gt;&gt; config = SpliceBertConfig()\n        &gt;&gt;&gt; model = SpliceBertForMaskedLM(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 26])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    _tied_weights_keys = [\"lm_head.decoder.bias\", \"lm_head.decoder.weight\"]\n\n    def __init__(self, config: SpliceBertConfig):\n        super().__init__(config)\n        if config.is_decoder:\n            logger.warning(\n                \"If you want to use `SpliceBertForMaskedLM` make sure `config.is_decoder=False` for \"\n                \"bi-directional self-attention.\"\n            )\n        self.splicebert = SpliceBertModel(config, add_pooling_layer=False)\n        self.lm_head = MaskedLMHead(config)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_output_embeddings(self):\n        return self.lm_head.decoder\n\n    def set_output_embeddings(self, new_embeddings):\n        self.lm_head.decoder = new_embeddings\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | MaskedLMOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.splicebert(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_attention_mask,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.lm_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return MaskedLMOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/splicebert/#multimolecule.models.splicebert.SpliceBertForNucleotidePrediction","title":"<code>SpliceBertForNucleotidePrediction</code>","text":"<p>               Bases: <code>SpliceBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import SpliceBertConfig, SpliceBertForNucleotidePrediction, RnaTokenizer\n&gt;&gt;&gt; config = SpliceBertConfig()\n&gt;&gt;&gt; model = SpliceBertForNucleotidePrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 5, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/splicebert/modeling_splicebert.py</code> Python<pre><code>class SpliceBertForNucleotidePrediction(SpliceBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import SpliceBertConfig, SpliceBertForNucleotidePrediction, RnaTokenizer\n        &gt;&gt;&gt; config = SpliceBertConfig()\n        &gt;&gt;&gt; model = SpliceBertForNucleotidePrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 5, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: SpliceBertConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.splicebert = SpliceBertModel(config, add_pooling_layer=True)\n        self.nucleotide_head = NucleotidePredictionHead(config)\n        self.head_config = self.nucleotide_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | NucleotidePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.splicebert(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.nucleotide_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return NucleotidePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/splicebert/#multimolecule.models.splicebert.SpliceBertForPreTraining","title":"<code>SpliceBertForPreTraining</code>","text":"<p>               Bases: <code>SpliceBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import SpliceBertConfig, SpliceBertForPreTraining, RnaTokenizer\n&gt;&gt;&gt; config = SpliceBertConfig()\n&gt;&gt;&gt; model = SpliceBertForPreTraining(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input)\n</code></pre> Source code in <code>multimolecule/models/splicebert/modeling_splicebert.py</code> Python<pre><code>class SpliceBertForPreTraining(SpliceBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import SpliceBertConfig, SpliceBertForPreTraining, RnaTokenizer\n        &gt;&gt;&gt; config = SpliceBertConfig()\n        &gt;&gt;&gt; model = SpliceBertForPreTraining(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input)\n    \"\"\"\n\n    _tied_weights_keys = [\"pretrain_head.decoder.bias\", \"pretrain_head.decoder.weight\"]\n\n    def __init__(self, config: SpliceBertConfig):\n        super().__init__(config)\n        if config.is_decoder:\n            logger.warning(\n                \"If you want to use `SpliceBertForPreTraining` make sure `config.is_decoder=False` for \"\n                \"bi-directional self-attention.\"\n            )\n        self.splicebert = SpliceBertModel(config, add_pooling_layer=False)\n        self.lm_head = MaskedLMHead(config)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | MaskedLMOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.splicebert(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_attention_mask,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.lm_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return MaskedLMOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/splicebert/#multimolecule.models.splicebert.SpliceBertForSequencePrediction","title":"<code>SpliceBertForSequencePrediction</code>","text":"<p>               Bases: <code>SpliceBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import SpliceBertConfig, SpliceBertForSequencePrediction, RnaTokenizer\n&gt;&gt;&gt; config = SpliceBertConfig()\n&gt;&gt;&gt; model = SpliceBertForSequencePrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.tensor([[1]]))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/splicebert/modeling_splicebert.py</code> Python<pre><code>class SpliceBertForSequencePrediction(SpliceBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import SpliceBertConfig, SpliceBertForSequencePrediction, RnaTokenizer\n        &gt;&gt;&gt; config = SpliceBertConfig()\n        &gt;&gt;&gt; model = SpliceBertForSequencePrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.tensor([[1]]))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: SpliceBertConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.splicebert = SpliceBertModel(config, add_pooling_layer=True)\n        self.sequence_head = SequencePredictionHead(config)\n        self.head_config = self.sequence_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | SequencePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.splicebert(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.sequence_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return SequencePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/splicebert/#multimolecule.models.splicebert.SpliceBertForTokenPrediction","title":"<code>SpliceBertForTokenPrediction</code>","text":"<p>               Bases: <code>SpliceBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import SpliceBertConfig, SpliceBertForTokenPrediction, RnaTokenizer\n&gt;&gt;&gt; config = SpliceBertConfig()\n&gt;&gt;&gt; model = SpliceBertForTokenPrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/splicebert/modeling_splicebert.py</code> Python<pre><code>class SpliceBertForTokenPrediction(SpliceBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import SpliceBertConfig, SpliceBertForTokenPrediction, RnaTokenizer\n        &gt;&gt;&gt; config = SpliceBertConfig()\n        &gt;&gt;&gt; model = SpliceBertForTokenPrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: SpliceBertConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.splicebert = SpliceBertModel(config, add_pooling_layer=True)\n        self.token_head = TokenPredictionHead(config)\n        self.head_config = self.token_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | TokenPredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.splicebert(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.token_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return TokenPredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/splicebert/#multimolecule.models.splicebert.SpliceBertModel","title":"<code>SpliceBertModel</code>","text":"<p>               Bases: <code>SpliceBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import SpliceBertConfig, SpliceBertModel, RnaTokenizer\n&gt;&gt;&gt; config = SpliceBertConfig()\n&gt;&gt;&gt; model = SpliceBertModel(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input)\n&gt;&gt;&gt; output[\"last_hidden_state\"].shape\ntorch.Size([1, 7, 512])\n&gt;&gt;&gt; output[\"pooler_output\"].shape\ntorch.Size([1, 512])\n</code></pre> Source code in <code>multimolecule/models/splicebert/modeling_splicebert.py</code> Python<pre><code>class SpliceBertModel(SpliceBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import SpliceBertConfig, SpliceBertModel, RnaTokenizer\n        &gt;&gt;&gt; config = SpliceBertConfig()\n        &gt;&gt;&gt; model = SpliceBertModel(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input)\n        &gt;&gt;&gt; output[\"last_hidden_state\"].shape\n        torch.Size([1, 7, 512])\n        &gt;&gt;&gt; output[\"pooler_output\"].shape\n        torch.Size([1, 512])\n    \"\"\"\n\n    def __init__(self, config: SpliceBertConfig, add_pooling_layer: bool = True):\n        super().__init__(config)\n        self.pad_token_id = config.pad_token_id\n        self.embeddings = SpliceBertEmbeddings(config)\n        self.encoder = SpliceBertEncoder(config)\n        self.pooler = SpliceBertPooler(config) if add_pooling_layer else None\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.embeddings.word_embeddings\n\n    def set_input_embeddings(self, value):\n        self.embeddings.word_embeddings = value\n\n    def _prune_heads(self, heads_to_prune):\n        \"\"\"\n        Prunes heads of the model. heads_to_prune: dict of {layer_num: list of heads to prune in this layer} See base\n        class PreTrainedModel\n        \"\"\"\n        for layer, heads in heads_to_prune.items():\n            self.encoder.layer[layer].attention.prune_heads(heads)\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        past_key_values: Tuple[Tuple[torch.FloatTensor, torch.FloatTensor], ...] | None = None,\n        use_cache: bool | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | BaseModelOutputWithPoolingAndCrossAttentions:\n        r\"\"\"\n        encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n            Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n            the model is configured as a decoder.\n        encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n            the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n            - 1 for tokens that are **not masked**,\n            - 0 for tokens that are **masked**.\n        past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors\n            of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n            Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n        use_cache (`bool`, *optional*):\n            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n            `past_key_values`).\n        \"\"\"\n        if kwargs:\n            warn(\n                f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n                f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n                \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n            )\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        if self.config.is_decoder:\n            use_cache = use_cache if use_cache is not None else self.config.use_cache\n        else:\n            use_cache = False\n\n        if isinstance(input_ids, NestedTensor):\n            input_ids, attention_mask = input_ids.tensor, input_ids.mask\n        if input_ids is not None and inputs_embeds is not None:\n            raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n        if input_ids is not None:\n            self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n            input_shape = input_ids.size()\n        elif inputs_embeds is not None:\n            input_shape = inputs_embeds.size()[:-1]\n        else:\n            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n        batch_size, seq_length = input_shape\n        device = input_ids.device if input_ids is not None else inputs_embeds.device  # type: ignore[union-attr]\n\n        # past_key_values_length\n        past_key_values_length = past_key_values[0][0].shape[2] if past_key_values is not None else 0\n\n        if attention_mask is None:\n            attention_mask = (\n                input_ids.ne(self.pad_token_id)\n                if self.pad_token_id is not None\n                else torch.ones(((batch_size, seq_length + past_key_values_length)), device=device)\n            )\n\n        # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n        # ourselves in which case we just need to make it broadcastable to all heads.\n        extended_attention_mask: Tensor = self.get_extended_attention_mask(attention_mask, input_shape)\n\n        # If a 2D or 3D attention mask is provided for the cross-attention\n        # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n        if self.config.is_decoder and encoder_hidden_states is not None:\n            encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n            encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n            if encoder_attention_mask is None:\n                encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n            encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n        else:\n            encoder_extended_attention_mask = None\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n        head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n        embedding_output = self.embeddings(\n            input_ids=input_ids,\n            position_ids=position_ids,\n            inputs_embeds=inputs_embeds,\n            past_key_values_length=past_key_values_length,\n        )\n        encoder_outputs = self.encoder(\n            embedding_output,\n            attention_mask=extended_attention_mask,\n            head_mask=head_mask,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_extended_attention_mask,\n            past_key_values=past_key_values,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n        sequence_output = encoder_outputs[0]\n        pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n        if not return_dict:\n            return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n        return BaseModelOutputWithPoolingAndCrossAttentions(\n            last_hidden_state=sequence_output,\n            pooler_output=pooled_output,\n            past_key_values=encoder_outputs.past_key_values,\n            hidden_states=encoder_outputs.hidden_states,\n            attentions=encoder_outputs.attentions,\n            cross_attentions=encoder_outputs.cross_attentions,\n        )\n</code></pre>"},{"location":"models/splicebert/#multimolecule.models.splicebert.SpliceBertModel.forward","title":"<code>forward(input_ids, attention_mask=None, position_ids=None, head_mask=None, inputs_embeds=None, encoder_hidden_states=None, encoder_attention_mask=None, past_key_values=None, use_cache=None, output_attentions=None, output_hidden_states=None, return_dict=None, **kwargs)</code>","text":"<p>encoder_hidden_states  (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, optional):     Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if     the model is configured as a decoder. encoder_attention_mask (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, optional):     Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in     the cross-attention if the model is configured as a decoder. Mask values selected in <code>[0, 1]</code>:</p> Text Only<pre><code>- 1 for tokens that are **not masked**,\n- 0 for tokens that are **masked**.\n</code></pre> <p>past_key_values (<code>tuple(tuple(torch.FloatTensor))</code> of length <code>config.n_layers</code> with each tuple having 4 tensors     of shape <code>(batch_size, num_heads, sequence_length - 1, embed_size_per_head)</code>):     Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.</p> Text Only<pre><code>If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\ndon't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n`decoder_input_ids` of shape `(batch_size, sequence_length)`.\n</code></pre> <p>use_cache (<code>bool</code>, optional):     If set to <code>True</code>, <code>past_key_values</code> key value states are returned and can be used to speed up decoding (see     <code>past_key_values</code>).</p> Source code in <code>multimolecule/models/splicebert/modeling_splicebert.py</code> Python<pre><code>def forward(\n    self,\n    input_ids: Tensor | NestedTensor,\n    attention_mask: Tensor | None = None,\n    position_ids: Tensor | None = None,\n    head_mask: Tensor | None = None,\n    inputs_embeds: Tensor | NestedTensor | None = None,\n    encoder_hidden_states: Tensor | None = None,\n    encoder_attention_mask: Tensor | None = None,\n    past_key_values: Tuple[Tuple[torch.FloatTensor, torch.FloatTensor], ...] | None = None,\n    use_cache: bool | None = None,\n    output_attentions: bool | None = None,\n    output_hidden_states: bool | None = None,\n    return_dict: bool | None = None,\n    **kwargs,\n) -&gt; Tuple[Tensor, ...] | BaseModelOutputWithPoolingAndCrossAttentions:\n    r\"\"\"\n    encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n        Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n        the model is configured as a decoder.\n    encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n        Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n        the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n        - 1 for tokens that are **not masked**,\n        - 0 for tokens that are **masked**.\n    past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors\n        of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n        Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n        If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n        don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n        `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n    use_cache (`bool`, *optional*):\n        If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n        `past_key_values`).\n    \"\"\"\n    if kwargs:\n        warn(\n            f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n            f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n            \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n        )\n    output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n    output_hidden_states = (\n        output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n    )\n    return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n    if self.config.is_decoder:\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n    else:\n        use_cache = False\n\n    if isinstance(input_ids, NestedTensor):\n        input_ids, attention_mask = input_ids.tensor, input_ids.mask\n    if input_ids is not None and inputs_embeds is not None:\n        raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n    if input_ids is not None:\n        self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n        input_shape = input_ids.size()\n    elif inputs_embeds is not None:\n        input_shape = inputs_embeds.size()[:-1]\n    else:\n        raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n    batch_size, seq_length = input_shape\n    device = input_ids.device if input_ids is not None else inputs_embeds.device  # type: ignore[union-attr]\n\n    # past_key_values_length\n    past_key_values_length = past_key_values[0][0].shape[2] if past_key_values is not None else 0\n\n    if attention_mask is None:\n        attention_mask = (\n            input_ids.ne(self.pad_token_id)\n            if self.pad_token_id is not None\n            else torch.ones(((batch_size, seq_length + past_key_values_length)), device=device)\n        )\n\n    # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n    # ourselves in which case we just need to make it broadcastable to all heads.\n    extended_attention_mask: Tensor = self.get_extended_attention_mask(attention_mask, input_shape)\n\n    # If a 2D or 3D attention mask is provided for the cross-attention\n    # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n    if self.config.is_decoder and encoder_hidden_states is not None:\n        encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n        encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n        if encoder_attention_mask is None:\n            encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n        encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n    else:\n        encoder_extended_attention_mask = None\n\n    # Prepare head mask if needed\n    # 1.0 in head_mask indicate we keep the head\n    # attention_probs has shape bsz x n_heads x N x N\n    # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n    # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n    head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n    embedding_output = self.embeddings(\n        input_ids=input_ids,\n        position_ids=position_ids,\n        inputs_embeds=inputs_embeds,\n        past_key_values_length=past_key_values_length,\n    )\n    encoder_outputs = self.encoder(\n        embedding_output,\n        attention_mask=extended_attention_mask,\n        head_mask=head_mask,\n        encoder_hidden_states=encoder_hidden_states,\n        encoder_attention_mask=encoder_extended_attention_mask,\n        past_key_values=past_key_values,\n        use_cache=use_cache,\n        output_attentions=output_attentions,\n        output_hidden_states=output_hidden_states,\n        return_dict=return_dict,\n    )\n    sequence_output = encoder_outputs[0]\n    pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n    if not return_dict:\n        return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n    return BaseModelOutputWithPoolingAndCrossAttentions(\n        last_hidden_state=sequence_output,\n        pooler_output=pooled_output,\n        past_key_values=encoder_outputs.past_key_values,\n        hidden_states=encoder_outputs.hidden_states,\n        attentions=encoder_outputs.attentions,\n        cross_attentions=encoder_outputs.cross_attentions,\n    )\n</code></pre>"},{"location":"models/splicebert/#multimolecule.models.splicebert.SpliceBertPreTrainedModel","title":"<code>SpliceBertPreTrainedModel</code>","text":"<p>               Bases: <code>PreTrainedModel</code></p> <p>An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained models.</p> Source code in <code>multimolecule/models/splicebert/modeling_splicebert.py</code> Python<pre><code>class SpliceBertPreTrainedModel(PreTrainedModel):\n    \"\"\"\n    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n    models.\n    \"\"\"\n\n    config_class = SpliceBertConfig\n    base_model_prefix = \"splicebert\"\n    supports_gradient_checkpointing = True\n    _no_split_modules = [\"SpliceBertLayer\", \"SpliceBertEmbeddings\"]\n\n    # Copied from transformers.models.bert.modeling_bert.BertPreTrainedModel._init_weights\n    def _init_weights(self, module: nn.Module):\n        \"\"\"Initialize the weights\"\"\"\n        if isinstance(module, nn.Linear):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, nn.Embedding):\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.padding_idx is not None:\n                module.weight.data[module.padding_idx].zero_()\n        elif isinstance(module, nn.LayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n\n    def _set_gradient_checkpointing(self, module, value=False):\n        if isinstance(module, SpliceBertEncoder):\n            module.gradient_checkpointing = value\n</code></pre>"},{"location":"models/utrbert/","title":"3UTRBERT","text":"<p>Pre-trained model on 3\u2019 untranslated region (3\u2019UTR) using a masked language modeling (MLM) objective.</p>"},{"location":"models/utrbert/#disclaimer","title":"Disclaimer","text":"<p>This is an UNOFFICIAL implementation of the Deciphering 3\u2019 UTR mediated gene regulation using interpretable deep representation learning by Yuning Yang, Gen Li, et al.</p> <p>The OFFICIAL repository of 3UTRBERT is at yangyn533/3UTRBERT.</p> <p>The team releasing 3UTRBERT did not write this model card for this model so this model card has been written by the MultiMolecule team.</p>"},{"location":"models/utrbert/#model-details","title":"Model Details","text":"<p>3UTRBERT is a bert-style model pre-trained on a large corpus of 3\u2019 untranslated regions (3\u2019UTRs) in a self-supervised fashion. This means that the model was trained on the raw nucleotides of RNA sequences only, with an automatic process to generate inputs and labels from those texts. Please refer to the Training Details section for more information on the training process.</p>"},{"location":"models/utrbert/#variations","title":"Variations","text":"<ul> <li><code>multimolecule/utrbert-3mer</code>: The 3UTRBERT model pre-trained on 3-mer data.</li> <li><code>multimolecule/utrbert-4mer</code>: The 3UTRBERT model pre-trained on 4-mer data.</li> <li><code>multimolecule/utrbert-5mer</code>: The 3UTRBERT model pre-trained on 5-mer data.</li> <li><code>multimolecule/utrbert-6mer</code>: The 3UTRBERT model pre-trained on 6-mer data.</li> </ul>"},{"location":"models/utrbert/#model-specification","title":"Model Specification","text":"Variants Num Layers Hidden Size Num Heads Intermediate Size Num Parameters (M) FLOPs (G) MACs (G) Max Num Tokens UTRBERT-3mer 12 768 12 3072 86.14 22.36 11.17 512 UTRBERT-4mer 86.53 UTRBERT-5mer 88.45 UTRBERT-6mer 98.05"},{"location":"models/utrbert/#links","title":"Links","text":"<ul> <li>Code: multimolecule.utrbert</li> <li>Data: GENCODE</li> <li>Paper: Deciphering 3\u2019 UTR mediated gene regulation using interpretable deep representation learning</li> <li>Developed by: Yuning Yang, Gen Li, Kuan Pang, Wuxinhao Cao, Xiangtao Li, Zhaolei Zhang</li> <li>Model type: BERT - FlashAttention</li> <li>Original Repository: https://github.com/yangyn533/3UTRBERT</li> </ul>"},{"location":"models/utrbert/#usage","title":"Usage","text":"<p>The model file depends on the <code>multimolecule</code> library. You can install it using pip:</p> Bash<pre><code>pip install multimolecule\n</code></pre>"},{"location":"models/utrbert/#direct-use","title":"Direct Use","text":"<p>Note: Default transformers pipeline does not support K-mer tokenization.</p> <p>You can use this model directly with a pipeline for masked language modeling:</p> Python<pre><code>&gt;&gt;&gt; import multimolecule  # you must import multimolecule to register models\n&gt;&gt;&gt; from transformers import pipeline\n&gt;&gt;&gt; unmasker = pipeline('fill-mask', model='multimolecule/utrbert-3mer')\n&gt;&gt;&gt; unmasker(\"uagc&lt;mask&gt;&lt;mask&gt;&lt;mask&gt;ucagacugauguuga\")[1]\n\n[{'score': 0.510771632194519,\n  'token': 49,\n  'token_str': 'CUU',\n  'sequence': '&lt;cls&gt; UAG AGC &lt;mask&gt; CUU &lt;mask&gt; UCA CAG AGA GAC ACU CUG UGA GAU AUG UGU GUU UUG UGA &lt;eos&gt;'},\n {'score': 0.3299057185649872,\n  'token': 39,\n  'token_str': 'CCU',\n  'sequence': '&lt;cls&gt; UAG AGC &lt;mask&gt; CCU &lt;mask&gt; UCA CAG AGA GAC ACU CUG UGA GAU AUG UGU GUU UUG UGA &lt;eos&gt;'},\n {'score': 0.09743840992450714,\n  'token': 34,\n  'token_str': 'CAU',\n  'sequence': '&lt;cls&gt; UAG AGC &lt;mask&gt; CAU &lt;mask&gt; UCA CAG AGA GAC ACU CUG UGA GAU AUG UGU GUU UUG UGA &lt;eos&gt;'},\n {'score': 0.010745460167527199,\n  'token': 64,\n  'token_str': 'GCU',\n  'sequence': '&lt;cls&gt; UAG AGC &lt;mask&gt; GCU &lt;mask&gt; UCA CAG AGA GAC ACU CUG UGA GAU AUG UGU GUU UUG UGA &lt;eos&gt;'},\n {'score': 0.010299043729901314,\n  'token': 24,\n  'token_str': 'AUU',\n  'sequence': '&lt;cls&gt; UAG AGC &lt;mask&gt; AUU &lt;mask&gt; UCA CAG AGA GAC ACU CUG UGA GAU AUG UGU GUU UUG UGA &lt;eos&gt;'}]\n</code></pre>"},{"location":"models/utrbert/#downstream-use","title":"Downstream Use","text":""},{"location":"models/utrbert/#extract-features","title":"Extract Features","text":"<p>Here is how to use this model to get the features of a given sequence in PyTorch:</p> Python<pre><code>from multimolecule import RnaTokenizer, UtrBertModel\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/utrbert-3mer')\nmodel = UtrBertModel.from_pretrained('multimolecule/utrbert-3mer')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\n\noutput = model(**input)\n</code></pre>"},{"location":"models/utrbert/#sequence-classification-regression","title":"Sequence Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for sequence classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a sequence-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, UtrBertForSequencePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/utrbert-3mer')\nmodel = UtrBertForSequencePrediction.from_pretrained('multimolecule/utrbert-3mer')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.tensor([1])\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/utrbert/#nucleotide-classification-regression","title":"Nucleotide Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for nucleotide classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a nucleotide-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, UtrBertForNucleotidePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/utrbert-3mer')\nmodel = UtrBertForNucleotidePrediction.from_pretrained('multimolecule/utrbert-3mer')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.randint(2, (len(text), ))\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/utrbert/#training-details","title":"Training Details","text":"<p>3UTRBERT used Masked Language Modeling (MLM) as the pre-training objective: taking a sequence, the model randomly masks 15% of the tokens in the input then runs the entire masked sentence through the model and has to predict the masked tokens. This is comparable to the Cloze task in language modeling.</p>"},{"location":"models/utrbert/#training-data","title":"Training Data","text":"<p>The 3UTRBERT model was pre-trained on human mRNA transcript sequences from GENCODE. GENCODE aims to identify all gene features in the human genome using a combination of computational analysis, manual annotation, and experimental validation. The GENCODE release 40 used by this work contains 61,544 genes, and 246,624 transcripts.</p> <p>3UTRBERT collected the human mRNA transcript sequences from GENCODE, including 108,573 unique mRNA transcripts. Only the longest transcript of each gene was used in the pre-training process. 3UTRBERT only used the 3\u2019 untranslated regions (3\u2019UTRs) of the mRNA transcripts for pre-training to avoid codon constrains in the CDS region, and to reduce increased complexity of the entire mRNA transcripts. The average length of the 3\u2019UTRs was 1,227 nucleotides, while the median length was 631 nucleotides. Each 3\u2019UTR sequence was cut to non-overlapping patches of 510 nucleotides. The remaining sequences were padded to the same length.</p> <p>Note <code>RnaTokenizer</code> will convert \u201cT\u201ds to \u201cU\u201ds for you, you may disable this behaviour by passing <code>replace_T_with_U=False</code>.</p>"},{"location":"models/utrbert/#training-procedure","title":"Training Procedure","text":""},{"location":"models/utrbert/#preprocessing","title":"Preprocessing","text":"<p>3UTRBERT used masked language modeling (MLM) as the pre-training objective. The masking procedure is similar to the one used in BERT:</p> <ul> <li>15% of the tokens are masked.</li> <li>In 80% of the cases, the masked tokens are replaced by <code>&lt;mask&gt;</code>.</li> <li>In 10% of the cases, the masked tokens are replaced by a random token (different) from the one they replace.</li> <li>In the 10% remaining cases, the masked tokens are left as is.</li> </ul> <p>Since 3UTRBERT used k-mer tokenizer, it masks the entire k-mer instead of individual nucleotides to avoid information leakage.</p> <p>For example, if the k-mer is 3, the sequence <code>\"UAGCGUAU\"</code> will be tokenized as <code>[\"UAG\", \"AGC\", \"GCG\", \"CGU\", \"GUA\", \"UAU\"]</code>. If the nucleotide <code>\"C\"</code> is masked, the adjacent tokens will also be masked, resulting <code>[\"UAG\", \"&lt;mask&gt;\", \"&lt;mask&gt;\", \"&lt;mask&gt;\", \"GUA\", \"UAU\"]</code>.</p>"},{"location":"models/utrbert/#pretraining","title":"PreTraining","text":"<p>The model was trained on 4 NVIDIA Quadro RTX 6000 GPUs with 24GiB memories.</p> <ul> <li>Batch size: 128</li> <li>Learning rate: 3e-4</li> <li>Weight decay: 0.01</li> <li>Optimizer: AdamW(\u03b21=0.9, \u03b22=0.98, e=1e-6)</li> <li>Steps: 200,000</li> <li>Learning rate scheduler: Linear</li> <li>Learning rate warm-up: 10,000 steps</li> </ul>"},{"location":"models/utrbert/#citation","title":"Citation","text":"<p>BibTeX:</p> BibTeX<pre><code>@article {yang2023deciphering,\n    author = {Yang, Yuning and Li, Gen and Pang, Kuan and Cao, Wuxinhao and Li, Xiangtao and Zhang, Zhaolei},\n    title = {Deciphering 3{\\textquoteright} UTR mediated gene regulation using interpretable deep representation learning},\n    elocation-id = {2023.09.08.556883},\n    year = {2023},\n    doi = {10.1101/2023.09.08.556883},\n    publisher = {Cold Spring Harbor Laboratory},\n    abstract = {The 3{\\textquoteright}untranslated regions (3{\\textquoteright}UTRs) of messenger RNAs contain many important cis-regulatory elements that are under functional and evolutionary constraints. We hypothesize that these constraints are similar to grammars and syntaxes in human languages and can be modeled by advanced natural language models such as Transformers, which has been very effective in modeling protein sequence and structures. Here we describe 3UTRBERT, which implements an attention-based language model, i.e., Bidirectional Encoder Representations from Transformers (BERT). 3UTRBERT was pre-trained on aggregated 3{\\textquoteright}UTR sequences of human mRNAs in a task-agnostic manner; the pre-trained model was then fine-tuned for specific downstream tasks such as predicting RBP binding sites, m6A RNA modification sites, and predicting RNA sub-cellular localizations. Benchmark results showed that 3UTRBERT generally outperformed other contemporary methods in each of these tasks. We also showed that the self-attention mechanism within 3UTRBERT allows direct visualization of the semantic relationship between sequence elements.Competing Interest StatementThe authors have declared no competing interest.},\n    URL = {https://www.biorxiv.org/content/early/2023/09/12/2023.09.08.556883},\n    eprint = {https://www.biorxiv.org/content/early/2023/09/12/2023.09.08.556883.full.pdf},\n    journal = {bioRxiv}\n}\n</code></pre>"},{"location":"models/utrbert/#contact","title":"Contact","text":"<p>Please use GitHub issues of MultiMolecule for any questions or comments on the model card.</p> <p>Please contact the authors of the 3UTRBERT paper for questions or comments on the paper/model.</p>"},{"location":"models/utrbert/#license","title":"License","text":"<p>This model is licensed under the AGPL-3.0 License.</p> Text Only<pre><code>SPDX-License-Identifier: AGPL-3.0-or-later\n</code></pre>"},{"location":"models/utrbert/#multimolecule.models.utrbert","title":"<code>multimolecule.models.utrbert</code>","text":""},{"location":"models/utrbert/#multimolecule.models.utrbert.RnaTokenizer","title":"<code>RnaTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>Constructs an RNA tokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>alphabet</code> <code>List[str] | None</code> <p>List of tokens to use. Defaults to IUPAC nucleotide code.</p> <code>None</code> <code>nmers</code> <code>int</code> <p>Size of nmers to tokenize. Defaults to 1.</p> <code>1</code> <code>codon</code> <code>bool</code> <p>Whether to tokenize into codons. Defaults to False.</p> <code>False</code> <code>replace_T_with_U</code> <code>bool</code> <p>Whether to replace T with U. Defaults to True.</p> <code>True</code> <code>do_upper_case</code> <code>bool</code> <p>Whether to convert input to uppercase. Defaults to True.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaTokenizer\n&gt;&gt;&gt; tokenizer = RnaTokenizer()\n&gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n[1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n&gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 3, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 17, 64, 49, 96, 84, 22, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 49, 22, 2]\n&gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\nTraceback (most recent call last):\nValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n</code></pre> Source code in <code>multimolecule/tokenisers/rna/tokenization_rna.py</code> Python<pre><code>class RnaTokenizer(Tokenizer):\n    \"\"\"\n    Constructs an RNA tokenizer.\n\n    Args:\n        alphabet (List[str] | None, optional): List of tokens to use.\n            Defaults to [IUPAC nucleotide code](https://www.bioinformatics.org/sms2/iupac.html).\n        nmers (int, optional): Size of nmers to tokenize.\n            Defaults to 1.\n        codon (bool, optional): Whether to tokenize into codons.\n            Defaults to False.\n        replace_T_with_U (bool, optional): Whether to replace T with U.\n            Defaults to True.\n        do_upper_case (bool, optional): Whether to convert input to uppercase.\n            Defaults to True.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaTokenizer\n        &gt;&gt;&gt; tokenizer = RnaTokenizer()\n        &gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n        [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n        &gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 3, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 17, 64, 49, 96, 84, 22, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 49, 22, 2]\n        &gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\n        Traceback (most recent call last):\n        ValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n    \"\"\"\n\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n\n    def __init__(\n        self,\n        alphabet: List[str] | None = None,\n        nmers: int = 1,\n        codon: bool = False,\n        replace_T_with_U: bool = True,\n        bos_token: str = \"&lt;cls&gt;\",\n        cls_token: str = \"&lt;cls&gt;\",\n        pad_token: str = \"&lt;pad&gt;\",\n        eos_token: str = \"&lt;eos&gt;\",\n        sep_token: str = \"&lt;eos&gt;\",\n        unk_token: str = \"&lt;unk&gt;\",\n        mask_token: str = \"&lt;mask&gt;\",\n        additional_special_tokens: List | Tuple | None = None,\n        do_upper_case: bool = True,\n        **kwargs,\n    ):\n        if codon and nmers &gt; 1:\n            raise ValueError(\"Codon and nmers cannot be used together.\")\n        if codon:\n            nmers = 3  # set to 3 to get correct vocab\n        super().__init__(\n            alphabet=get_vocab_list(alphabet, nmers),\n            bos_token=bos_token,\n            cls_token=cls_token,\n            pad_token=pad_token,\n            eos_token=eos_token,\n            sep_token=sep_token,\n            unk_token=unk_token,\n            mask_token=mask_token,\n            additional_special_tokens=additional_special_tokens,\n            do_upper_case=do_upper_case,\n            **kwargs,\n        )\n        self.replace_T_with_U = replace_T_with_U\n        self.nmers = nmers\n        self.condon = codon\n\n    def _tokenize(self, text: str, **kwargs):\n        if self.do_upper_case:\n            text = text.upper()\n        if self.replace_T_with_U:\n            text = text.replace(\"T\", \"U\")\n        if self.condon:\n            if len(text) % 3 != 0:\n                raise ValueError(\n                    f\"length of input sequence  must be a multiple of 3 for codon tokenization, but got {len(text)}\"\n                )\n            return [text[i : i + 3] for i in range(0, len(text), 3)]\n        if self.nmers &gt; 1:\n            return [text[i : i + self.nmers] for i in range(len(text) - self.nmers + 1)]  # noqa: E203\n        return list(text)\n</code></pre>"},{"location":"models/utrbert/#multimolecule.models.utrbert.UtrBertConfig","title":"<code>UtrBertConfig</code>","text":"<p>               Bases: <code>PreTrainedConfig</code></p> <p>This is the configuration class to store the configuration of a [<code>UtrBertModel</code>]. It is used to instantiate a 3UTRBERT model according to the specified arguments, defining the model architecture. Instantiating a configuration with the defaults will yield a similar configuration to that of the 3UTRBERT yangyn533/3UTRBERT architecture.</p> <p>Configuration objects inherit from [<code>PreTrainedConfig</code>] and can be used to control the model outputs. Read the documentation from [<code>PreTrainedConfig</code>] for more information.</p> <p>Parameters:</p> Name Type Description Default <code>vocab_size</code> <code>`int`, *optional*</code> <p>Vocabulary size of the UTRBERT model. Defines the number of different tokens that can be represented by the <code>inputs_ids</code> passed when calling [<code>BertModel</code>].</p> <code>None</code> <code>nmers</code> <code>`int`, *optional*</code> <p>kmer size of the UTRBERT model. Defines the vocabulary size of the model.</p> <code>None</code> <code>hidden_size</code> <code>`int`, *optional*, defaults to 768</code> <p>Dimensionality of the encoder layers and the pooler layer.</p> <code>768</code> <code>num_hidden_layers</code> <code>`int`, *optional*, defaults to 12</code> <p>Number of hidden layers in the Transformer encoder.</p> <code>12</code> <code>num_attention_heads</code> <code>`int`, *optional*, defaults to 12</code> <p>Number of attention heads for each attention layer in the Transformer encoder.</p> <code>12</code> <code>intermediate_size</code> <code>`int`, *optional*, defaults to 3072</code> <p>Dimensionality of the \u201cintermediate\u201d (often named feed-forward) layer in the Transformer encoder.</p> <code>3072</code> <code>hidden_act</code> <code>`str` or `Callable`, *optional*, defaults to `\"gelu\"`</code> <p>The non-linear activation function (function or string) in the encoder and pooler. If string, <code>\"gelu\"</code>, <code>\"relu\"</code>, <code>\"silu\"</code> and <code>\"gelu_new\"</code> are supported.</p> <code>'gelu'</code> <code>hidden_dropout</code> <code>`float`, *optional*, defaults to 0.1</code> <p>The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.</p> <code>0.1</code> <code>attention_dropout</code> <code>`float`, *optional*, defaults to 0.1</code> <p>The dropout ratio for the attention probabilities.</p> <code>0.1</code> <code>max_position_embeddings</code> <code>`int`, *optional*, defaults to 512</code> <p>The maximum sequence length that this model might ever be used with. Typically set this to something large just in case (e.g., 512 or 1024 or 2048).</p> <code>512</code> <code>type_vocab_size</code> <code>`int`, *optional*, defaults to 2</code> <p>The vocabulary size of the <code>token_type_ids</code> passed when calling [<code>BertModel</code>] or [<code>TFBertModel</code>].</p> required <code>initializer_range</code> <code>`float`, *optional*, defaults to 0.02</code> <p>The standard deviation of the truncated_normal_initializer for initializing all weight matrices.</p> <code>0.02</code> <code>layer_norm_eps</code> <code>`float`, *optional*, defaults to 1e-12</code> <p>The epsilon used by the layer normalization layers.</p> <code>1e-12</code> <code>position_embedding_type</code> <code>`str`, *optional*, defaults to `\"absolute\"`</code> <p>Type of position embedding. Choose one of <code>\"absolute\"</code>, <code>\"relative_key\"</code>, <code>\"relative_key_query\"</code>. For positional embeddings use <code>\"absolute\"</code>. For more information on <code>\"relative_key\"</code>, please refer to Self-Attention with Relative Position Representations (Shaw et al.). For more information on <code>\"relative_key_query\"</code>, please refer to Method 4 in Improve Transformer Models with Better Relative Position Embeddings (Huang et al.).</p> <code>'absolute'</code> <code>is_decoder</code> <code>`bool`, *optional*, defaults to `False`</code> <p>Whether the model is used as a decoder or not. If <code>False</code>, the model is used as an encoder.</p> required <code>use_cache</code> <code>`bool`, *optional*, defaults to `True`</code> <p>Whether or not the model should return the last key/values attentions (not used by all models). Only relevant if <code>config.is_decoder=True</code>.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import UtrBertConfig, UtrBertModel\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a UtrBERT multimolecule/utrbert style configuration\n&gt;&gt;&gt; configuration = UtrBertConfig(vocab_size=26, nmers=1)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/utrbert style configuration\n&gt;&gt;&gt; model = UtrBertModel(configuration)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Accessing the model configuration\n&gt;&gt;&gt; configuration = model.config\n</code></pre> Source code in <code>multimolecule/models/utrbert/configuration_utrbert.py</code> Python<pre><code>class UtrBertConfig(PreTrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`UtrBertModel`]. It is used to instantiate a\n    3UTRBERT model according to the specified arguments, defining the model architecture. Instantiating a configuration\n    with the defaults will yield a similar configuration to that of the 3UTRBERT\n    [yangyn533/3UTRBERT](https://github.com/yangyn533/3UTRBERT) architecture.\n\n    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n    documentation from [`PreTrainedConfig`] for more information.\n\n\n    Args:\n        vocab_size (`int`, *optional*):\n            Vocabulary size of the UTRBERT model. Defines the number of different tokens that can be represented by the\n            `inputs_ids` passed when calling [`BertModel`].\n        nmers (`int`, *optional*):\n            kmer size of the UTRBERT model. Defines the vocabulary size of the model.\n        hidden_size (`int`, *optional*, defaults to 768):\n            Dimensionality of the encoder layers and the pooler layer.\n        num_hidden_layers (`int`, *optional*, defaults to 12):\n            Number of hidden layers in the Transformer encoder.\n        num_attention_heads (`int`, *optional*, defaults to 12):\n            Number of attention heads for each attention layer in the Transformer encoder.\n        intermediate_size (`int`, *optional*, defaults to 3072):\n            Dimensionality of the \"intermediate\" (often named feed-forward) layer in the Transformer encoder.\n        hidden_act (`str` or `Callable`, *optional*, defaults to `\"gelu\"`):\n            The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n            `\"relu\"`, `\"silu\"` and `\"gelu_new\"` are supported.\n        hidden_dropout (`float`, *optional*, defaults to 0.1):\n            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n        attention_dropout (`float`, *optional*, defaults to 0.1):\n            The dropout ratio for the attention probabilities.\n        max_position_embeddings (`int`, *optional*, defaults to 512):\n            The maximum sequence length that this model might ever be used with. Typically set this to something large\n            just in case (e.g., 512 or 1024 or 2048).\n        type_vocab_size (`int`, *optional*, defaults to 2):\n            The vocabulary size of the `token_type_ids` passed when calling [`BertModel`] or [`TFBertModel`].\n        initializer_range (`float`, *optional*, defaults to 0.02):\n            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n        layer_norm_eps (`float`, *optional*, defaults to 1e-12):\n            The epsilon used by the layer normalization layers.\n        position_embedding_type (`str`, *optional*, defaults to `\"absolute\"`):\n            Type of position embedding. Choose one of `\"absolute\"`, `\"relative_key\"`, `\"relative_key_query\"`. For\n            positional embeddings use `\"absolute\"`. For more information on `\"relative_key\"`, please refer to\n            [Self-Attention with Relative Position Representations (Shaw et al.)](https://arxiv.org/abs/1803.02155).\n            For more information on `\"relative_key_query\"`, please refer to *Method 4* in [Improve Transformer Models\n            with Better Relative Position Embeddings (Huang et al.)](https://arxiv.org/abs/2009.13658).\n        is_decoder (`bool`, *optional*, defaults to `False`):\n            Whether the model is used as a decoder or not. If `False`, the model is used as an encoder.\n        use_cache (`bool`, *optional*, defaults to `True`):\n            Whether or not the model should return the last key/values attentions (not used by all models). Only\n            relevant if `config.is_decoder=True`.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import UtrBertConfig, UtrBertModel\n\n        &gt;&gt;&gt; # Initializing a UtrBERT multimolecule/utrbert style configuration\n        &gt;&gt;&gt; configuration = UtrBertConfig(vocab_size=26, nmers=1)\n\n        &gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/utrbert style configuration\n        &gt;&gt;&gt; model = UtrBertModel(configuration)\n\n        &gt;&gt;&gt; # Accessing the model configuration\n        &gt;&gt;&gt; configuration = model.config\n    \"\"\"\n\n    model_type = \"utrbert\"\n\n    def __init__(\n        self,\n        vocab_size=None,\n        nmers=None,\n        hidden_size=768,\n        num_hidden_layers=12,\n        num_attention_heads=12,\n        intermediate_size=3072,\n        hidden_act=\"gelu\",\n        hidden_dropout=0.1,\n        attention_dropout=0.1,\n        max_position_embeddings=512,\n        initializer_range=0.02,\n        layer_norm_eps=1e-12,\n        position_embedding_type=\"absolute\",\n        use_cache=True,\n        head=None,\n        lm_head=None,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n\n        self.vocab_size = vocab_size\n        self.type_vocab_size = 2\n        self.nmers = nmers\n        self.hidden_size = hidden_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_attention_heads = num_attention_heads\n        self.hidden_act = hidden_act\n        self.intermediate_size = intermediate_size\n        self.hidden_dropout = hidden_dropout\n        self.attention_dropout = attention_dropout\n        self.max_position_embeddings = max_position_embeddings\n        self.initializer_range = initializer_range\n        self.layer_norm_eps = layer_norm_eps\n        self.position_embedding_type = position_embedding_type\n        self.use_cache = use_cache\n        self.head = HeadConfig(**head if head is not None else {})\n        self.lm_head = MaskedLMHeadConfig(**lm_head if lm_head is not None else {})\n</code></pre>"},{"location":"models/utrbert/#multimolecule.models.utrbert.UtrBertForMaskedLM","title":"<code>UtrBertForMaskedLM</code>","text":"<p>               Bases: <code>UtrBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import UtrBertConfig, UtrBertForMaskedLM, RnaTokenizer\n&gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=2)\n&gt;&gt;&gt; config = UtrBertConfig(vocab_size=tokenizer.vocab_size)\n&gt;&gt;&gt; model = UtrBertForMaskedLM(config)\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 6, 31])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/utrbert/modeling_utrbert.py</code> Python<pre><code>class UtrBertForMaskedLM(UtrBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import UtrBertConfig, UtrBertForMaskedLM, RnaTokenizer\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=2)\n        &gt;&gt;&gt; config = UtrBertConfig(vocab_size=tokenizer.vocab_size)\n        &gt;&gt;&gt; model = UtrBertForMaskedLM(config)\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 6, 31])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    _tied_weights_keys = [\"predictions.decoder.bias\", \"cls.predictions.decoder.weight\"]\n\n    def __init__(self, config: UtrBertConfig):\n        super().__init__(config)\n        if config.is_decoder:\n            logger.warning(\n                \"If you want to use `BertForMaskedLM` make sure `config.is_decoder=False` for \"\n                \"bi-directional self-attention.\"\n            )\n        self.utrbert = UtrBertModel(config, add_pooling_layer=False)\n        self.lm_head = MaskedLMHead(config)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_output_embeddings(self):\n        return self.lm_head.decoder\n\n    def set_output_embeddings(self, new_embeddings):\n        self.lm_head.decoder = new_embeddings\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | MaskedLMOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.utrbert(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_attention_mask,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.lm_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return MaskedLMOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/utrbert/#multimolecule.models.utrbert.UtrBertForNucleotidePrediction","title":"<code>UtrBertForNucleotidePrediction</code>","text":"<p>               Bases: <code>UtrBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import UtrBertConfig, UtrBertForNucleotidePrediction, RnaTokenizer\n&gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=2)\n&gt;&gt;&gt; config = UtrBertConfig(vocab_size=tokenizer.vocab_size, nmers=2)\n&gt;&gt;&gt; model = UtrBertForNucleotidePrediction(config)\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 5, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/utrbert/modeling_utrbert.py</code> Python<pre><code>class UtrBertForNucleotidePrediction(UtrBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import UtrBertConfig, UtrBertForNucleotidePrediction, RnaTokenizer\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=2)\n        &gt;&gt;&gt; config = UtrBertConfig(vocab_size=tokenizer.vocab_size, nmers=2)\n        &gt;&gt;&gt; model = UtrBertForNucleotidePrediction(config)\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 5, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: UtrBertConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.utrbert = UtrBertModel(config, add_pooling_layer=False)\n        self.nucleotide_head = NucleotideKMerHead(config)\n        self.head_config = self.nucleotide_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | NucleotidePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.utrbert(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.nucleotide_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return NucleotidePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/utrbert/#multimolecule.models.utrbert.UtrBertForPreTraining","title":"<code>UtrBertForPreTraining</code>","text":"<p>               Bases: <code>UtrBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import UtrBertConfig, UtrBertForPreTraining, RnaTokenizer\n&gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n&gt;&gt;&gt; config = UtrBertConfig(vocab_size=tokenizer.vocab_size)\n&gt;&gt;&gt; model = UtrBertForPreTraining(config)\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input)\n</code></pre> Source code in <code>multimolecule/models/utrbert/modeling_utrbert.py</code> Python<pre><code>class UtrBertForPreTraining(UtrBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import UtrBertConfig, UtrBertForPreTraining, RnaTokenizer\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n        &gt;&gt;&gt; config = UtrBertConfig(vocab_size=tokenizer.vocab_size)\n        &gt;&gt;&gt; model = UtrBertForPreTraining(config)\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input)\n    \"\"\"\n\n    _tied_weights_keys = [\"lm_head.decoder.bias\", \"lm_head.decoder.weight\"]\n\n    def __init__(self, config: UtrBertConfig):\n        super().__init__(config)\n        if config.is_decoder:\n            logger.warning(\n                \"If you want to use `UtrBertForPreTraining` make sure `config.is_decoder=False` for \"\n                \"bi-directional self-attention.\"\n            )\n        self.utrbert = UtrBertModel(config, add_pooling_layer=True)\n        self.lm_head = MaskedLMHead(config)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | MaskedLMOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.utrbert(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.lm_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return MaskedLMOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/utrbert/#multimolecule.models.utrbert.UtrBertForSequencePrediction","title":"<code>UtrBertForSequencePrediction</code>","text":"<p>               Bases: <code>UtrBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import UtrBertConfig, UtrBertForSequencePrediction, RnaTokenizer\n&gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=4)\n&gt;&gt;&gt; config = UtrBertConfig(vocab_size=tokenizer.vocab_size)\n&gt;&gt;&gt; model = UtrBertForSequencePrediction(config)\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.tensor([[1]]))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/utrbert/modeling_utrbert.py</code> Python<pre><code>class UtrBertForSequencePrediction(UtrBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import UtrBertConfig, UtrBertForSequencePrediction, RnaTokenizer\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=4)\n        &gt;&gt;&gt; config = UtrBertConfig(vocab_size=tokenizer.vocab_size)\n        &gt;&gt;&gt; model = UtrBertForSequencePrediction(config)\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.tensor([[1]]))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: UtrBertConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.utrbert = UtrBertModel(config)\n        self.sequence_head = SequencePredictionHead(config)\n        self.head_config = self.sequence_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | SequencePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.utrbert(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.sequence_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return SequencePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/utrbert/#multimolecule.models.utrbert.UtrBertForTokenPrediction","title":"<code>UtrBertForTokenPrediction</code>","text":"<p>               Bases: <code>UtrBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import UtrBertConfig, UtrBertForTokenPrediction, RnaTokenizer\n&gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=2)\n&gt;&gt;&gt; config = UtrBertConfig(vocab_size=tokenizer.vocab_size, nmers=2)\n&gt;&gt;&gt; model = UtrBertForTokenPrediction(config)\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/utrbert/modeling_utrbert.py</code> Python<pre><code>class UtrBertForTokenPrediction(UtrBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import UtrBertConfig, UtrBertForTokenPrediction, RnaTokenizer\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=2)\n        &gt;&gt;&gt; config = UtrBertConfig(vocab_size=tokenizer.vocab_size, nmers=2)\n        &gt;&gt;&gt; model = UtrBertForTokenPrediction(config)\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: UtrBertConfig):\n        super().__init__(config)\n        self.num_labels = config.num_labels\n        self.utrbert = UtrBertModel(config, add_pooling_layer=False)\n        self.token_head = TokenKMerHead(config)\n        self.head_config = self.token_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | TokenPredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.utrbert(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.token_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return TokenPredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/utrbert/#multimolecule.models.utrbert.UtrBertModel","title":"<code>UtrBertModel</code>","text":"<p>               Bases: <code>UtrBertPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import UtrBertConfig, UtrBertModel, RnaTokenizer\n&gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=1)\n&gt;&gt;&gt; config = UtrBertConfig(vocab_size=tokenizer.vocab_size)\n&gt;&gt;&gt; model = UtrBertModel(config)\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input)\n&gt;&gt;&gt; output[\"last_hidden_state\"].shape\ntorch.Size([1, 7, 768])\n&gt;&gt;&gt; output[\"pooler_output\"].shape\ntorch.Size([1, 768])\n</code></pre> Source code in <code>multimolecule/models/utrbert/modeling_utrbert.py</code> Python<pre><code>class UtrBertModel(UtrBertPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import UtrBertConfig, UtrBertModel, RnaTokenizer\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=1)\n        &gt;&gt;&gt; config = UtrBertConfig(vocab_size=tokenizer.vocab_size)\n        &gt;&gt;&gt; model = UtrBertModel(config)\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input)\n        &gt;&gt;&gt; output[\"last_hidden_state\"].shape\n        torch.Size([1, 7, 768])\n        &gt;&gt;&gt; output[\"pooler_output\"].shape\n        torch.Size([1, 768])\n    \"\"\"\n\n    def __init__(self, config: UtrBertConfig, add_pooling_layer: bool = True):\n        super().__init__(config)\n        self.pad_token_id = config.pad_token_id\n        self.embeddings = UtrBertEmbeddings(config)\n        self.encoder = UtrBertEncoder(config)\n        self.pooler = UtrBertPooler(config) if add_pooling_layer else None\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.embeddings.word_embeddings\n\n    def set_input_embeddings(self, value):\n        self.embeddings.word_embeddings = value\n\n    def _prune_heads(self, heads_to_prune):\n        \"\"\"\n        Prunes heads of the model. heads_to_prune: dict of {layer_num: list of heads to prune in this layer} See base\n        class PreTrainedModel\n        \"\"\"\n        for layer, heads in heads_to_prune.items():\n            self.encoder.layer[layer].attention.prune_heads(heads)\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        past_key_values: Tuple[Tuple[torch.FloatTensor, torch.FloatTensor], ...] | None = None,\n        use_cache: bool | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | BaseModelOutputWithPoolingAndCrossAttentions:\n        r\"\"\"\n        encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n            Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n            the model is configured as a decoder.\n        encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n            the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n            - 1 for tokens that are **not masked**,\n            - 0 for tokens that are **masked**.\n        past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors\n            of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n            Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n        use_cache (`bool`, *optional*):\n            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n            `past_key_values`).\n        \"\"\"\n        if kwargs:\n            warn(\n                f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n                f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n                \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n            )\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        if self.config.is_decoder:\n            use_cache = use_cache if use_cache is not None else self.config.use_cache\n        else:\n            use_cache = False\n\n        if isinstance(input_ids, NestedTensor):\n            input_ids, attention_mask = input_ids.tensor, input_ids.mask\n        if input_ids is not None and inputs_embeds is not None:\n            raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n        if input_ids is not None:\n            self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n            input_shape = input_ids.size()\n        elif inputs_embeds is not None:\n            input_shape = inputs_embeds.size()[:-1]\n        else:\n            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n        batch_size, seq_length = input_shape\n        device = input_ids.device if input_ids is not None else inputs_embeds.device  # type: ignore[union-attr]\n\n        # past_key_values_length\n        past_key_values_length = past_key_values[0][0].shape[2] if past_key_values is not None else 0\n\n        if attention_mask is None:\n            attention_mask = (\n                input_ids.ne(self.pad_token_id)\n                if self.pad_token_id is not None\n                else torch.ones(((batch_size, seq_length + past_key_values_length)), device=device)\n            )\n\n        # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n        # ourselves in which case we just need to make it broadcastable to all heads.\n        extended_attention_mask: Tensor = self.get_extended_attention_mask(attention_mask, input_shape)\n\n        # If a 2D or 3D attention mask is provided for the cross-attention\n        # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n        if self.config.is_decoder and encoder_hidden_states is not None:\n            encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n            encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n            if encoder_attention_mask is None:\n                encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n            encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n        else:\n            encoder_extended_attention_mask = None\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n        head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n        embedding_output = self.embeddings(\n            input_ids=input_ids,\n            position_ids=position_ids,\n            inputs_embeds=inputs_embeds,\n            past_key_values_length=past_key_values_length,\n        )\n        encoder_outputs = self.encoder(\n            embedding_output,\n            attention_mask=extended_attention_mask,\n            head_mask=head_mask,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_extended_attention_mask,\n            past_key_values=past_key_values,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n        sequence_output = encoder_outputs[0]\n        pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n        if not return_dict:\n            return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n        return BaseModelOutputWithPoolingAndCrossAttentions(\n            last_hidden_state=sequence_output,\n            pooler_output=pooled_output,\n            past_key_values=encoder_outputs.past_key_values,\n            hidden_states=encoder_outputs.hidden_states,\n            attentions=encoder_outputs.attentions,\n            cross_attentions=encoder_outputs.cross_attentions,\n        )\n</code></pre>"},{"location":"models/utrbert/#multimolecule.models.utrbert.UtrBertModel.forward","title":"<code>forward(input_ids, attention_mask=None, position_ids=None, head_mask=None, inputs_embeds=None, encoder_hidden_states=None, encoder_attention_mask=None, past_key_values=None, use_cache=None, output_attentions=None, output_hidden_states=None, return_dict=None, **kwargs)</code>","text":"<p>encoder_hidden_states  (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, optional):     Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if     the model is configured as a decoder. encoder_attention_mask (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, optional):     Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in     the cross-attention if the model is configured as a decoder. Mask values selected in <code>[0, 1]</code>:</p> Text Only<pre><code>- 1 for tokens that are **not masked**,\n- 0 for tokens that are **masked**.\n</code></pre> <p>past_key_values (<code>tuple(tuple(torch.FloatTensor))</code> of length <code>config.n_layers</code> with each tuple having 4 tensors     of shape <code>(batch_size, num_heads, sequence_length - 1, embed_size_per_head)</code>):     Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.</p> Text Only<pre><code>If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\ndon't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n`decoder_input_ids` of shape `(batch_size, sequence_length)`.\n</code></pre> <p>use_cache (<code>bool</code>, optional):     If set to <code>True</code>, <code>past_key_values</code> key value states are returned and can be used to speed up decoding (see     <code>past_key_values</code>).</p> Source code in <code>multimolecule/models/utrbert/modeling_utrbert.py</code> Python<pre><code>def forward(\n    self,\n    input_ids: Tensor | NestedTensor,\n    attention_mask: Tensor | None = None,\n    position_ids: Tensor | None = None,\n    head_mask: Tensor | None = None,\n    inputs_embeds: Tensor | NestedTensor | None = None,\n    encoder_hidden_states: Tensor | None = None,\n    encoder_attention_mask: Tensor | None = None,\n    past_key_values: Tuple[Tuple[torch.FloatTensor, torch.FloatTensor], ...] | None = None,\n    use_cache: bool | None = None,\n    output_attentions: bool | None = None,\n    output_hidden_states: bool | None = None,\n    return_dict: bool | None = None,\n    **kwargs,\n) -&gt; Tuple[Tensor, ...] | BaseModelOutputWithPoolingAndCrossAttentions:\n    r\"\"\"\n    encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n        Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n        the model is configured as a decoder.\n    encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n        Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n        the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n        - 1 for tokens that are **not masked**,\n        - 0 for tokens that are **masked**.\n    past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors\n        of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n        Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n        If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n        don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n        `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n    use_cache (`bool`, *optional*):\n        If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n        `past_key_values`).\n    \"\"\"\n    if kwargs:\n        warn(\n            f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n            f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n            \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n        )\n    output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n    output_hidden_states = (\n        output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n    )\n    return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n    if self.config.is_decoder:\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n    else:\n        use_cache = False\n\n    if isinstance(input_ids, NestedTensor):\n        input_ids, attention_mask = input_ids.tensor, input_ids.mask\n    if input_ids is not None and inputs_embeds is not None:\n        raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n    if input_ids is not None:\n        self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n        input_shape = input_ids.size()\n    elif inputs_embeds is not None:\n        input_shape = inputs_embeds.size()[:-1]\n    else:\n        raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n    batch_size, seq_length = input_shape\n    device = input_ids.device if input_ids is not None else inputs_embeds.device  # type: ignore[union-attr]\n\n    # past_key_values_length\n    past_key_values_length = past_key_values[0][0].shape[2] if past_key_values is not None else 0\n\n    if attention_mask is None:\n        attention_mask = (\n            input_ids.ne(self.pad_token_id)\n            if self.pad_token_id is not None\n            else torch.ones(((batch_size, seq_length + past_key_values_length)), device=device)\n        )\n\n    # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n    # ourselves in which case we just need to make it broadcastable to all heads.\n    extended_attention_mask: Tensor = self.get_extended_attention_mask(attention_mask, input_shape)\n\n    # If a 2D or 3D attention mask is provided for the cross-attention\n    # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n    if self.config.is_decoder and encoder_hidden_states is not None:\n        encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n        encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n        if encoder_attention_mask is None:\n            encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n        encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n    else:\n        encoder_extended_attention_mask = None\n\n    # Prepare head mask if needed\n    # 1.0 in head_mask indicate we keep the head\n    # attention_probs has shape bsz x n_heads x N x N\n    # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n    # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n    head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n    embedding_output = self.embeddings(\n        input_ids=input_ids,\n        position_ids=position_ids,\n        inputs_embeds=inputs_embeds,\n        past_key_values_length=past_key_values_length,\n    )\n    encoder_outputs = self.encoder(\n        embedding_output,\n        attention_mask=extended_attention_mask,\n        head_mask=head_mask,\n        encoder_hidden_states=encoder_hidden_states,\n        encoder_attention_mask=encoder_extended_attention_mask,\n        past_key_values=past_key_values,\n        use_cache=use_cache,\n        output_attentions=output_attentions,\n        output_hidden_states=output_hidden_states,\n        return_dict=return_dict,\n    )\n    sequence_output = encoder_outputs[0]\n    pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n    if not return_dict:\n        return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n    return BaseModelOutputWithPoolingAndCrossAttentions(\n        last_hidden_state=sequence_output,\n        pooler_output=pooled_output,\n        past_key_values=encoder_outputs.past_key_values,\n        hidden_states=encoder_outputs.hidden_states,\n        attentions=encoder_outputs.attentions,\n        cross_attentions=encoder_outputs.cross_attentions,\n    )\n</code></pre>"},{"location":"models/utrbert/#multimolecule.models.utrbert.UtrBertPreTrainedModel","title":"<code>UtrBertPreTrainedModel</code>","text":"<p>               Bases: <code>PreTrainedModel</code></p> <p>An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained models.</p> Source code in <code>multimolecule/models/utrbert/modeling_utrbert.py</code> Python<pre><code>class UtrBertPreTrainedModel(PreTrainedModel):\n    \"\"\"\n    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n    models.\n    \"\"\"\n\n    config_class = UtrBertConfig\n    base_model_prefix = \"utrbert\"\n    supports_gradient_checkpointing = True\n    _no_split_modules = [\"UtrBertLayer\", \"UtrBertEmbeddings\"]\n\n    # Copied from transformers.models.bert.modeling_bert.BertPreTrainedModel._init_weights\n    def _init_weights(self, module: nn.Module):\n        \"\"\"Initialize the weights\"\"\"\n        if isinstance(module, nn.Linear):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, nn.Embedding):\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.padding_idx is not None:\n                module.weight.data[module.padding_idx].zero_()\n        elif isinstance(module, nn.LayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n</code></pre>"},{"location":"models/utrlm/","title":"UTR-LM","text":"<p>Pre-trained model on 5\u2019 untranslated region (5\u2019UTR) using masked language modeling (MLM), Secondary Structure (SS), and Minimum Free Energy (MFE) objectives.</p>"},{"location":"models/utrlm/#statement","title":"Statement","text":"<p>A 5\u2019 UTR Language Model for Decoding Untranslated Regions of mRNA and Function Predictions is published in Nature Machine Intelligence, which is a Closed Access / Author-Fee Journal.</p> <p>Machine learning has been at the forefront of the movement for free and open access to research.</p> <p>We see no role for closed access or author-fee publication in the future of machine learning research and believe the adoption of these journals as an outlet of record for the machine learning community would be a retrograde step.</p> <p>The MoltiMolecule team is committed to the principles of open access and open science.</p> <p>We do NOT endorse the publication of manuscripts on Closed Access / Author-Fee Journals and encourage the community to support Open Access Journals.</p> <p>Please consider signing the Statement on Nature Machine Intelligence.</p>"},{"location":"models/utrlm/#disclaimer","title":"Disclaimer","text":"<p>This is an UNOFFICIAL implementation of the A 5\u2019 UTR Language Model for Decoding Untranslated Regions of mRNA and Function Predictions by Yanyi Chu, Dan Yu, et al.</p> <p>The OFFICIAL repository of UTR-LM is at a96123155/UTR-LM.</p> <p>The team releasing UTR-LM did not write this model card for this model so this model card has been written by the MultiMolecule team.</p>"},{"location":"models/utrlm/#model-details","title":"Model Details","text":"<p>UTR-LM is a bert-style model pre-trained on a large corpus of 5\u2019 untranslated regions (5\u2019UTRs) in a self-supervised fashion. This means that the model was trained on the raw nucleotides of RNA sequences only, with an automatic process to generate inputs and labels from those texts. Please refer to the Training Details section for more information on the training process.</p>"},{"location":"models/utrlm/#variations","title":"Variations","text":"<ul> <li><code>multimolecule/utrlm.te_el</code>: The UTR-LM model for Translation Efficiency of transcripts and mRNA Expression Level.</li> <li><code>multimolecule/utrlm.mrl</code>: The UTR-LM model for Mean Ribosome Loading.</li> </ul>"},{"location":"models/utrlm/#model-specification","title":"Model Specification","text":"Variants Num Layers Hidden Size Num Heads Intermediate Size Num Parameters (M) FLOPs (G) MACs (G) Max Num Tokens UTR-LM MRL 6 128 16 512 1.21 0.35 0.18 1022 UTR-LM TE_EL"},{"location":"models/utrlm/#links","title":"Links","text":"<ul> <li>Code: multimolecule.utrlm</li> <li>Data:</li> <li>Ensembl Genome Browser</li> <li>Human 5\u2032 UTR design and variant effect prediction from a massively parallel translation assay</li> <li>High-Throughput 5\u2019 UTR Engineering for Enhanced Protein Production in Non-Viral Gene Therapies</li> <li>Paper: A 5\u2019 UTR Language Model for Decoding Untranslated Regions of mRNA and Function Predictions</li> <li>Developed by: Yanyi Chu, Dan Yu, Yupeng Li, Kaixuan Huang, Yue Shen, Le Cong, Jason Zhang, Mengdi Wang</li> <li>Model type: BERT - ESM</li> <li>Original Repository: https://github.com/a96123155/UTR-LM</li> </ul>"},{"location":"models/utrlm/#usage","title":"Usage","text":"<p>The model file depends on the <code>multimolecule</code> library. You can install it using pip:</p> Bash<pre><code>pip install multimolecule\n</code></pre>"},{"location":"models/utrlm/#direct-use","title":"Direct Use","text":"<p>You can use this model directly with a pipeline for masked language modeling:</p> Python<pre><code>&gt;&gt;&gt; import multimolecule  # you must import multimolecule to register models\n&gt;&gt;&gt; from transformers import pipeline\n&gt;&gt;&gt; unmasker = pipeline('fill-mask', model='multimolecule/utrlm.te_el')\n&gt;&gt;&gt; unmasker(\"uagc&lt;mask&gt;uaucagacugauguuga\")\n\n[{'score': 0.07525687664747238,\n  'token': 11,\n  'token_str': 'I',\n  'sequence': 'U A G C I U A U C A G A C U G A U G U U G A'},\n {'score': 0.07319962233304977,\n  'token': 6,\n  'token_str': 'A',\n  'sequence': 'U A G C A U A U C A G A C U G A U G U U G A'},\n {'score': 0.07106836140155792,\n  'token': 24,\n  'token_str': '*',\n  'sequence': 'U A G C * U A U C A G A C U G A U G U U G A'},\n {'score': 0.06967106461524963,\n  'token': 10,\n  'token_str': 'N',\n  'sequence': 'U A G C N U A U C A G A C U G A U G U U G A'},\n {'score': 0.06574146449565887,\n  'token': 19,\n  'token_str': 'W',\n  'sequence': 'U A G C W U A U C A G A C U G A U G U U G A'}]\n</code></pre>"},{"location":"models/utrlm/#downstream-use","title":"Downstream Use","text":""},{"location":"models/utrlm/#extract-features","title":"Extract Features","text":"<p>Here is how to use this model to get the features of a given sequence in PyTorch:</p> Python<pre><code>from multimolecule import RnaTokenizer, UtrLmModel\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/utrlm.te_el')\nmodel = UtrLmModel.from_pretrained('multimolecule/utrlm.te_el')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\n\noutput = model(**input)\n</code></pre>"},{"location":"models/utrlm/#sequence-classification-regression","title":"Sequence Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for sequence classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a sequence-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, UtrLmForSequencePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/utrlm.te_el')\nmodel = UtrLmForSequencePrediction.from_pretrained('multimolecule/utrlm.te_el')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.tensor([1])\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/utrlm/#nucleotide-classification-regression","title":"Nucleotide Classification / Regression","text":"<p>Note: This model is not fine-tuned for any specific task. You will need to fine-tune the model on a downstream task to use it for nucleotide classification or regression.</p> <p>Here is how to use this model as backbone to fine-tune for a nucleotide-level task in PyTorch:</p> Python<pre><code>import torch\nfrom multimolecule import RnaTokenizer, UtrLmForNucleotidePrediction\n\n\ntokenizer = RnaTokenizer.from_pretrained('multimolecule/utrlm.te_el')\nmodel = UtrLmForNucleotidePrediction.from_pretrained('multimolecule/utrlm.te_el')\n\ntext = \"UAGCUUAUCAGACUGAUGUUGA\"\ninput = tokenizer(text, return_tensors='pt')\nlabel = torch.randint(2, (len(text), ))\n\noutput = model(**input, labels=label)\n</code></pre>"},{"location":"models/utrlm/#training-details","title":"Training Details","text":"<p>UTR-LM used a mixed training strategy with one self-supervised task and two supervised tasks, where the labels of both supervised tasks are calculated using [ViennaRNA](https://viennarna.readthedocs.io.</p> <ol> <li>Masked Language Modeling (MLM): taking a sequence, the model randomly masks 15% of the tokens in the input then runs the entire masked sentence through the model and has to predict the masked tokens. This is comparable to the Cloze task in language modeling.</li> <li>Secondary Structure (SS): predicting the secondary structure of the <code>&lt;mask&gt;</code> token in the MLM task.</li> <li>Minimum Free Energy (MFE): predicting the minimum free energy of the 5\u2019 UTR sequence.</li> </ol>"},{"location":"models/utrlm/#training-data","title":"Training Data","text":"<p>The UTR-LM model was pre-trained on 5\u2019 UTR sequences from three sources:</p> <ul> <li>Ensembl Genome Browser: Ensembl is a genome browser for vertebrate genomes that supports research in comparative genomics, evolution, sequence variation and transcriptional regulation. UTR-LM used 5\u2019 UTR sequences from 5 species: human, rat, mouse, chicken, and zebrafish, since these species have high-quality and manual gene annotations.</li> <li>Human 5\u2032 UTR design and variant effect prediction from a massively parallel translation assay: Sample et al. proposed 8 distinct 5\u2019 UTR libraries, each containing random 50 nucleotide sequences, to evaluate translation rules using mean ribosome loading (MRL) measurements.</li> <li>High-Throughput 5\u2019 UTR Engineering for Enhanced Protein Production in Non-Viral Gene Therapies: Cao et al. analyzed endogenous human 5\u2019 UTRs, including data from 3 distinct cell lines/tissues: human embryonic kidney 293T (HEK), human prostate cancer cell (PC3), and human muscle tissue (Muscle).</li> </ul> <p>UTR-LM preprocessed the 5\u2019 UTR sequences in a 4-step pipeline:</p> <ol> <li>removed all coding sequence (CDS) and non-5\u2019 UTR fragments from the raw sequences.</li> <li>identified and removed duplicate sequences</li> <li>truncated the sequences to fit within a range of 30 to 1022 bp</li> <li>filtered out incorrect and low-quality sequences</li> </ol> <p>Note <code>RnaTokenizer</code> will convert \u201cT\u201ds to \u201cU\u201ds for you, you may disable this behaviour by passing <code>replace_T_with_U=False</code>.</p>"},{"location":"models/utrlm/#training-procedure","title":"Training Procedure","text":""},{"location":"models/utrlm/#preprocessing","title":"Preprocessing","text":"<p>UTR-LM used masked language modeling (MLM) as one of the pre-training objectives. The masking procedure is similar to the one used in BERT:</p> <ul> <li>15% of the tokens are masked.</li> <li>In 80% of the cases, the masked tokens are replaced by <code>&lt;mask&gt;</code>.</li> <li>In 10% of the cases, the masked tokens are replaced by a random token (different) from the one they replace.</li> <li>In the 10% remaining cases, the masked tokens are left as is.</li> </ul>"},{"location":"models/utrlm/#pretraining","title":"PreTraining","text":"<p>The model was trained on two clusters:</p> <ol> <li>4 NVIDIA V100 GPUs with 16GiB memories.</li> <li>4 NVIDIA P100 GPUs with 32GiB memories.</li> </ol>"},{"location":"models/utrlm/#citation","title":"Citation","text":"<p>BibTeX:</p> BibTeX<pre><code>@article {chu2023a,\n    author = {Chu, Yanyi and Yu, Dan and Li, Yupeng and Huang, Kaixuan and Shen, Yue and Cong, Le and Zhang, Jason and Wang, Mengdi},\n    title = {A 5{\\textquoteright} UTR Language Model for Decoding Untranslated Regions of mRNA and Function Predictions},\n    elocation-id = {2023.10.11.561938},\n    year = {2023},\n    doi = {10.1101/2023.10.11.561938},\n    publisher = {Cold Spring Harbor Laboratory},\n    abstract = {The 5{\\textquoteright} UTR, a regulatory region at the beginning of an mRNA molecule, plays a crucial role in regulating the translation process and impacts the protein expression level. Language models have showcased their effectiveness in decoding the functions of protein and genome sequences. Here, we introduced a language model for 5{\\textquoteright} UTR, which we refer to as the UTR-LM. The UTR-LM is pre-trained on endogenous 5{\\textquoteright} UTRs from multiple species and is further augmented with supervised information including secondary structure and minimum free energy. We fine-tuned the UTR-LM in a variety of downstream tasks. The model outperformed the best-known benchmark by up to 42\\% for predicting the Mean Ribosome Loading, and by up to 60\\% for predicting the Translation Efficiency and the mRNA Expression Level. The model also applies to identifying unannotated Internal Ribosome Entry Sites within the untranslated region and improves the AUPR from 0.37 to 0.52 compared to the best baseline. Further, we designed a library of 211 novel 5{\\textquoteright} UTRs with high predicted values of translation efficiency and evaluated them via a wet-lab assay. Experiment results confirmed that our top designs achieved a 32.5\\% increase in protein production level relative to well-established 5{\\textquoteright} UTR optimized for therapeutics.Competing Interest StatementThe authors have declared no competing interest.},\n    URL = {https://www.biorxiv.org/content/early/2023/10/14/2023.10.11.561938},\n    eprint = {https://www.biorxiv.org/content/early/2023/10/14/2023.10.11.561938.full.pdf},\n    journal = {bioRxiv}\n}\n</code></pre>"},{"location":"models/utrlm/#contact","title":"Contact","text":"<p>Please use GitHub issues of MultiMolecule for any questions or comments on the model card.</p> <p>Please contact the authors of the UTR-LM paper for questions or comments on the paper/model.</p>"},{"location":"models/utrlm/#license","title":"License","text":"<p>This model is licensed under the AGPL-3.0 License.</p> Text Only<pre><code>SPDX-License-Identifier: AGPL-3.0-or-later\n</code></pre>"},{"location":"models/utrlm/#multimolecule.models.utrlm","title":"<code>multimolecule.models.utrlm</code>","text":""},{"location":"models/utrlm/#multimolecule.models.utrlm.RnaTokenizer","title":"<code>RnaTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>Constructs an RNA tokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>alphabet</code> <code>List[str] | None</code> <p>List of tokens to use. Defaults to IUPAC nucleotide code.</p> <code>None</code> <code>nmers</code> <code>int</code> <p>Size of nmers to tokenize. Defaults to 1.</p> <code>1</code> <code>codon</code> <code>bool</code> <p>Whether to tokenize into codons. Defaults to False.</p> <code>False</code> <code>replace_T_with_U</code> <code>bool</code> <p>Whether to replace T with U. Defaults to True.</p> <code>True</code> <code>do_upper_case</code> <code>bool</code> <p>Whether to convert input to uppercase. Defaults to True.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaTokenizer\n&gt;&gt;&gt; tokenizer = RnaTokenizer()\n&gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n[1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n&gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 3, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 17, 64, 49, 96, 84, 22, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 49, 22, 2]\n&gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\nTraceback (most recent call last):\nValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n</code></pre> Source code in <code>multimolecule/tokenisers/rna/tokenization_rna.py</code> Python<pre><code>class RnaTokenizer(Tokenizer):\n    \"\"\"\n    Constructs an RNA tokenizer.\n\n    Args:\n        alphabet (List[str] | None, optional): List of tokens to use.\n            Defaults to [IUPAC nucleotide code](https://www.bioinformatics.org/sms2/iupac.html).\n        nmers (int, optional): Size of nmers to tokenize.\n            Defaults to 1.\n        codon (bool, optional): Whether to tokenize into codons.\n            Defaults to False.\n        replace_T_with_U (bool, optional): Whether to replace T with U.\n            Defaults to True.\n        do_upper_case (bool, optional): Whether to convert input to uppercase.\n            Defaults to True.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaTokenizer\n        &gt;&gt;&gt; tokenizer = RnaTokenizer()\n        &gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n        [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n        &gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 3, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 17, 64, 49, 96, 84, 22, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 49, 22, 2]\n        &gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\n        Traceback (most recent call last):\n        ValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n    \"\"\"\n\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n\n    def __init__(\n        self,\n        alphabet: List[str] | None = None,\n        nmers: int = 1,\n        codon: bool = False,\n        replace_T_with_U: bool = True,\n        bos_token: str = \"&lt;cls&gt;\",\n        cls_token: str = \"&lt;cls&gt;\",\n        pad_token: str = \"&lt;pad&gt;\",\n        eos_token: str = \"&lt;eos&gt;\",\n        sep_token: str = \"&lt;eos&gt;\",\n        unk_token: str = \"&lt;unk&gt;\",\n        mask_token: str = \"&lt;mask&gt;\",\n        additional_special_tokens: List | Tuple | None = None,\n        do_upper_case: bool = True,\n        **kwargs,\n    ):\n        if codon and nmers &gt; 1:\n            raise ValueError(\"Codon and nmers cannot be used together.\")\n        if codon:\n            nmers = 3  # set to 3 to get correct vocab\n        super().__init__(\n            alphabet=get_vocab_list(alphabet, nmers),\n            bos_token=bos_token,\n            cls_token=cls_token,\n            pad_token=pad_token,\n            eos_token=eos_token,\n            sep_token=sep_token,\n            unk_token=unk_token,\n            mask_token=mask_token,\n            additional_special_tokens=additional_special_tokens,\n            do_upper_case=do_upper_case,\n            **kwargs,\n        )\n        self.replace_T_with_U = replace_T_with_U\n        self.nmers = nmers\n        self.condon = codon\n\n    def _tokenize(self, text: str, **kwargs):\n        if self.do_upper_case:\n            text = text.upper()\n        if self.replace_T_with_U:\n            text = text.replace(\"T\", \"U\")\n        if self.condon:\n            if len(text) % 3 != 0:\n                raise ValueError(\n                    f\"length of input sequence  must be a multiple of 3 for codon tokenization, but got {len(text)}\"\n                )\n            return [text[i : i + 3] for i in range(0, len(text), 3)]\n        if self.nmers &gt; 1:\n            return [text[i : i + self.nmers] for i in range(len(text) - self.nmers + 1)]  # noqa: E203\n        return list(text)\n</code></pre>"},{"location":"models/utrlm/#multimolecule.models.utrlm.UtrLmConfig","title":"<code>UtrLmConfig</code>","text":"<p>               Bases: <code>PreTrainedConfig</code></p> <p>This is the configuration class to store the configuration of a [<code>UtrLmModel</code>]. It is used to instantiate a RNA-FM model according to the specified arguments, defining the model architecture. Instantiating a configuration with the defaults will yield a similar configuration to that of the RNA-FM a96123155/UTR-LM architecture.</p> <p>Configuration objects inherit from [<code>PreTrainedConfig</code>] and can be used to control the model outputs. Read the documentation from [<code>PreTrainedConfig</code>] for more information.</p> <p>Parameters:</p> Name Type Description Default <code>vocab_size</code> <code>`int`, *optional*, defaults to 26</code> <p>Vocabulary size of the RNA-FM model. Defines the number of different tokens that can be represented by the <code>inputs_ids</code> passed when calling [<code>UtrLmModel</code>].</p> <code>26</code> <code>hidden_size</code> <code>`int`, *optional*, defaults to 512</code> <p>Dimensionality of the encoder layers and the pooler layer.</p> <code>128</code> <code>num_hidden_layers</code> <code>`int`, *optional*, defaults to 6</code> <p>Number of hidden layers in the Transformer encoder.</p> <code>6</code> <code>num_attention_heads</code> <code>`int`, *optional*, defaults to 12</code> <p>Number of attention heads for each attention layer in the Transformer encoder.</p> <code>16</code> <code>intermediate_size</code> <code>`int`, *optional*, defaults to 2048</code> <p>Dimensionality of the \u201cintermediate\u201d (often named feed-forward) layer in the Transformer encoder.</p> <code>512</code> <code>hidden_dropout</code> <code>`float`, *optional*, defaults to 0.1</code> <p>The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.</p> <code>0.1</code> <code>attention_dropout</code> <code>`float`, *optional*, defaults to 0.1</code> <p>The dropout ratio for the attention probabilities.</p> <code>0.1</code> <code>max_position_embeddings</code> <code>`int`, *optional*, defaults to 1026</code> <p>The maximum sequence length that this model might ever be used with. Typically set this to something large just in case (e.g., 512 or 1024 or 2048).</p> <code>1026</code> <code>initializer_range</code> <code>`float`, *optional*, defaults to 0.02</code> <p>The standard deviation of the truncated_normal_initializer for initializing all weight matrices.</p> <code>0.02</code> <code>layer_norm_eps</code> <code>`float`, *optional*, defaults to 1e-12</code> <p>The epsilon used by the layer normalization layers.</p> <code>1e-12</code> <code>pad_token_id</code> <code>`int`, *optional*, defaults to 0</code> <p>The index of the padding token in the vocabulary. This must be included in the config because certain parts of the RnaBert code use this instead of the attention mask.</p> required <code>bos_token_id</code> <code>`int`, *optional*, defaults to 1</code> <p>The index of the bos token in the vocabulary. This must be included in the config because of the contact and other prediction heads removes the bos and padding token when predicting outputs.</p> required <code>mask_token_id</code> <code>`int`, *optional*, defaults to 4</code> <p>The index of the mask token in the vocabulary. This must be included in the config because of the \u201cmask-dropout\u201d scaling trick, which will scale the inputs depending on the number of masked tokens.</p> required <code>position_embedding_type</code> <code>`str`, *optional*, defaults to `\"absolute\"`</code> <p>Type of position embedding. Choose one of <code>\"absolute\"</code>, <code>\"relative_key\"</code>, <code>\"relative_key_query\", \"rotary\"</code>. For positional embeddings use <code>\"absolute\"</code>. For more information on <code>\"relative_key\"</code>, please refer to Self-Attention with Relative Position Representations (Shaw et al.). For more information on <code>\"relative_key_query\"</code>, please refer to Method 4 in Improve Transformer Models with Better Relative Position Embeddings (Huang et al.).</p> <code>'rotary'</code> <code>is_decoder</code> <code>`bool`, *optional*, defaults to `False`</code> <p>Whether the model is used as a decoder or not. If <code>False</code>, the model is used as an encoder.</p> required <code>use_cache</code> <code>`bool`, *optional*, defaults to `True`</code> <p>Whether or not the model should return the last key/values attentions (not used by all models). Only relevant if <code>config.is_decoder=True</code>.</p> <code>True</code> <code>emb_layer_norm_before</code> <code>`bool`, *optional*</code> <p>Whether to apply layer normalization after embeddings but before the main stem of the network.</p> <code>None</code> <code>token_dropout</code> <code>`bool`, defaults to `False`</code> <p>When this is enabled, masked tokens are treated as if they had been dropped out by input dropout.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import UtrLmModel, UtrLmConfig\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a UTR-LM multimolecule/utrlm style configuration\n&gt;&gt;&gt; configuration = UtrLmConfig()\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/utrlm style configuration\n&gt;&gt;&gt; model = UtrLmModel(configuration)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Accessing the model configuration\n&gt;&gt;&gt; configuration = model.config\n</code></pre> Source code in <code>multimolecule/models/utrlm/configuration_utrlm.py</code> Python<pre><code>class UtrLmConfig(PreTrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`UtrLmModel`]. It is used to instantiate a RNA-FM\n    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n    defaults will yield a similar configuration to that of the RNA-FM\n    [a96123155/UTR-LM](https://github.com/a96123155/UTR-LM) architecture.\n\n    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n    documentation from [`PreTrainedConfig`] for more information.\n\n\n    Args:\n        vocab_size (`int`, *optional*, defaults to 26):\n            Vocabulary size of the RNA-FM model. Defines the number of different tokens that can be represented by the\n            `inputs_ids` passed when calling [`UtrLmModel`].\n        hidden_size (`int`, *optional*, defaults to 512):\n            Dimensionality of the encoder layers and the pooler layer.\n        num_hidden_layers (`int`, *optional*, defaults to 6):\n            Number of hidden layers in the Transformer encoder.\n        num_attention_heads (`int`, *optional*, defaults to 12):\n            Number of attention heads for each attention layer in the Transformer encoder.\n        intermediate_size (`int`, *optional*, defaults to 2048):\n            Dimensionality of the \"intermediate\" (often named feed-forward) layer in the Transformer encoder.\n        hidden_dropout (`float`, *optional*, defaults to 0.1):\n            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n        attention_dropout (`float`, *optional*, defaults to 0.1):\n            The dropout ratio for the attention probabilities.\n        max_position_embeddings (`int`, *optional*, defaults to 1026):\n            The maximum sequence length that this model might ever be used with. Typically set this to something large\n            just in case (e.g., 512 or 1024 or 2048).\n        initializer_range (`float`, *optional*, defaults to 0.02):\n            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n        layer_norm_eps (`float`, *optional*, defaults to 1e-12):\n            The epsilon used by the layer normalization layers.\n        pad_token_id (`int`, *optional*, defaults to 0):\n            The index of the padding token in the vocabulary. This must be included in the config because certain parts\n            of the RnaBert code use this instead of the attention mask.\n        bos_token_id (`int`, *optional*, defaults to 1):\n            The index of the bos token in the vocabulary. This must be included in the config because of the\n            contact and other prediction heads removes the bos and padding token when predicting outputs.\n        mask_token_id (`int`, *optional*, defaults to 4):\n            The index of the mask token in the vocabulary. This must be included in the config because of the\n            \"mask-dropout\" scaling trick, which will scale the inputs depending on the number of masked tokens.\n        position_embedding_type (`str`, *optional*, defaults to `\"absolute\"`):\n            Type of position embedding. Choose one of `\"absolute\"`, `\"relative_key\"`, `\"relative_key_query\", \"rotary\"`.\n            For positional embeddings use `\"absolute\"`. For more information on `\"relative_key\"`, please refer to\n            [Self-Attention with Relative Position Representations (Shaw et al.)](https://arxiv.org/abs/1803.02155).\n            For more information on `\"relative_key_query\"`, please refer to *Method 4* in [Improve Transformer Models\n            with Better Relative Position Embeddings (Huang et al.)](https://arxiv.org/abs/2009.13658).\n        is_decoder (`bool`, *optional*, defaults to `False`):\n            Whether the model is used as a decoder or not. If `False`, the model is used as an encoder.\n        use_cache (`bool`, *optional*, defaults to `True`):\n            Whether or not the model should return the last key/values attentions (not used by all models). Only\n            relevant if `config.is_decoder=True`.\n        emb_layer_norm_before (`bool`, *optional*):\n            Whether to apply layer normalization after embeddings but before the main stem of the network.\n        token_dropout (`bool`, defaults to `False`):\n            When this is enabled, masked tokens are treated as if they had been dropped out by input dropout.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import UtrLmModel, UtrLmConfig\n\n        &gt;&gt;&gt; # Initializing a UTR-LM multimolecule/utrlm style configuration\n        &gt;&gt;&gt; configuration = UtrLmConfig()\n\n        &gt;&gt;&gt; # Initializing a model (with random weights) from the multimolecule/utrlm style configuration\n        &gt;&gt;&gt; model = UtrLmModel(configuration)\n\n        &gt;&gt;&gt; # Accessing the model configuration\n        &gt;&gt;&gt; configuration = model.config\n    \"\"\"\n\n    model_type = \"utrlm\"\n\n    def __init__(\n        self,\n        vocab_size=26,\n        hidden_size=128,\n        num_hidden_layers=6,\n        num_attention_heads=16,\n        intermediate_size=512,\n        hidden_act=\"gelu\",\n        hidden_dropout=0.1,\n        attention_dropout=0.1,\n        max_position_embeddings=1026,\n        initializer_range=0.02,\n        layer_norm_eps=1e-12,\n        position_embedding_type=\"rotary\",\n        use_cache=True,\n        emb_layer_norm_before=None,\n        token_dropout=True,\n        head=None,\n        lm_head=None,\n        ss_head=None,\n        mfe_head=None,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n\n        self.vocab_size = vocab_size\n        self.hidden_size = hidden_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_attention_heads = num_attention_heads\n        self.intermediate_size = intermediate_size\n        self.hidden_act = hidden_act\n        self.hidden_dropout = hidden_dropout\n        self.attention_dropout = attention_dropout\n        self.max_position_embeddings = max_position_embeddings\n        self.initializer_range = initializer_range\n        self.layer_norm_eps = layer_norm_eps\n        self.position_embedding_type = position_embedding_type\n        self.use_cache = use_cache\n        self.emb_layer_norm_before = emb_layer_norm_before\n        self.token_dropout = token_dropout\n        self.head = HeadConfig(**head if head is not None else {})\n        self.lm_head = MaskedLMHeadConfig(**lm_head if lm_head is not None else {})\n        self.ss_head = HeadConfig(**ss_head) if ss_head is not None else None\n        self.mfe_head = HeadConfig(**mfe_head) if mfe_head is not None else None\n</code></pre>"},{"location":"models/utrlm/#multimolecule.models.utrlm.UtrLmForMaskedLM","title":"<code>UtrLmForMaskedLM</code>","text":"<p>               Bases: <code>UtrLmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import UtrLmConfig, UtrLmModel, RnaTokenizer\n&gt;&gt;&gt; config = UtrLmConfig()\n&gt;&gt;&gt; model = UtrLmForMaskedLM(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 26])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/utrlm/modeling_utrlm.py</code> Python<pre><code>class UtrLmForMaskedLM(UtrLmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import UtrLmConfig, UtrLmModel, RnaTokenizer\n        &gt;&gt;&gt; config = UtrLmConfig()\n        &gt;&gt;&gt; model = UtrLmForMaskedLM(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=input[\"input_ids\"])\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 26])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    _tied_weights_keys = [\"lm_head.decoder.weight\"]\n\n    def __init__(self, config: UtrLmConfig):\n        super().__init__(config)\n        if config.is_decoder:\n            logger.warning(\n                \"If you want to use `UtrLmForMaskedLM` make sure `config.is_decoder=False` for \"\n                \"bi-directional self-attention.\"\n            )\n        self.utrlm = UtrLmModel(config, add_pooling_layer=False)\n        self.lm_head = MaskedLMHead(config)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | MaskedLMOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.utrlm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_attention_mask,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.lm_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return MaskedLMOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/utrlm/#multimolecule.models.utrlm.UtrLmForNucleotidePrediction","title":"<code>UtrLmForNucleotidePrediction</code>","text":"<p>               Bases: <code>UtrLmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import UtrLmConfig, UtrLmForNucleotidePrediction, RnaTokenizer\n&gt;&gt;&gt; config = UtrLmConfig()\n&gt;&gt;&gt; model = UtrLmForNucleotidePrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 5, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/utrlm/modeling_utrlm.py</code> Python<pre><code>class UtrLmForNucleotidePrediction(UtrLmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import UtrLmConfig, UtrLmForNucleotidePrediction, RnaTokenizer\n        &gt;&gt;&gt; config = UtrLmConfig()\n        &gt;&gt;&gt; model = UtrLmForNucleotidePrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randn(1, 5, 2))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 5, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;BinaryCrossEntropyWithLogitsBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: UtrLmConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.utrlm = UtrLmModel(config, add_pooling_layer=True)\n        self.nucleotide_head = NucleotidePredictionHead(config)\n        self.head_config = self.nucleotide_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | NucleotidePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.utrlm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.nucleotide_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return NucleotidePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/utrlm/#multimolecule.models.utrlm.UtrLmForPreTraining","title":"<code>UtrLmForPreTraining</code>","text":"<p>               Bases: <code>UtrLmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import UtrLmConfig, UtrLmModel, RnaTokenizer\n&gt;&gt;&gt; config = UtrLmConfig()\n&gt;&gt;&gt; model = UtrLmForPreTraining(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels_mlm=input[\"input_ids\"])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;AddBackward0&gt;)\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 26])\n&gt;&gt;&gt; output[\"contact_map\"].shape\ntorch.Size([1, 5, 5, 2])\n</code></pre> Source code in <code>multimolecule/models/utrlm/modeling_utrlm.py</code> Python<pre><code>class UtrLmForPreTraining(UtrLmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import UtrLmConfig, UtrLmModel, RnaTokenizer\n        &gt;&gt;&gt; config = UtrLmConfig()\n        &gt;&gt;&gt; model = UtrLmForPreTraining(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels_mlm=input[\"input_ids\"])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;AddBackward0&gt;)\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 26])\n        &gt;&gt;&gt; output[\"contact_map\"].shape\n        torch.Size([1, 5, 5, 2])\n    \"\"\"\n\n    _tied_weights_keys = [\"head.predictions.decoder.weight\"]\n\n    def __init__(self, config: UtrLmConfig):\n        super().__init__(config)\n        if config.is_decoder:\n            logger.warning(\n                \"If you want to use `UtrLmForPreTraining` make sure `config.is_decoder=False` for \"\n                \"bi-directional self-attention.\"\n            )\n        self.utrlm = UtrLmModel(config, add_pooling_layer=False)\n        self.pretrain_head = UtrLmPreTrainingHeads(config)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_output_embeddings(self):\n        return self.pretrain_head.predictions.decoder\n\n    def set_output_embeddings(self, embeddings):\n        self.pretrain_head.predictions.decoder = embeddings\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        labels_mlm: Tensor | None = None,\n        labels_contact: Tensor | None = None,\n        labels_ss: Tensor | None = None,\n        labels_mfe: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | UtrLmForPreTrainingOutput:\n        if output_attentions is False:\n            warn(\"output_attentions must be True for contact classification and will be ignored.\")\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.utrlm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_attention_mask,\n            output_attentions=True,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        total_loss, logits, contact_map, secondary_structure, minimum_free_energy = self.pretrain_head(\n            outputs,\n            attention_mask,\n            input_ids,\n            labels_mlm=labels_mlm,\n            labels_contact=labels_contact,\n            labels_ss=labels_ss,\n            labels_mfe=labels_mfe,\n        )\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((total_loss,) + output) if total_loss is not None else output\n\n        return UtrLmForPreTrainingOutput(\n            loss=total_loss,\n            logits=logits,\n            contact_map=contact_map,\n            secondary_structure=secondary_structure,\n            minimum_free_energy=minimum_free_energy,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/utrlm/#multimolecule.models.utrlm.UtrLmForSequencePrediction","title":"<code>UtrLmForSequencePrediction</code>","text":"<p>               Bases: <code>UtrLmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import UtrLmConfig, UtrLmModel, RnaTokenizer\n&gt;&gt;&gt; config = UtrLmConfig()\n&gt;&gt;&gt; model = UtrLmForSequencePrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.tensor([[1]]))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/utrlm/modeling_utrlm.py</code> Python<pre><code>class UtrLmForSequencePrediction(UtrLmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import UtrLmConfig, UtrLmModel, RnaTokenizer\n        &gt;&gt;&gt; config = UtrLmConfig()\n        &gt;&gt;&gt; model = UtrLmForSequencePrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.tensor([[1]]))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: UtrLmConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.utrlm = UtrLmModel(config, add_pooling_layer=True)\n        self.sequence_head = SequencePredictionHead(config)\n        self.head_config = self.sequence_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | SequencePredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.utrlm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.sequence_head(outputs, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return SequencePredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/utrlm/#multimolecule.models.utrlm.UtrLmForTokenPrediction","title":"<code>UtrLmForTokenPrediction</code>","text":"<p>               Bases: <code>UtrLmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import UtrLmConfig, UtrLmModel, RnaTokenizer\n&gt;&gt;&gt; config = UtrLmConfig()\n&gt;&gt;&gt; model = UtrLmForTokenPrediction(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n&gt;&gt;&gt; output[\"logits\"].shape\ntorch.Size([1, 7, 2])\n&gt;&gt;&gt; output[\"loss\"]\ntensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n</code></pre> Source code in <code>multimolecule/models/utrlm/modeling_utrlm.py</code> Python<pre><code>class UtrLmForTokenPrediction(UtrLmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import UtrLmConfig, UtrLmModel, RnaTokenizer\n        &gt;&gt;&gt; config = UtrLmConfig()\n        &gt;&gt;&gt; model = UtrLmForTokenPrediction(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input, labels=torch.randint(2, (1, 7)))\n        &gt;&gt;&gt; output[\"logits\"].shape\n        torch.Size([1, 7, 2])\n        &gt;&gt;&gt; output[\"loss\"]  # doctest:+ELLIPSIS\n        tensor(..., grad_fn=&lt;NllLossBackward0&gt;)\n    \"\"\"\n\n    def __init__(self, config: UtrLmConfig):\n        super().__init__(config)\n        self.num_labels = config.head.num_labels\n        self.utrlm = UtrLmModel(config, add_pooling_layer=True)\n        self.token_head = TokenPredictionHead(config)\n        self.head_config = self.token_head.config\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        labels: Tensor | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | TokenPredictorOutput:\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        outputs = self.utrlm(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            **kwargs,\n        )\n        output = self.token_head(outputs, attention_mask, input_ids, labels)\n        logits, loss = output.logits, output.loss\n\n        if not return_dict:\n            output = (logits,) + outputs[2:]\n            return ((loss,) + output) if loss is not None else output\n\n        return TokenPredictorOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n</code></pre>"},{"location":"models/utrlm/#multimolecule.models.utrlm.UtrLmModel","title":"<code>UtrLmModel</code>","text":"<p>               Bases: <code>UtrLmPreTrainedModel</code></p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import UtrLmConfig, UtrLmModel, RnaTokenizer\n&gt;&gt;&gt; config = UtrLmConfig()\n&gt;&gt;&gt; model = UtrLmModel(config)\n&gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n&gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n&gt;&gt;&gt; output = model(**input)\n&gt;&gt;&gt; output[\"last_hidden_state\"].shape\ntorch.Size([1, 7, 128])\n&gt;&gt;&gt; output[\"pooler_output\"].shape\ntorch.Size([1, 128])\n</code></pre> Source code in <code>multimolecule/models/utrlm/modeling_utrlm.py</code> Python<pre><code>class UtrLmModel(UtrLmPreTrainedModel):\n    \"\"\"\n    Examples:\n        &gt;&gt;&gt; from multimolecule import UtrLmConfig, UtrLmModel, RnaTokenizer\n        &gt;&gt;&gt; config = UtrLmConfig()\n        &gt;&gt;&gt; model = UtrLmModel(config)\n        &gt;&gt;&gt; tokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rna\")\n        &gt;&gt;&gt; input = tokenizer(\"ACGUN\", return_tensors=\"pt\")\n        &gt;&gt;&gt; output = model(**input)\n        &gt;&gt;&gt; output[\"last_hidden_state\"].shape\n        torch.Size([1, 7, 128])\n        &gt;&gt;&gt; output[\"pooler_output\"].shape\n        torch.Size([1, 128])\n    \"\"\"\n\n    def __init__(self, config: UtrLmConfig, add_pooling_layer: bool = True):\n        super().__init__(config)\n        self.pad_token_id = config.pad_token_id\n        self.embeddings = UtrLmEmbeddings(config)\n        self.encoder = UtrLmEncoder(config)\n        self.pooler = UtrLmPooler(config) if add_pooling_layer else None\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.embeddings.word_embeddings\n\n    def set_input_embeddings(self, value):\n        self.embeddings.word_embeddings = value\n\n    def _prune_heads(self, heads_to_prune):\n        \"\"\"\n        Prunes heads of the model. heads_to_prune: dict of {layer_num: list of heads to prune in this layer} See base\n        class PreTrainedModel\n        \"\"\"\n        for layer, heads in heads_to_prune.items():\n            self.encoder.layer[layer].attention.prune_heads(heads)\n\n    def forward(\n        self,\n        input_ids: Tensor | NestedTensor,\n        attention_mask: Tensor | None = None,\n        position_ids: Tensor | None = None,\n        head_mask: Tensor | None = None,\n        inputs_embeds: Tensor | NestedTensor | None = None,\n        encoder_hidden_states: Tensor | None = None,\n        encoder_attention_mask: Tensor | None = None,\n        past_key_values: Tuple[Tuple[torch.FloatTensor, torch.FloatTensor], ...] | None = None,\n        use_cache: bool | None = None,\n        output_attentions: bool | None = None,\n        output_hidden_states: bool | None = None,\n        return_dict: bool | None = None,\n        **kwargs,\n    ) -&gt; Tuple[Tensor, ...] | BaseModelOutputWithPoolingAndCrossAttentions:\n        r\"\"\"\n        encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n            Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n            the model is configured as a decoder.\n        encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n            the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n            - 1 for tokens that are **not masked**,\n            - 0 for tokens that are **masked**.\n        past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors\n            of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n            Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n        use_cache (`bool`, *optional*):\n            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n            `past_key_values`).\n        \"\"\"\n        if kwargs:\n            warn(\n                f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n                f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n                \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n            )\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        if self.config.is_decoder:\n            use_cache = use_cache if use_cache is not None else self.config.use_cache\n        else:\n            use_cache = False\n\n        if isinstance(input_ids, NestedTensor):\n            input_ids, attention_mask = input_ids.tensor, input_ids.mask\n        if input_ids is not None and inputs_embeds is not None:\n            raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n        if input_ids is not None:\n            self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n            input_shape = input_ids.size()\n        elif inputs_embeds is not None:\n            input_shape = inputs_embeds.size()[:-1]\n        else:\n            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n        batch_size, seq_length = input_shape\n        device = input_ids.device if input_ids is not None else inputs_embeds.device  # type: ignore[union-attr]\n\n        # past_key_values_length\n        past_key_values_length = past_key_values[0][0].shape[2] if past_key_values is not None else 0\n\n        if attention_mask is None:\n            attention_mask = (\n                input_ids.ne(self.pad_token_id)\n                if self.pad_token_id is not None\n                else torch.ones(((batch_size, seq_length + past_key_values_length)), device=device)\n            )\n\n        # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n        # ourselves in which case we just need to make it broadcastable to all heads.\n        extended_attention_mask: Tensor = self.get_extended_attention_mask(attention_mask, input_shape)\n\n        # If a 2D or 3D attention mask is provided for the cross-attention\n        # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n        if self.config.is_decoder and encoder_hidden_states is not None:\n            encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n            encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n            if encoder_attention_mask is None:\n                encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n            encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n        else:\n            encoder_extended_attention_mask = None\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n        head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n        embedding_output = self.embeddings(\n            input_ids=input_ids,\n            position_ids=position_ids,\n            attention_mask=attention_mask,\n            inputs_embeds=inputs_embeds,\n            past_key_values_length=past_key_values_length,\n        )\n        encoder_outputs = self.encoder(\n            embedding_output,\n            attention_mask=extended_attention_mask,\n            head_mask=head_mask,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_extended_attention_mask,\n            past_key_values=past_key_values,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n        sequence_output = encoder_outputs[0]\n        pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n        if not return_dict:\n            return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n        return BaseModelOutputWithPoolingAndCrossAttentions(\n            last_hidden_state=sequence_output,\n            pooler_output=pooled_output,\n            past_key_values=encoder_outputs.past_key_values,\n            hidden_states=encoder_outputs.hidden_states,\n            attentions=encoder_outputs.attentions,\n            cross_attentions=encoder_outputs.cross_attentions,\n        )\n</code></pre>"},{"location":"models/utrlm/#multimolecule.models.utrlm.UtrLmModel.forward","title":"<code>forward(input_ids, attention_mask=None, position_ids=None, head_mask=None, inputs_embeds=None, encoder_hidden_states=None, encoder_attention_mask=None, past_key_values=None, use_cache=None, output_attentions=None, output_hidden_states=None, return_dict=None, **kwargs)</code>","text":"<p>encoder_hidden_states  (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, optional):     Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if     the model is configured as a decoder. encoder_attention_mask (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, optional):     Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in     the cross-attention if the model is configured as a decoder. Mask values selected in <code>[0, 1]</code>:</p> Text Only<pre><code>- 1 for tokens that are **not masked**,\n- 0 for tokens that are **masked**.\n</code></pre> <p>past_key_values (<code>tuple(tuple(torch.FloatTensor))</code> of length <code>config.n_layers</code> with each tuple having 4 tensors     of shape <code>(batch_size, num_heads, sequence_length - 1, embed_size_per_head)</code>):     Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.</p> Text Only<pre><code>If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\ndon't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n`decoder_input_ids` of shape `(batch_size, sequence_length)`.\n</code></pre> <p>use_cache (<code>bool</code>, optional):     If set to <code>True</code>, <code>past_key_values</code> key value states are returned and can be used to speed up decoding (see     <code>past_key_values</code>).</p> Source code in <code>multimolecule/models/utrlm/modeling_utrlm.py</code> Python<pre><code>def forward(\n    self,\n    input_ids: Tensor | NestedTensor,\n    attention_mask: Tensor | None = None,\n    position_ids: Tensor | None = None,\n    head_mask: Tensor | None = None,\n    inputs_embeds: Tensor | NestedTensor | None = None,\n    encoder_hidden_states: Tensor | None = None,\n    encoder_attention_mask: Tensor | None = None,\n    past_key_values: Tuple[Tuple[torch.FloatTensor, torch.FloatTensor], ...] | None = None,\n    use_cache: bool | None = None,\n    output_attentions: bool | None = None,\n    output_hidden_states: bool | None = None,\n    return_dict: bool | None = None,\n    **kwargs,\n) -&gt; Tuple[Tensor, ...] | BaseModelOutputWithPoolingAndCrossAttentions:\n    r\"\"\"\n    encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n        Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n        the model is configured as a decoder.\n    encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n        Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n        the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n        - 1 for tokens that are **not masked**,\n        - 0 for tokens that are **masked**.\n    past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors\n        of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n        Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n        If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n        don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n        `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n    use_cache (`bool`, *optional*):\n        If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n        `past_key_values`).\n    \"\"\"\n    if kwargs:\n        warn(\n            f\"Additional keyword arguments `{', '.join(kwargs)}` are detected in \"\n            f\"`{self.__class__.__name__}.forward`, they will be ignored.\\n\"\n            \"This is provided for backward compatibility and may lead to unexpected behavior.\"\n        )\n    output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n    output_hidden_states = (\n        output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n    )\n    return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n    if self.config.is_decoder:\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n    else:\n        use_cache = False\n\n    if isinstance(input_ids, NestedTensor):\n        input_ids, attention_mask = input_ids.tensor, input_ids.mask\n    if input_ids is not None and inputs_embeds is not None:\n        raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n    if input_ids is not None:\n        self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n        input_shape = input_ids.size()\n    elif inputs_embeds is not None:\n        input_shape = inputs_embeds.size()[:-1]\n    else:\n        raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n    batch_size, seq_length = input_shape\n    device = input_ids.device if input_ids is not None else inputs_embeds.device  # type: ignore[union-attr]\n\n    # past_key_values_length\n    past_key_values_length = past_key_values[0][0].shape[2] if past_key_values is not None else 0\n\n    if attention_mask is None:\n        attention_mask = (\n            input_ids.ne(self.pad_token_id)\n            if self.pad_token_id is not None\n            else torch.ones(((batch_size, seq_length + past_key_values_length)), device=device)\n        )\n\n    # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n    # ourselves in which case we just need to make it broadcastable to all heads.\n    extended_attention_mask: Tensor = self.get_extended_attention_mask(attention_mask, input_shape)\n\n    # If a 2D or 3D attention mask is provided for the cross-attention\n    # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n    if self.config.is_decoder and encoder_hidden_states is not None:\n        encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n        encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n        if encoder_attention_mask is None:\n            encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n        encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n    else:\n        encoder_extended_attention_mask = None\n\n    # Prepare head mask if needed\n    # 1.0 in head_mask indicate we keep the head\n    # attention_probs has shape bsz x n_heads x N x N\n    # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n    # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n    head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n    embedding_output = self.embeddings(\n        input_ids=input_ids,\n        position_ids=position_ids,\n        attention_mask=attention_mask,\n        inputs_embeds=inputs_embeds,\n        past_key_values_length=past_key_values_length,\n    )\n    encoder_outputs = self.encoder(\n        embedding_output,\n        attention_mask=extended_attention_mask,\n        head_mask=head_mask,\n        encoder_hidden_states=encoder_hidden_states,\n        encoder_attention_mask=encoder_extended_attention_mask,\n        past_key_values=past_key_values,\n        use_cache=use_cache,\n        output_attentions=output_attentions,\n        output_hidden_states=output_hidden_states,\n        return_dict=return_dict,\n    )\n    sequence_output = encoder_outputs[0]\n    pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n    if not return_dict:\n        return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n    return BaseModelOutputWithPoolingAndCrossAttentions(\n        last_hidden_state=sequence_output,\n        pooler_output=pooled_output,\n        past_key_values=encoder_outputs.past_key_values,\n        hidden_states=encoder_outputs.hidden_states,\n        attentions=encoder_outputs.attentions,\n        cross_attentions=encoder_outputs.cross_attentions,\n    )\n</code></pre>"},{"location":"models/utrlm/#multimolecule.models.utrlm.UtrLmPreTrainedModel","title":"<code>UtrLmPreTrainedModel</code>","text":"<p>               Bases: <code>PreTrainedModel</code></p> <p>An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained models.</p> Source code in <code>multimolecule/models/utrlm/modeling_utrlm.py</code> Python<pre><code>class UtrLmPreTrainedModel(PreTrainedModel):\n    \"\"\"\n    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n    models.\n    \"\"\"\n\n    config_class = UtrLmConfig\n    base_model_prefix = \"utrlm\"\n    supports_gradient_checkpointing = True\n    _no_split_modules = [\"UtrLmLayer\", \"UtrLmEmbeddings\"]\n\n    # Copied from transformers.models.bert.modeling_bert.BertPreTrainedModel._init_weights\n    def _init_weights(self, module: nn.Module):\n        \"\"\"Initialize the weights\"\"\"\n        if isinstance(module, nn.Linear):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, nn.Embedding):\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.padding_idx is not None:\n                module.weight.data[module.padding_idx].zero_()\n        elif isinstance(module, nn.LayerNorm):\n            module.bias.data.zero_()\n            module.weight.data.fill_(1.0)\n</code></pre>"},{"location":"tokenisers/dna/","title":"DnaTokenizer","text":"<p>DnaTokenizer is smart, it tokenizes raw DNA nucleotides into tokens, no matter if the input is in uppercase or lowercase, uses T (Thymine) or U (Uracil), and with or without special tokens. It also supports tokenization into nmers and codons, so you don\u2019t have to write complex code to preprocess your data.</p> <p>By default, DnaTokenizer uses an extended version of the IUPAC nucleotide code. This extension includes two additional tokens, <code>X</code> and <code>*</code>.</p> <ul> <li><code>X</code>: represents Any base, it is slightly different from <code>N</code> which represents Unknown base.   In automatic word embedding conversion, the <code>X</code> will be initialized as the mean of <code>A</code>, <code>C</code>, <code>G</code>, and <code>T</code>, while <code>N</code> will not be further processed.</li> <li><code>*</code>: is not used in MultiMolecule and is reserved for future use.</li> </ul> <p>If <code>kmers</code> is greater than <code>1</code>, or <code>codon</code> is set to <code>True</code>, the tokenizer will use a minimal alphabet that includes only the five canonical nucleotides <code>A</code>, <code>C</code>, <code>G</code>, <code>T</code>, and <code>N</code>.</p>"},{"location":"tokenisers/dna/#multimolecule.tokenisers.DnaTokenizer","title":"<code>multimolecule.tokenisers.DnaTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>Constructs a DNA tokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>alphabet</code> <code>List[str] | None</code> <p>List of tokens to use. Defaults to IUPAC nucleotide code.</p> <code>None</code> <code>nmers</code> <code>int</code> <p>Size of nmers to tokenize. Defaults to 1.</p> <code>1</code> <code>codon</code> <code>bool</code> <p>Whether to tokenize into codons. Defaults to False.</p> <code>False</code> <code>replace_U_with_T</code> <code>bool</code> <p>Whether to replace U with T. Defaults to True.</p> <code>True</code> <code>do_upper_case</code> <code>bool</code> <p>Whether to convert input to uppercase. Defaults to True.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import DnaTokenizer\n&gt;&gt;&gt; tokenizer = DnaTokenizer()\n&gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGTNXVHDBMRWSYK.*-')[\"input_ids\"]\n[1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 2]\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer = DnaTokenizer(replace_U_with_T=False)\n&gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n[1, 6, 7, 8, 3, 2]\n&gt;&gt;&gt; tokenizer = DnaTokenizer(nmers=3)\n&gt;&gt;&gt; tokenizer('tataaagta')[\"input_ids\"]\n[1, 84, 21, 81, 6, 8, 19, 71, 2]\n&gt;&gt;&gt; tokenizer = DnaTokenizer(codon=True)\n&gt;&gt;&gt; tokenizer('tataaagta')[\"input_ids\"]\n[1, 84, 6, 71, 2]\n&gt;&gt;&gt; tokenizer('tataaagtaa')[\"input_ids\"]\nTraceback (most recent call last):\nValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n</code></pre> Source code in <code>multimolecule/tokenisers/dna/tokenization_dna.py</code> Python<pre><code>class DnaTokenizer(Tokenizer):\n    \"\"\"\n    Constructs a DNA tokenizer.\n\n    Args:\n        alphabet (List[str] | None, optional): List of tokens to use.\n            Defaults to [IUPAC nucleotide code](https://www.bioinformatics.org/sms2/iupac.html).\n        nmers (int, optional): Size of nmers to tokenize.\n            Defaults to 1.\n        codon (bool, optional): Whether to tokenize into codons.\n            Defaults to False.\n        replace_U_with_T (bool, optional): Whether to replace U with T.\n            Defaults to True.\n        do_upper_case (bool, optional): Whether to convert input to uppercase.\n            Defaults to True.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import DnaTokenizer\n        &gt;&gt;&gt; tokenizer = DnaTokenizer()\n        &gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGTNXVHDBMRWSYK.*-')[\"input_ids\"]\n        [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 2]\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer = DnaTokenizer(replace_U_with_T=False)\n        &gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n        [1, 6, 7, 8, 3, 2]\n        &gt;&gt;&gt; tokenizer = DnaTokenizer(nmers=3)\n        &gt;&gt;&gt; tokenizer('tataaagta')[\"input_ids\"]\n        [1, 84, 21, 81, 6, 8, 19, 71, 2]\n        &gt;&gt;&gt; tokenizer = DnaTokenizer(codon=True)\n        &gt;&gt;&gt; tokenizer('tataaagta')[\"input_ids\"]\n        [1, 84, 6, 71, 2]\n        &gt;&gt;&gt; tokenizer('tataaagtaa')[\"input_ids\"]\n        Traceback (most recent call last):\n        ValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n    \"\"\"\n\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n\n    def __init__(\n        self,\n        alphabet: List[str] | None = None,\n        nmers: int = 1,\n        codon: bool = False,\n        bos_token: str = \"&lt;cls&gt;\",\n        cls_token: str = \"&lt;cls&gt;\",\n        pad_token: str = \"&lt;pad&gt;\",\n        eos_token: str = \"&lt;eos&gt;\",\n        sep_token: str = \"&lt;eos&gt;\",\n        unk_token: str = \"&lt;unk&gt;\",\n        mask_token: str = \"&lt;mask&gt;\",\n        additional_special_tokens: List | Tuple | None = None,\n        replace_U_with_T: bool = True,\n        do_upper_case: bool = True,\n        **kwargs,\n    ):\n        if codon and nmers &gt; 1:\n            raise ValueError(\"Codon and nmers cannot be used together.\")\n        if codon:\n            nmers = 3  # set to 3 to get correct vocab\n        super().__init__(\n            alphabet=get_vocab_list(alphabet, nmers),\n            bos_token=bos_token,\n            cls_token=cls_token,\n            pad_token=pad_token,\n            eos_token=eos_token,\n            sep_token=sep_token,\n            unk_token=unk_token,\n            mask_token=mask_token,\n            additional_special_tokens=additional_special_tokens,\n            do_upper_case=do_upper_case,\n            **kwargs,\n        )\n        self.replace_U_with_T = replace_U_with_T\n        self.nmers = nmers\n        self.condon = codon\n\n    def _tokenize(self, text: str, **kwargs):\n        if self.do_upper_case:\n            text = text.upper()\n        if self.replace_U_with_T:\n            text = text.replace(\"U\", \"T\")\n        if self.condon:\n            if len(text) % 3 != 0:\n                raise ValueError(\n                    f\"length of input sequence  must be a multiple of 3 for codon tokenization, but got {len(text)}\"\n                )\n            return [text[i : i + 3] for i in range(0, len(text), 3)]\n        if self.nmers &gt; 1:\n            return [text[i : i + self.nmers] for i in range(len(text) - self.nmers + 1)]  # noqa: E203\n        return list(text)\n</code></pre>"},{"location":"tokenisers/protein/","title":"ProteinTokenizer","text":"<p>ProteinTokenizer is smart, it tokenizes raw amino acids into tokens, no matter if the input is in uppercase or lowercase, and with or without special tokens.</p> <p>By default, ProteinTokenizer uses an extended version of the IUPAC amino acid code. This extension includes nine additional tokens, <code>X</code>, <code>B</code>, <code>Z</code>, <code>J</code>, <code>U</code>, <code>O</code>, <code>.</code>, <code>-</code>, and <code>*</code>.</p> <ul> <li><code>X</code>: Xxx; Any or unknown amino acid</li> <li><code>B</code>: Asx; Aspartic acid (R) or Asparagine (N)</li> <li><code>Z</code>: Glx; Glutamic acid (E) or Glutamine (Q)</li> <li><code>J</code>: Xle; Leucine (L) or Isoleucine (I)</li> <li><code>U</code>: Sec; Selenocysteine</li> <li><code>O</code>: Pyl; Pyrrolysine</li> <li><code>.</code>: is not used in MultiMolecule and is reserved for future use.</li> <li><code>-</code>: is not used in MultiMolecule and is reserved for future use.</li> <li><code>*</code>: is not used in MultiMolecule and is reserved for future use.</li> </ul>"},{"location":"tokenisers/protein/#multimolecule.tokenisers.ProteinTokenizer","title":"<code>multimolecule.tokenisers.ProteinTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>Constructs a Protein tokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>alphabet</code> <code>List[str] | None</code> <p>List of tokens to use. Defaults to IUPAC nucleotide code.</p> <code>None</code> <code>do_upper_case</code> <code>bool</code> <p>Whether to convert input to uppercase. Defaults to True.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import ProteinTokenizer\n&gt;&gt;&gt; tokenizer = ProteinTokenizer()\n&gt;&gt;&gt; tokenizer('ACDEFGHIKLMNPQRSTVWYXBZJUO')[\"input_ids\"]\n[1, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 2]\n&gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;.*-')[\"input_ids\"]\n[1, 0, 1, 2, 3, 4, 5, 32, 33, 34, 2]\n&gt;&gt;&gt; tokenizer('manlgcwmlv')[\"input_ids\"]\n[1, 16, 6, 17, 15, 11, 7, 24, 16, 15, 23, 2]\n</code></pre> Source code in <code>multimolecule/tokenisers/protein/tokenization_protein.py</code> Python<pre><code>class ProteinTokenizer(Tokenizer):\n    \"\"\"\n    Constructs a Protein tokenizer.\n\n    Args:\n        alphabet (List[str] | None, optional): List of tokens to use.\n            Defaults to [IUPAC nucleotide code](https://www.bioinformatics.org/sms2/iupac.html).\n        do_upper_case (bool, optional): Whether to convert input to uppercase.\n            Defaults to True.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import ProteinTokenizer\n        &gt;&gt;&gt; tokenizer = ProteinTokenizer()\n        &gt;&gt;&gt; tokenizer('ACDEFGHIKLMNPQRSTVWYXBZJUO')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 2]\n        &gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;.*-')[\"input_ids\"]\n        [1, 0, 1, 2, 3, 4, 5, 32, 33, 34, 2]\n        &gt;&gt;&gt; tokenizer('manlgcwmlv')[\"input_ids\"]\n        [1, 16, 6, 17, 15, 11, 7, 24, 16, 15, 23, 2]\n    \"\"\"\n\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n\n    def __init__(\n        self,\n        alphabet: List[str] | None = None,\n        bos_token: str = \"&lt;cls&gt;\",\n        cls_token: str = \"&lt;cls&gt;\",\n        pad_token: str = \"&lt;pad&gt;\",\n        eos_token: str = \"&lt;eos&gt;\",\n        sep_token: str = \"&lt;eos&gt;\",\n        unk_token: str = \"&lt;unk&gt;\",\n        mask_token: str = \"&lt;mask&gt;\",\n        additional_special_tokens: List | Tuple | None = None,\n        do_upper_case: bool = True,\n        **kwargs,\n    ):\n        super().__init__(\n            alphabet=get_vocab_list(alphabet),\n            bos_token=bos_token,\n            cls_token=cls_token,\n            pad_token=pad_token,\n            eos_token=eos_token,\n            sep_token=sep_token,\n            unk_token=unk_token,\n            mask_token=mask_token,\n            additional_special_tokens=additional_special_tokens,\n            do_upper_case=do_upper_case,\n            **kwargs,\n        )\n\n    def _tokenize(self, text: str, **kwargs):\n        if self.do_upper_case:\n            text = text.upper()\n        return list(text)\n</code></pre>"},{"location":"tokenisers/rna/","title":"RnaTokenizer","text":"<p>RnaTokenizer is smart, it tokenizes raw RNA nucleotides into tokens, no matter if the input is in uppercase or lowercase, uses U (Uracil) or T (Thymine), and with or without special tokens. It also supports tokenization into nmers and codons, so you don\u2019t have to write complex code to preprocess your data.</p> <p>By default, RnaTokenizer uses an extended version of the IUPAC nucleotide code. This extension includes three additional tokens, <code>I</code>, <code>X</code> and <code>*</code>.</p> <ul> <li><code>I</code> represent Inosine, which is a post-trancriptional modification that is not a standard RNA base.   Inosine is the result of a deamination reaction of adenines that is catalyzed by adenosine deaminases acting on tRNAs (ADATs)</li> <li><code>X</code>: represents Any base, it is slightly different from <code>N</code> which represents Unknown base.   In automatic word embedding conversion, the <code>X</code> will be initialized as the mean of <code>A</code>, <code>C</code>, <code>G</code>, and <code>U</code>, while <code>N</code> will not be further processed.</li> <li><code>*</code>: is not used in MultiMolecule and is reserved for future use.</li> </ul> <p>If <code>kmers</code> is greater than <code>1</code>, or <code>codon</code> is set to <code>True</code>, the tokenizer will use a minimal alphabet that includes only the five canonical nucleotides <code>A</code>, <code>C</code>, <code>G</code>, <code>U</code>, and <code>N</code>.</p>"},{"location":"tokenisers/rna/#multimolecule.tokenisers.RnaTokenizer","title":"<code>multimolecule.tokenisers.RnaTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>Constructs an RNA tokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>alphabet</code> <code>List[str] | None</code> <p>List of tokens to use. Defaults to IUPAC nucleotide code.</p> <code>None</code> <code>nmers</code> <code>int</code> <p>Size of nmers to tokenize. Defaults to 1.</p> <code>1</code> <code>codon</code> <code>bool</code> <p>Whether to tokenize into codons. Defaults to False.</p> <code>False</code> <code>replace_T_with_U</code> <code>bool</code> <p>Whether to replace T with U. Defaults to True.</p> <code>True</code> <code>do_upper_case</code> <code>bool</code> <p>Whether to convert input to uppercase. Defaults to True.</p> <code>True</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from multimolecule import RnaTokenizer\n&gt;&gt;&gt; tokenizer = RnaTokenizer()\n&gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n[1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n&gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 9, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n&gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n[1, 6, 7, 8, 3, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 17, 64, 49, 96, 84, 22, 2]\n&gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n&gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n[1, 83, 49, 22, 2]\n&gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\nTraceback (most recent call last):\nValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n</code></pre> Source code in <code>multimolecule/tokenisers/rna/tokenization_rna.py</code> Python<pre><code>class RnaTokenizer(Tokenizer):\n    \"\"\"\n    Constructs an RNA tokenizer.\n\n    Args:\n        alphabet (List[str] | None, optional): List of tokens to use.\n            Defaults to [IUPAC nucleotide code](https://www.bioinformatics.org/sms2/iupac.html).\n        nmers (int, optional): Size of nmers to tokenize.\n            Defaults to 1.\n        codon (bool, optional): Whether to tokenize into codons.\n            Defaults to False.\n        replace_T_with_U (bool, optional): Whether to replace T with U.\n            Defaults to True.\n        do_upper_case (bool, optional): Whether to convert input to uppercase.\n            Defaults to True.\n\n    Examples:\n        &gt;&gt;&gt; from multimolecule import RnaTokenizer\n        &gt;&gt;&gt; tokenizer = RnaTokenizer()\n        &gt;&gt;&gt; tokenizer('&lt;pad&gt;&lt;cls&gt;&lt;eos&gt;&lt;unk&gt;&lt;mask&gt;&lt;null&gt;ACGUNIXVHDBMRWSYK.*-')[\"input_ids\"]\n        [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 2]\n        &gt;&gt;&gt; tokenizer('acgu')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 9, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(replace_T_with_U=False)\n        &gt;&gt;&gt; tokenizer('acgt')[\"input_ids\"]\n        [1, 6, 7, 8, 3, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(nmers=3)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 17, 64, 49, 96, 84, 22, 2]\n        &gt;&gt;&gt; tokenizer = RnaTokenizer(codon=True)\n        &gt;&gt;&gt; tokenizer('uagcuuauc')[\"input_ids\"]\n        [1, 83, 49, 22, 2]\n        &gt;&gt;&gt; tokenizer('uagcuuauca')[\"input_ids\"]\n        Traceback (most recent call last):\n        ValueError: length of input sequence  must be a multiple of 3 for codon tokenization, but got 10\n    \"\"\"\n\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n\n    def __init__(\n        self,\n        alphabet: List[str] | None = None,\n        nmers: int = 1,\n        codon: bool = False,\n        replace_T_with_U: bool = True,\n        bos_token: str = \"&lt;cls&gt;\",\n        cls_token: str = \"&lt;cls&gt;\",\n        pad_token: str = \"&lt;pad&gt;\",\n        eos_token: str = \"&lt;eos&gt;\",\n        sep_token: str = \"&lt;eos&gt;\",\n        unk_token: str = \"&lt;unk&gt;\",\n        mask_token: str = \"&lt;mask&gt;\",\n        additional_special_tokens: List | Tuple | None = None,\n        do_upper_case: bool = True,\n        **kwargs,\n    ):\n        if codon and nmers &gt; 1:\n            raise ValueError(\"Codon and nmers cannot be used together.\")\n        if codon:\n            nmers = 3  # set to 3 to get correct vocab\n        super().__init__(\n            alphabet=get_vocab_list(alphabet, nmers),\n            bos_token=bos_token,\n            cls_token=cls_token,\n            pad_token=pad_token,\n            eos_token=eos_token,\n            sep_token=sep_token,\n            unk_token=unk_token,\n            mask_token=mask_token,\n            additional_special_tokens=additional_special_tokens,\n            do_upper_case=do_upper_case,\n            **kwargs,\n        )\n        self.replace_T_with_U = replace_T_with_U\n        self.nmers = nmers\n        self.condon = codon\n\n    def _tokenize(self, text: str, **kwargs):\n        if self.do_upper_case:\n            text = text.upper()\n        if self.replace_T_with_U:\n            text = text.replace(\"T\", \"U\")\n        if self.condon:\n            if len(text) % 3 != 0:\n                raise ValueError(\n                    f\"length of input sequence  must be a multiple of 3 for codon tokenization, but got {len(text)}\"\n                )\n            return [text[i : i + 3] for i in range(0, len(text), 3)]\n        if self.nmers &gt; 1:\n            return [text[i : i + self.nmers] for i in range(len(text) - self.nmers + 1)]  # noqa: E203\n        return list(text)\n</code></pre>"},{"location":"zh/#_1","title":"\u4ecb\u7ecd","text":"<p>\u200b\u6b22\u8fce\u200b\u6765\u5230\u200b MultiMolecule (\u200b\u6d66\u539f\u200b)\uff0c\u200b\u8fd9\u662f\u200b\u4e00\u4e2a\u200b\u901a\u8fc7\u200b\u673a\u5668\u200b\u5b66\u4e60\u200b\u52a0\u901f\u200b\u79d1\u5b66\u7814\u7a76\u200b\u7684\u200b\u57fa\u7840\u200b\u5e93\u200b\u3002MultiMolecule \u200b\u65e8\u5728\u200b\u4e3a\u200b\u5e0c\u671b\u200b\u5728\u200b\u5de5\u4f5c\u200b\u5f53\u4e2d\u200b\u4f7f\u7528\u200b AI \u200b\u7684\u200b\u7814\u7a76\u200b\u4eba\u5458\u200b\u63d0\u4f9b\u200b\u4e00\u5957\u200b\u5168\u9762\u200b\u800c\u200b\u7075\u6d3b\u200b\u7684\u200b\u5de5\u5177\u200b\u3002</p> <p>\u200b\u6211\u4eec\u200b\u7406\u89e3\u200b AI4Science \u200b\u662f\u200b\u4e00\u4e2a\u200b\u5e7f\u6cdb\u200b\u7684\u200b\u9886\u57df\u200b\uff0c\u200b\u6765\u81ea\u200b\u4e0d\u540c\u200b\u5b66\u79d1\u200b\u7684\u200b\u7814\u7a76\u200b\u4eba\u5458\u200b\u4f7f\u7528\u200b\u5404\u79cd\u200b\u5b9e\u8df5\u200b\u65b9\u6cd5\u200b\u3002\u200b\u56e0\u6b64\u200b\uff0cMultiMolecule \u200b\u8bbe\u8ba1\u200b\u65f6\u200b\u8003\u8651\u200b\u4e86\u200b\u4f4e\u200b\u8026\u5408\u200b\u6027\u200b\uff0c\u200b\u8fd9\u200b\u610f\u5473\u7740\u200b\u867d\u7136\u200b\u5b83\u200b\u63d0\u4f9b\u200b\u4e86\u200b\u5b8c\u6574\u200b\u7684\u200b\u529f\u80fd\u200b\u5957\u4ef6\u200b\uff0c\u200b\u4f46\u200b\u6bcf\u4e2a\u200b\u6a21\u5757\u200b\u90fd\u200b\u53ef\u4ee5\u200b\u72ec\u7acb\u200b\u4f7f\u7528\u200b\u3002\u200b\u8fd9\u4f7f\u200b\u60a8\u200b\u53ef\u4ee5\u200b\u4ec5\u200b\u5c06\u200b\u6240\u200b\u9700\u200b\u7ec4\u4ef6\u200b\u96c6\u6210\u200b\u5230\u200b\u73b0\u6709\u200b\u5de5\u4f5c\u200b\u6d41\u7a0b\u200b\u4e2d\u200b\uff0c\u200b\u800c\u200b\u4e0d\u4f1a\u200b\u589e\u52a0\u200b\u4e0d\u5fc5\u8981\u200b\u7684\u200b\u590d\u6742\u6027\u200b\u3002MultiMolecule \u200b\u63d0\u4f9b\u200b\u7684\u200b\u4e3b\u8981\u200b\u529f\u80fd\u200b\u5305\u62ec\u200b\uff1a</p> <ul> <li><code>data</code>: \u200b\u9ad8\u6548\u200b\u7684\u200b\u6570\u636e\u5904\u7406\u200b\u548c\u200b\u9884\u5904\u7406\u200b\u529f\u80fd\u200b\uff0c\u200b\u4ee5\u200b\u7b80\u5316\u200b\u79d1\u5b66\u200b\u6570\u636e\u200b\u96c6\u200b\u7684\u200b\u6444\u53d6\u200b\u548c\u200b\u8f6c\u6362\u200b\u3002</li> <li><code>modules</code>: \u200b\u65e8\u5728\u200b\u63d0\u4f9b\u200b\u7075\u6d3b\u6027\u200b\u548c\u200b\u53ef\u200b\u91cd\u7528\u200b\u6027\u200b\u7684\u200b\u6a21\u5757\u5316\u200b\u7ec4\u4ef6\u200b\uff0c\u200b\u9002\u7528\u200b\u4e8e\u200b\u5404\u79cd\u200b\u673a\u5668\u200b\u5b66\u4e60\u200b\u4efb\u52a1\u200b\u3002</li> <li><code>models</code>: \u200b\u4e3a\u200b\u79d1\u5b66\u7814\u7a76\u200b\u5e94\u7528\u200b\u4f18\u5316\u200b\u7684\u200b\u6700\u200b\u5148\u8fdb\u200b\u6a21\u578b\u200b\u67b6\u6784\u200b\uff0c\u200b\u786e\u4fdd\u200b\u9ad8\u6027\u80fd\u200b\u548c\u200b\u9ad8\u200b\u51c6\u786e\u6027\u200b\u3002</li> <li><code>tokenisers</code>: \u200b\u5148\u8fdb\u200b\u7684\u200b\u5206\u8bcd\u200b\u65b9\u6cd5\u200b\uff0c\u200b\u6709\u6548\u200b\u5904\u7406\u200b\u590d\u6742\u200b\u7684\u200b\u79d1\u5b66\u200b\u6587\u672c\u200b\u548c\u200b\u6570\u636e\u8868\u793a\u200b\u3002</li> <li><code>utils</code>: \u200b\u4e00\u7cfb\u5217\u200b\u5b9e\u7528\u200b\u51fd\u6570\u200b\u548c\u200b\u5de5\u5177\u200b\uff0c\u200b\u7b80\u5316\u200b\u5e38\u89c1\u200b\u4efb\u52a1\u200b\u5e76\u200b\u589e\u5f3a\u200b\u6574\u4f53\u200b\u7528\u6237\u200b\u4f53\u9a8c\u200b\u3002</li> </ul>"},{"location":"zh/#_2","title":"\u5b89\u88c5","text":"<p>\u200b\u4ece\u200b PyPI \u200b\u5b89\u88c5\u200b\u6700\u65b0\u200b\u7684\u200b\u7a33\u5b9a\u200b\u7248\u672c\u200b\uff1a</p> Bash<pre><code>pip install multimolecule\n</code></pre> <p>\u200b\u4ece\u200b\u6e90\u4ee3\u7801\u200b\u5b89\u88c5\u200b\u6700\u65b0\u200b\u7248\u672c\u200b\uff1a</p> Bash<pre><code>pip install git+https://github.com/DLS5-Omics/MultiMolecule\n</code></pre>"},{"location":"zh/#_3","title":"\u8bb8\u53ef\u8bc1","text":"<p>\u200b\u6211\u4eec\u200b\u76f8\u4fe1\u200b\u5f00\u653e\u200b\u662f\u200b\u7814\u7a76\u200b\u7684\u200b\u57fa\u7840\u200b\u3002</p> <p>MultiMolecule \u200b\u5728\u200b GNU Affero \u200b\u901a\u7528\u200b\u516c\u5171\u200b\u8bb8\u53ef\u8bc1\u200b\u4e0b\u200b\u6388\u6743\u200b\u3002</p> <p>\u200b\u8bf7\u200b\u52a0\u5165\u200b\u6211\u4eec\u200b\uff0c\u200b\u5171\u540c\u200b\u5efa\u7acb\u200b\u4e00\u4e2a\u200b\u5f00\u653e\u200b\u7684\u200b\u7814\u7a76\u200b\u793e\u533a\u200b\u3002</p> <p><code>SPDX-License-Identifier: AGPL-3.0-or-later</code></p>"},{"location":"zh/models/#_1","title":"\u6a21\u578b","text":"<p><code>models</code> \u200b\u63d0\u4f9b\u200b\u4e86\u200b\u4e00\u7cfb\u5217\u200b\u9884\u200b\u8bad\u7ec3\u200b\u6a21\u578b\u200b\u3002</p>"},{"location":"zh/models/#_2","title":"\u6a21\u578b\u200b\u7c7b","text":"<p>\u200b\u5728\u200b <code>transformers</code> \u200b\u5e93\u200b\u5f53\u4e2d\u200b\uff0c\u200b\u6a21\u578b\u200b\u7c7b\u200b\u7684\u200b\u540d\u5b57\u200b\u6709\u65f6\u200b\u53ef\u4ee5\u200b\u5f15\u8d77\u200b\u8bef\u89e3\u200b\u3002 \u200b\u5c3d\u7ba1\u200b\u8fd9\u4e9b\u200b\u7c7b\u200b\u652f\u6301\u200b\u56de\u5f52\u200b\u548c\u200b\u5206\u7c7b\u200b\u4efb\u52a1\u200b\uff0c\u200b\u4f46\u200b\u5b83\u4eec\u200b\u7684\u200b\u540d\u5b57\u200b\u901a\u5e38\u200b\u5305\u542b\u200b <code>xxxForSequenceClassification</code>\uff0c\u200b\u8fd9\u200b\u53ef\u80fd\u200b\u6697\u793a\u200b\u5b83\u4eec\u200b\u53ea\u80fd\u200b\u7528\u4e8e\u200b\u5206\u7c7b\u200b\u3002</p> <p>\u200b\u4e3a\u4e86\u200b\u907f\u514d\u200b\u8fd9\u79cd\u200b\u6b67\u4e49\u200b\uff0cMultiMolecule \u200b\u63d0\u4f9b\u200b\u4e86\u200b\u4e00\u7cfb\u5217\u200b\u6a21\u578b\u200b\u7c7b\u200b\uff0c\u200b\u8fd9\u4e9b\u200b\u7c7b\u200b\u7684\u200b\u540d\u79f0\u200b\u6e05\u6670\u200b\u3001\u200b\u76f4\u89c2\u200b\uff0c\u200b\u53cd\u6620\u200b\u4e86\u200b\u5b83\u4eec\u200b\u7684\u200b\u9884\u671f\u200b\u7528\u9014\u200b\uff1a</p> <ul> <li><code>multimolecule.AutoModelForContactPrediction</code>: \u200b\u63a5\u89e6\u200b\u9884\u6d4b\u200b</li> <li><code>multimolecule.AutoModelForNucleotidePrediction</code>: \u200b\u6838\u82f7\u9178\u200b\u9884\u6d4b\u200b</li> <li><code>multimolecule.AutoModelForSequencePrediction</code>: \u200b\u5e8f\u5217\u200b\u9884\u6d4b\u200b</li> <li><code>multimolecule.AutoModelForTokenPrediction</code>: \u200b\u4ee4\u724c\u200b\u9884\u6d4b\u200b</li> </ul> <p>\u200b\u6bcf\u4e2a\u200b\u6a21\u578b\u200b\u90fd\u200b\u652f\u6301\u200b\u56de\u5f52\u200b\u548c\u200b\u5206\u7c7b\u200b\u4efb\u52a1\u200b\uff0c\u200b\u4e3a\u200b\u5e7f\u6cdb\u200b\u7684\u200b\u5e94\u7528\u200b\u63d0\u4f9b\u200b\u4e86\u200b\u7075\u6d3b\u6027\u200b\u548c\u200b\u7cbe\u5ea6\u200b\u3002</p>"},{"location":"zh/models/#_3","title":"\u6838\u82f7\u9178\u200b\u9884\u6d4b","text":"<p>\u200b\u4e0e\u200b Token Classification \u200b\u7c7b\u4f3c\u200b\uff0c\u200b\u4f46\u200b\u5982\u679c\u200b\u6a21\u578b\u200b\u914d\u7f6e\u200b\u4e2d\u200b\u5b9a\u4e49\u200b\u4e86\u200b <code>&lt;bos&gt;</code> \u200b\u6216\u200b <code>&lt;eos&gt;</code> \u200b\u4ee4\u724c\u200b\uff0c\u200b\u5219\u200b\u5c06\u200b\u5176\u200b\u79fb\u9664\u200b\u3002</p> <p><code>&lt;bos&gt;</code> \u200b\u548c\u200b <code>&lt;eos&gt;</code> \u200b\u4ee4\u724c\u200b</p> <p>\u200b\u5728\u200b MultiMolecule \u200b\u63d0\u4f9b\u200b\u7684\u200b\u5206\u8bcd\u5668\u200b\u4e2d\u200b\uff0c<code>&lt;bos&gt;</code> \u200b\u4ee4\u724c\u200b\u6307\u5411\u200b <code>&lt;cls&gt;</code> \u200b\u4ee4\u724c\u200b\uff0c<code>&lt;sep&gt;</code> \u200b\u4ee4\u724c\u200b\u6307\u5411\u200b <code>&lt;eos&gt;</code> \u200b\u4ee4\u724c\u200b\u3002</p>"},{"location":"zh/models/#_4","title":"\u4f7f\u7528","text":""},{"location":"zh/models/#multimoleculeautomodel","title":"\u4f7f\u7528\u200b <code>multimolecule.AutoModel</code> \u200b\u6784\u5efa","text":"Python<pre><code>from transformers import AutoTokenizer\n\nfrom multimolecule import AutoModelForSequencePrediction\n\nmodel = AutoModelForSequencePrediction.from_pretrained(\"multimolecule/rnafm\")\ntokenizer = AutoTokenizer.from_pretrained(\"multimolecule/rnafm\")\n\nsequence = \"UAGCGUAUCAGACUGAUGUUG\"\noutput = model(**tokenizer(sequence, return_tensors=\"pt\"))\n</code></pre>"},{"location":"zh/models/#_5","title":"\u76f4\u63a5\u200b\u8bbf\u95ee","text":"<p>\u200b\u6240\u6709\u200b\u6a21\u578b\u200b\u53ef\u4ee5\u200b\u901a\u8fc7\u200b <code>from_pretrained</code> \u200b\u65b9\u6cd5\u200b\u76f4\u63a5\u200b\u52a0\u8f7d\u200b\u3002</p> Python<pre><code>from multimolecule.models import RnaFmForNucleotidePrediction, RnaTokenizer\n\nmodel = RnaFmForNucleotidePrediction.from_pretrained(\"multimolecule/rnafm\")\ntokenizer = RnaTokenizer.from_pretrained(\"multimolecule/rnafm\")\n\nsequence = \"UAGCGUAUCAGACUGAUGUUG\"\noutput = model(**tokenizer(sequence, return_tensors=\"pt\"))\n</code></pre>"},{"location":"zh/models/#transformersautomodel","title":"\u4f7f\u7528\u200b <code>transformers.AutoModel</code> \u200b\u6784\u5efa","text":"<p>\u200b\u867d\u7136\u200b\u6211\u4eec\u200b\u4e3a\u200b\u6a21\u578b\u200b\u7c7b\u200b\u4f7f\u7528\u200b\u4e86\u200b\u4e0d\u540c\u200b\u7684\u200b\u547d\u540d\u200b\u7ea6\u5b9a\u200b\uff0c\u200b\u4f46\u200b\u6a21\u578b\u200b\u4ecd\u7136\u200b\u6ce8\u518c\u200b\u5230\u200b\u76f8\u5e94\u200b\u7684\u200b <code>transformers.AutoModel</code> \u200b\u4e2d\u200b\u3002</p> Python<pre><code>from transformers import AutoModelForSequenceClassification, AutoTokenizer\n\nimport multimolecule  # noqa: F401\n\nmodel = AutoModelForSequenceClassification.from_pretrained(\"multimolecule/mrnafm\")\ntokenizer = AutoTokenizer.from_pretrained(\"multimolecule/mrnafm\")\n\nsequence = \"UAGCGUAUCAGACUGAUGUUG\"\noutput = model(**tokenizer(sequence, return_tensors=\"pt\"))\n</code></pre> <p>\u200b\u4f7f\u7528\u200b\u524d\u5148\u200b <code>import multimolecule</code></p> <p>\u200b\u8bf7\u200b\u6ce8\u610f\u200b\uff0c\u200b\u5728\u200b\u4f7f\u7528\u200b <code>transformers.AutoModel</code> \u200b\u6784\u5efa\u200b\u6a21\u578b\u200b\u4e4b\u524d\u200b\uff0c\u200b\u5fc5\u987b\u200b\u5148\u200b <code>import multimolecule</code>\u3002 \u200b\u6a21\u578b\u200b\u7684\u200b\u6ce8\u518c\u200b\u5728\u200b <code>multimolecule</code> \u200b\u5305\u4e2d\u200b\u5b8c\u6210\u200b\uff0c\u200b\u6a21\u578b\u200b\u5728\u200b <code>transformers</code> \u200b\u5305\u4e2d\u200b\u4e0d\u53ef\u200b\u7528\u200b\u3002</p> <p>\u200b\u5982\u679c\u200b\u5728\u200b\u4f7f\u7528\u200b <code>transformers.AutoModel</code> \u200b\u4e4b\u524d\u200b\u672a\u200b <code>import multimolecule</code>\uff0c\u200b\u5c06\u4f1a\u200b\u5f15\u53d1\u200b\u4ee5\u4e0b\u200b\u9519\u8bef\u200b\uff1a</p> Python<pre><code>ValueError: The checkpoint you are trying to load has model type `rnafm` but Transformers does not recognize this architecture. This could be because of an issue with the checkpoint, or because your version of Transformers is out of date.\n</code></pre>"},{"location":"zh/models/#_6","title":"\u521d\u59cb\u5316\u200b\u4e00\u4e2a\u200b\u9999\u8349\u200b\u6a21\u578b","text":"<p>\u200b\u4f60\u200b\u4e5f\u200b\u53ef\u4ee5\u200b\u4f7f\u7528\u200b\u6a21\u578b\u200b\u7c7b\u200b\u521d\u59cb\u5316\u200b\u4e00\u4e2a\u200b\u57fa\u7840\u200b\u6a21\u578b\u200b\u3002</p> Python<pre><code>from multimolecule.models import RnaFmConfig, RnaFmForNucleotidePrediction, RnaTokenizer\n\nconfig = RnaFmConfig()\nmodel = RnaFmForNucleotidePrediction(config)\ntokenizer = RnaTokenizer()\n\nsequence = \"UAGCGUAUCAGACUGAUGUUG\"\noutput = model(**tokenizer(sequence, return_tensors=\"pt\"))\n</code></pre>"},{"location":"zh/models/#_7","title":"\u53ef\u7528\u200b\u6a21\u578b","text":""},{"location":"zh/models/#dna","title":"\u8131\u6c27\u6838\u7cd6\u6838\u9178\u200b\uff08DNA\uff09","text":"<ul> <li>CaLM</li> </ul>"},{"location":"zh/models/#rna","title":"\u6838\u7cd6\u6838\u9178\u200b\uff08RNA\uff09","text":"<ul> <li>ERNIE-RNA</li> <li>RiNALMo</li> <li>RNABERT</li> <li>RNA-FM</li> <li>RNA-MSM</li> <li>SpliceBERT</li> <li>3UTRBERT</li> <li>UTR-LM</li> </ul>"},{"location":"zh/tokenisers/#tokenisers","title":"Tokenisers","text":"<p><code>tokenisers</code> \u200b\u63d0\u4f9b\u200b\u4e86\u200b\u4e00\u7cfb\u5217\u200b\u9884\u5b9a\u200b\u4e49\u200b\u4ee4\u724c\u200b\u5668\u200b\u3002</p> <p>\u200b\u4ee4\u724c\u200b\u5668\u662f\u200b\u4e00\u4e2a\u200b\u5c06\u200b\u6838\u82f7\u9178\u200b\u6216\u200b\u6c28\u57fa\u9178\u200b\u5e8f\u5217\u200b\u8f6c\u6362\u200b\u4e3a\u200b\u7d22\u5f15\u200b\u5e8f\u5217\u200b\u7684\u200b\u7c7b\u200b\u3002\u200b\u5b83\u200b\u7528\u4e8e\u200b\u5728\u200b\u5c06\u200b\u8f93\u5165\u200b\u5e8f\u5217\u200b\u9988\u9001\u200b\u5230\u200b\u6a21\u578b\u200b\u4e4b\u524d\u200b\u5bf9\u200b\u5176\u200b\u8fdb\u884c\u200b\u9884\u5904\u7406\u200b\u3002</p> <p>\u200b\u8bf7\u53c2\u9605\u200b Tokenizer \u200b\u4e86\u89e3\u200b\u66f4\u200b\u591a\u200b\u7ec6\u8282\u200b\u3002</p>"},{"location":"zh/tokenisers/#_1","title":"\u53ef\u7528\u200b\u4ee4\u724c\u200b\u5668","text":"<ul> <li>RnaTokenizer</li> <li>DnaTokenizer</li> <li>ProteinTokenizer</li> </ul>"}]}